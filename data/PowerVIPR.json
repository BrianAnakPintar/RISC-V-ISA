[
    {
        "mnemonic": "vec_abs",
        "name": "Vector Absolute Value",
        "syntax": "r = vec_abs (a)",
        "purpose": "Returns a vector r that contains the\n      absolute values of the contents of the vector\n      a.",
        "result": "The value of each element of r is the\n      absolute value of the corresponding element of\n      a.  For integer vectors, the arithmetic\n      is modular.",
        "endianness": "None.",
        "instructions": [ "vspltisw", "vsububm", "vmaxsb", "vsubuwm", "vmaxsw", "vsubudm", "vmaxsd", "xvabssp", "xvabsdp" ],
        "type_signatures": {
            "var_heads": [ "r", "a", "Example Implementation" ],
            "list": [
                [ "vector signed char", "vector signed char", "vspltisw t,0\n   vsububm  t,t,a\n   vmaxsb   r,t,a" ],
                [ "vector signed short", "vector signed short", "vspltisw t,0\n   vsubuhm  t,t,a\n   vmaxsh   r,t,a" ],
                [ "vector signed int", "vector signed int", "vspltisw t,0\n   vsubuwm  t,t,a\n   vmaxsw   r,t,a" ],
                [ "vector signed long long", "vector signed long long", "vspltisw t,0\n   vsubudm  t,t,a\n   vmaxsd   r,t,a" ],
                [ "vector float", "vector float", "xvabssp  r,a" ],
                [ "vector double", "vector double", "xvabsdp  r,a" ]
            ]
        }
    },
    {
        "mnemonic": "vec_absd",
        "name": "Vector Absolute Difference",
        "syntax": "r = vec_absd (a, b)",
        "purpose": "Computes the absolute difference of two vectors.",
        "result": "The value of each element of r is the\n      absolute difference of the corresponding elements of a and b, using\n      modular arithmetic.",
        "endianness": "None.",
        "instructions": [ "vabsdub", "vabsduh", "vabsduw" ],
        "type_signatures": {
            "var_heads": [ "r", "a", "b", "Example Implementation", "Restrictions" ],
            "list": [
                [ "vector unsigned char", "vector unsigned char", "vector unsigned char", "vabsdub r,a,b", "ISA 3.0 or later" ],
                [ "vector unsigned short", "vector unsigned short", "vector unsigned short", "vabsduh r,a,b", "ISA 3.0 or later" ],
                [ "vector unsigned int", "vector unsigned int", "vector unsigned int", "vabsduw r,a,b", "ISA 3.0 or later" ]
            ]
        }
    },
    {
        "mnemonic": "vec_abss",
        "name": "Vector Absolute Value Saturated",
        "syntax": "r = vec_abss (a)",
        "purpose": "Returns a vector r that contains the\n      saturated absolute values of the contents of the vector\n      a.",
        "result": "The value of each element of r is the\n      saturated absolute value of the corresponding element of\n      a.",
        "endianness": "None.",
        "instructions": [ "vspltisb", "vsubsbs", "vmaxsb", "vspltish", "vsubshs", "vmaxsh", "vspltisw", "vsubsws", "vmaxsw" ],
        "type_signatures": {
            "var_heads": [ "r", "a", "Example Implementation" ],
            "list": [
                [ "vector signed char", "vector signed char", "vspltisb t,0\n   vsubsbs  t,t,a\n   vmaxsb   r,t,a" ],
                [ "vector signed short", "vector signed short", "vspltish t,0\n   vsubshs  t,t,a\n   vmaxsh   r,t,a" ],
                [ "vector signed int", "vector signed int", "vspltisw t,0\n   vsubsws  t,t,a\n   vmaxsw   r,t,a" ]
            ]
        }
    },
    {
        "mnemonic": "vec_add",
        "name": "Vector Addition",
        "syntax": "r = vec_add (a, b)",
        "purpose": "Computes the sum of two vectors.",
        "result": "The value of each element of r is the\n      sum of the corresponding elements of a and b.  Modular\n      arithmetic is used for both signed and unsigned integers.",
        "endianness": "None.",
        "instructions": [ "vaddubm", "vadduhm", "vadduwm", "vaddudm", "vadduqm", "xvaddsp", "xvadddp" ],
        "type_signatures": {
            "var_heads": [ "r", "a", "b", "Example Implementation" ],
            "list": [
                [ "vector signed char", "vector signed char", "vector signed char", "vaddubm r,a,b" ],
                [ "vector unsigned char", "vector unsigned char", "vector unsigned char", "vaddubm r,a,b" ],
                [ "vector signed short", "vector signed short", "vector signed short", "vadduhm r,a,b" ],
                [ "vector unsigned short", "vector unsigned short", "vector unsigned short", "vadduhm r,a,b" ],
                [ "vector signed int", "vector signed int", "vector signed int", "vadduwm r,a,b" ],
                [ "vector unsigned int", "vector unsigned int", "vector unsigned int", "vadduwm r,a,b" ],
                [ "vector signed long long", "vector signed long long", "vector signed long long", "vaddudm r,a,b" ],
                [ "vector unsigned long long", "vector unsigned long long", "vector unsigned long long", "vaddudm r,a,b" ],
                [ "vector signed __int128", "vector signed __int128", "vector signed __int128", "vadduqm r,a,b" ],
                [ "vector unsigned __int128", "vector unsigned __int128", "vector unsigned __int128", "vadduqm r,a,b" ],
                [ "vector float", "vector float", "vector float", "xvaddsp r,a,b" ],
                [ "vector double", "vector double", "vector double", "xvadddp r,a,b" ]
            ]
        }
    },
    {
        "mnemonic": "vec_addc",
        "name": "Vector Add Carrying",
        "syntax": "r = vec_addc (a, b)",
        "purpose": "Returns a vector of carries produced by adding two vectors.",
        "result": "The value of each element of r is the\n      carry produced by adding the corresponding elements of a and b (1\n      if there is a carry, 0 otherwise).",
        "endianness": "None.",
        "instructions": [ "vaddcuw", "vaddcuq" ],
        "type_signatures": {
            "var_heads": [ "r", "a", "b", "Example Implementation" ],
            "list": [
                [ "vector signed int", "vector signed int", "vector signed int", "vaddcuw r,a,b" ],
                [ "vector unsigned int", "vector unsigned int", "vector unsigned int", "vaddcuw r,a,b" ],
                [ "vector signed __int128", "vector signed __int128", "vector signed __int128", "vaddcuq r,a,b" ],
                [ "vector unsigned __int128", "vector unsigned __int128", "vector unsigned __int128", "vaddcuq r,a,b" ]
            ]
        }
    },
    {
        "mnemonic": "vec_adde",
        "name": "Vector Add Extended",
        "syntax": "r = vec_adde (a, b, c)",
        "purpose": "Returns a vector formed as the sum of two vectors and a carry vector.",
        "result": "The value of each element of r is\n      produced by adding the corresponding elements of a and b with\n      a carry specified in the corresponding element of c (1 if there is a carry, 0 otherwise).",
        "endianness": "None.",
        "instructions": [ "vspltisw", "vadduwm", "xxland", "vaddeuqm" ],
        "type_signatures": {
            "var_heads": [ "r", "a", "b", "c", "Example Implementation" ],
            "list": [
                [ "vector signed int", "vector signed int", "vector signed int", "vector signed int", "vspltisw t,1\n   vadduwm  r,a,b\n   xxland   c,c,t\n   vadduwm  r,r,c" ],
                [ "vector unsigned int", "vector unsigned int", "vector unsigned int", "vector unsigned int", "vspltisw t,1\n   vadduwm  r,a,b\n   xxland   c,c,t\n   vadduwm  r,r,c" ],
                [ "vector signed __int128", "vector signed __int128", "vector signed __int128", "vector signed __int128", "vaddeuqm r,a,b,c" ],
                [ "vector unsigned __int128", "vector unsigned __int128", "vector unsigned __int128", "vector unsigned __int128", "vaddeuqm r,a,b,c" ]
            ]
        }
    },
    {
        "mnemonic": "vec_addec",
        "name": "Vector Add Extended Carrying",
        "syntax": "r = vec_addec (a, b, c)",
        "purpose": "Returns a vector of carries produced by adding two vectors and\n      a carry vector.",
        "result": "The value of each element of r is\n      the carry produced by adding the corresponding elements of a and b and\n      a carry specified in the corresponding element of c (1 if there is a carry, 0 otherwise).",
        "endianness": "None.",
        "instructions": [ "vspltisw", "xxland", "vadduwm", "vaddcuw", "xxlor", "vaddecuq" ],
        "type_signatures": {
            "var_heads": [ "r", "a", "b", "c", "Example Implementation" ],
            "list": [
                [ "vector signed int", "vector signed int", "vector signed int", "vector signed int", "vspltisw t,1\n   xxland   u,c,t\n   vadduwm  v,a,b\n   vaddcuw  w,a,b\n   vaddcuw  x,v,u\n   xxlor    r,w,x" ],
                [ "vector unsigned int", "vector unsigned int", "vector unsigned int", "vector unsigned int", "vspltisw t,1\n   xxland   u,c,t\n   vadduwm  v,a,b\n   vaddcuw  w,a,b\n   vaddcuw  x,v,u\n   xxlor    r,w,x" ],
                [ "vector signed __int128", "vector signed __int128", "vector signed __int128", "vector signed __int128", "vaddecuq r,a,b,c" ],
                [ "vector unsigned __int128", "vector unsigned __int128", "vector unsigned __int128", "vector unsigned __int128", "vaddecuq r,a,b,c" ]
            ]
        }
    },
    {
        "mnemonic": "vec_adds",
        "name": "Vector Add Saturating",
        "syntax": "r = vec_adds (a, b)",
        "purpose": "Computes the saturated sum of two vectors.",
        "result": "The value of each element of r is the\n      saturated sum of the corresponding elements of a and b.",
        "endianness": "None.",
        "instructions": [ "vaddsbs", "vaddubs", "vaddshs", "vadduhs", "vaddsws", "vadduws" ],
        "type_signatures": {
            "var_heads": [ "r", "a", "b", "Example Implementation" ],
            "list": [
                [ "vector signed char", "vector signed char", "vector signed char", "vaddsbs r,a,b" ],
                [ "vector unsigned char", "vector unsigned char", "vector unsigned char", "vaddubs r,a,b" ],
                [ "vector signed short", "vector signed short", "vector signed short", "vaddshs r,a,b" ],
                [ "vector unsigned short", "vector unsigned short", "vector unsigned short", "vadduhs r,a,b" ],
                [ "vector signed int", "vector signed int", "vector signed int", "vaddsws r,a,b" ],
                [ "vector unsigned int", "vector unsigned int", "vector unsigned int", "vadduws r,a,b" ]
            ]
        }
    },
    {
        "mnemonic": "vec_all_eq",
        "name": "Vector All Equal",
        "syntax": "r = vec_all_eq (a, b)",
        "purpose": "Tests whether all elements of a\n      are equal to the corresponding elements of b.",
        "result": "r is 1 if each\n      element of a is equal to the\n      corresponding element of b. Otherwise,\n      r is 0.",
        "endianness": "None.",
        "instructions": [ "vcmpequb.", "mfocrf", "rlwinm", "vcmpequw.", "vcmpequd.", "vcmpequh.", "xvcmpeqdp.", "xvcmpeqsp." ],
        "type_signatures": {
            "var_heads": [ "r", "a", "b", "Example Implementation" ],
            "list": [
                [ "int", "vector bool char", "vector bool char", "vcmpequb.  t,a,b\n  mfocrf     u,2\n  rlwinm     r,u,25,1" ],
                [ "int", "vector signed char", "vector signed char", "vcmpequb.  t,a,b\n  mfocrf     u,2\n  rlwinm     r,u,25,1" ],
                [ "int", "vector unsigned char", "vector unsigned char", "vcmpequb.  t,a,b\n  mfocrf     u,2\n  rlwinm     r,u,25,1" ],
                [ "int", "vector bool short", "vector bool short", "vcmpequh.  t,a,b\n  mfocrf     u,2\n  rlwinm     r,u,25,1" ],
                [ "int", "vector signed short", "vector signed short", "vcmpequh.  t,a,b\n  mfocrf     u,2\n  rlwinm     r,u,25,1" ],
                [ "int", "vector unsigned short", "vector unsigned short", "vcmpequh.  t,a,b\n  mfocrf     u,2\n  rlwinm     r,u,25,1" ],
                [ "int", "vector pixel", "vector pixel", "vcmpequh.  t,a,b\n  mfocrf     u,2\n  rlwinm     r,u,25,1" ],
                [ "int", "vector bool int", "vector bool int", "vcmpequw.  t,a,b\n  mfocrf     u,2\n  rlwinm     r,u,25,1" ],
                [ "int", "vector signed int", "vector signed int", "vcmpequw.  t,a,b\n  mfocrf     u,2\n  rlwinm     r,u,25,1" ],
                [ "int", "vector unsigned int", "vector unsigned int", "vcmpequw.  t,a,b\n  mfocrf     u,2\n  rlwinm     r,u,25,1" ],
                [ "int", "vector bool long long", "vector bool long long", "vcmpequd.  t,a,b\n  mfocrf     u,2\n  rlwinm     r,u,25,1" ],
                [ "int", "vector signed long long", "vector signed long long", "vcmpequd.  t,a,b\n  mfocrf     u,2\n  rlwinm     r,u,25,1" ],
                [ "int", "vector unsigned long long", "vector unsigned long long", "vcmpequd.  t,a,b\n  mfocrf     u,2\n  rlwinm     r,u,25,1" ],
                [ "int", "vector float", "vector float", "xvcmpeqsp.  t,a,b\n  mfocrf      u,2\n  rlwinm      r,u,25,1" ],
                [ "int", "vector double", "vector double", "xvcmpeqdp.  t,a,b\n  mfocrf      u,2\n  rlwinm      r,u,25,1" ]
            ]
        }
    },
    {
        "mnemonic": "vec_all_ge",
        "name": "Vector All Greater or Equal",
        "syntax": "r = vec_all_ge (a, b)",
        "purpose": "Tests whether all elements of a are\n      greater than or equal to the corresponding elements of b.",
        "result": "r is 1 if\n      all elements of a are greater\n      than or equal to the corresponding elements of b.  Otherwise, r is 0.",
        "endianness": "None.",
        "instructions": [ "vcmpgtsb.", "mfocrf", "rlwinm", "vcmpgtub.", "vcmpgtsw.", "vcmpgtuw.", "vcmpgtsd.", "vcmpgtud.", "vcmpgtsh.", "vcmpgtuh.", "xvcmpgedp.", "xvcmpgesp." ],
        "type_signatures": {
            "var_heads": [ "r", "a", "b", "Example Implementation" ],
            "list": [
                [ "int", "vector signed char", "vector signed char", "vcmpgtsb.  t,b,a\n  mfocrf     u,2\n  rlwinm     r,u,27,1" ],
                [ "int", "vector unsigned char", "vector unsigned char", "vcmpgtub.  t,b,a\n  mfocrf     u,2\n  rlwinm     r,u,27,1" ],
                [ "int", "vector signed short", "vector signed short", "vcmpgtsh.  t,b,a\n  mfocrf     u,2\n  rlwinm     r,u,27,1" ],
                [ "int", "vector unsigned short", "vector unsigned short", "vcmpgtuh.  t,b,a\n  mfocrf     u,2\n  rlwinm     r,u,27,1" ],
                [ "int", "vector signed int", "vector signed int", "vcmpgtsw.  t,b,a\n  mfocrf     u,2\n  rlwinm     r,u,27,1" ],
                [ "int", "vector unsigned int", "vector unsigned int", "vcmpgtuw.  t,b,a\n  mfocrf     u,2\n  rlwinm     r,u,27,1" ],
                [ "int", "vector signed long long", "vector signed long long", "vcmpgtsd.  t,b,a\n  mfocrf     u,2\n  rlwinm     r,u,27,1" ],
                [ "int", "vector unsigned long long", "vector unsigned long long", "vcmpgtud.  t,b,a\n  mfocrf     u,2\n  rlwinm     r,u,27,1" ],
                [ "int", "vector float", "vector float", "xvcmpgesp.  t,a,b\n  mfocrf      u,2\n  rlwinm      r,u,25,1" ],
                [ "int", "vector double", "vector double", "xvcmpgedp.  t,a,b\n  mfocrf      u,2\n  rlwinm      r,u,25,1" ]
            ]
        }
    },
    {
        "mnemonic": "vec_all_gt",
        "name": "Vector All Greater Than",
        "syntax": "r = vec_all_gt (a, b)",
        "purpose": "Tests whether all elements of a are\n      greater than the corresponding elements of b.",
        "result": "r is 1 if\n      all elements of a are greater\n      than the corresponding elements of b.  Otherwise, r is 0.",
        "endianness": "None.",
        "instructions": [ "vcmpgtsb.", "mfocrf", "rlwinm", "vcmpgtub.", "vcmpgtsw.", "vcmpgtuw.", "vcmpgtsd.", "vcmpgtud.", "vcmpgtsh.", "vcmpgtuh.", "xvcmpgtdp.", "xvcmpgtsp." ],
        "type_signatures": {
            "var_heads": [ "r", "a", "b", "Example Implementation" ],
            "list": [
                [ "int", "vector signed char", "vector signed char", "vcmpgtsb.  t,a,b\n  mfocrf     u,2\n  rlwinm     r,u,25,1" ],
                [ "int", "vector unsigned char", "vector unsigned char", "vcmpgtub.  t,a,b\n  mfocrf     u,2\n  rlwinm     r,u,25,1" ],
                [ "int", "vector signed short", "vector signed short", "vcmpgtsh.  t,a,b\n  mfocrf     u,2\n  rlwinm     r,u,25,1" ],
                [ "int", "vector unsigned short", "vector unsigned short", "vcmpgtuh.  t,a,b\n  mfocrf     u,2\n  rlwinm     r,u,25,1" ],
                [ "int", "vector signed int", "vector signed int", "vcmpgtsw.  t,a,b\n  mfocrf     u,2\n  rlwinm     r,u,25,1" ],
                [ "int", "vector unsigned int", "vector unsigned int", "vcmpgtuw.  t,a,b\n  mfocrf     u,2\n  rlwinm     r,u,25,1" ],
                [ "int", "vector signed long long", "vector signed long long", "vcmpgtsd.  t,a,b\n  mfocrf     u,2\n  rlwinm     r,u,25,1" ],
                [ "int", "vector unsigned long long", "vector unsigned long long", "vcmpgtud.  t,a,b\n  mfocrf     u,2\n  rlwinm     r,u,25,1" ],
                [ "int", "vector float", "vector float", "xvcmpgtsp. t,a,b\n  mfocrf     u,2\n  rlwinm     r,u,25,1" ],
                [ "int", "vector double", "vector double", "xvcmpgtdp. t,a,b\n  mfocrf     u,2\n  rlwinm     r,u,25,1" ]
            ]
        }
    },
    {
        "mnemonic": "vec_all_in",
        "name": "Vector All In Range",
        "syntax": "r = vec_all_in (a, b)",
        "purpose": "Tests whether all elements of a vector are within a given range.",
        "result": "r  is 1 if each\n      element of a has a value less than or\n      equal to the value of the corresponding element of b, and greater than or equal to the negative of\n      the value of the corresponding element of b. Otherwise, r\n      is 0.",
        "endianness": "None.",
        "instructions": [ "vcmpbfp.", "mfocrf", "rlwinm" ],
        "type_signatures": {
            "var_heads": [ "r", "a", "b", "Example Implementation" ],
            "list": [
                [ "int", "vector float", "vector float", "vcmpbfp.  t,a,b\n  mfocrf    u,2\n  rlwinm    r,u,27,1" ]
            ]
        }
    },
    {
        "mnemonic": "vec_all_le",
        "name": "Vector All Less or Equal",
        "syntax": "r = vec_all_le (a, b)",
        "purpose": "Tests whether all elements of a are\n      less than or equal to the corresponding elements of b.",
        "result": "r is 1 if all\n      elements of a are less than or equal to\n      the corresponding elements of b.\n      Otherwise, r is 0.",
        "endianness": "None.",
        "instructions": [ "vcmpgtsb.", "mfocrf", "rlwinm", "vcmpgtub.", "vcmpgtsw.", "vcmpgtuw.", "vcmpgtsd.", "vcmpgtud.", "vcmpgtsh.", "vcmpgtuh.", "xvcmpgedp.", "xvcmpgesp." ],
        "type_signatures": {
            "var_heads": [ "r", "a", "b", "Example Implementation" ],
            "list": [
                [ "int", "vector signed char", "vector signed char", "vcmpgtsb.  t,a,b\n  mfocrf     u,2\n  rlwinm     r,u,27,1" ],
                [ "int", "vector unsigned char", "vector unsigned char", "vcmpgtub.  t,a,b\n  mfocrf     u,2\n  rlwinm     r,u,27,1" ],
                [ "int", "vector signed short", "vector signed short", "vcmpgtsh.  t,a,b\n  mfocrf     u,2\n  rlwinm     r,u,27,1" ],
                [ "int", "vector unsigned short", "vector unsigned short", "vcmpgtuh.  t,a,b\n  mfocrf     u,2\n  rlwinm     r,u,27,1" ],
                [ "int", "vector signed int", "vector signed int", "vcmpgtsw.  t,a,b\n  mfocrf     u,2\n  rlwinm     r,u,27,1" ],
                [ "int", "vector unsigned int", "vector unsigned int", "vcmpgtuw.  t,a,b\n  mfocrf     u,2\n  rlwinm     r,u,27,1" ],
                [ "int", "vector signed long long", "vector signed long long", "vcmpgtsd.  t,a,b\n  mfocrf     u,2\n  rlwinm     r,u,27,1" ],
                [ "int", "vector unsigned long long", "vector unsigned long long", "vcmpgtud.  t,a,b\n  mfocrf     u,2\n  rlwinm     r,u,27,1" ],
                [ "int", "vector float", "vector float", "xvcmpgesp.  t,b,a\n  mfocrf      u,2\n  rlwinm      r,u,25,1" ],
                [ "int", "vector double", "vector double", "xvcmpgedp.  t,b,a\n  mfocrf      u,2\n  rlwinm      r,u,25,1" ]
            ]
        }
    },
    {
        "mnemonic": "vec_all_lt",
        "name": "Vector All Less Than",
        "syntax": "r = vec_all_lt (a, b)",
        "purpose": "Tests whether all elements of a are\n      less than the corresponding elements of b.",
        "result": "r is 1 if all\n      elements of a are less than the\n      corresponding elements of b. Otherwise,\n      r is 0.",
        "endianness": "None.",
        "instructions": [ "vcmpgtsb.", "mfocrf", "rlwinm", "vcmpgtub.", "vcmpgtsw.", "vcmpgtuw.", "vcmpgtsd.", "vcmpgtud.", "vcmpgtsh.", "vcmpgtuh.", "xvcmpgtdp.", "xvcmpgtsp." ],
        "type_signatures": {
            "var_heads": [ "r", "a", "b", "Example Implementation" ],
            "list": [
                [ "int", "vector signed char", "vector signed char", "vcmpgtsb.  t,b,a\n  mfocrf     u,2\n  rlwinm     r,u,25,1" ],
                [ "int", "vector unsigned char", "vector unsigned char", "vcmpgtub.  t,b,a\n  mfocrf     u,2\n  rlwinm     r,u,25,1" ],
                [ "int", "vector signed short", "vector signed short", "vcmpgtsh.  t,b,a\n  mfocrf     u,2\n  rlwinm     r,u,25,1" ],
                [ "int", "vector unsigned short", "vector unsigned short", "vcmpgtuh.  t,b,a\n  mfocrf     u,2\n  rlwinm     r,u,25,1" ],
                [ "int", "vector signed int", "vector signed int", "vcmpgtsw.  t,b,a\n  mfocrf     u,2\n  rlwinm     r,u,25,1" ],
                [ "int", "vector unsigned int", "vector unsigned int", "vcmpgtuw.  t,b,a\n  mfocrf     u,2\n  rlwinm     r,u,25,1" ],
                [ "int", "vector signed long long", "vector signed long long", "vcmpgtsd.  t,b,a\n  mfocrf     u,2\n  rlwinm     r,u,25,1" ],
                [ "int", "vector unsigned long long", "vector unsigned long long", "vcmpgtud.  t,b,a\n  mfocrf     u,2\n  rlwinm     r,u,25,1" ],
                [ "int", "vector float", "vector float", "xvcmpgtsp.  t,b,a\n  mfocrf      u,2\n  rlwinm      r,u,25,1" ],
                [ "int", "vector double", "vector double", "xvcmpgtdp.  t,b,a\n  mfocrf      u,2\n  rlwinm      r,u,25,1" ]
            ]
        }
    },
    {
        "mnemonic": "vec_all_nan",
        "name": "Vector All Not-a-Number",
        "syntax": "r = vec_all_nan (a)",
        "purpose": "Tests whether all elements of a\n      are not-a-number (NaN).",
        "result": "r is 1 if\n      all elements of a are\n      NaN.  Otherwise, r is 0.",
        "endianness": "None.",
        "instructions": [ "xvcmpeqdp.", "mfocrf", "rlwinm", "xvcmpeqsp." ],
        "type_signatures": {
            "var_heads": [ "r", "a", "Example Implementation" ],
            "list": [
                [ "int", "vector float", "xvcmpeqsp.  t,a,a\n  mfocrf      u,2\n  rlwinm      r,u,27,1" ],
                [ "int", "vector double", "xvcmpeqdp.  t,a,a\n  mfocrf      u,2\n  rlwinm      r,u,27,1" ]
            ]
        }
    },
    {
        "mnemonic": "vec_all_ne",
        "name": "Vector All Not Equal",
        "syntax": "r = vec_all_ne (a, b)",
        "purpose": "Tests whether all elements of a\n      are not equal to the corresponding elements of b.",
        "result": "r is 1 if\n      all elements of a are not equal\n      to the corresponding elements of b.  Otherwise, r is 0.",
        "endianness": "None.",
        "instructions": [ "vcmpneb.", "mfocrf", "rlwinm", "vcmpnew.", "vcmpequd.", "vcmpneh.", "xvcmpeqdp.", "xvcmpeqsp." ],
        "type_signatures": {
            "var_heads": [ "r", "a", "b", "Example Implementation" ],
            "list": [
                [ "int", "vector bool char", "vector bool char", "vcmpneb.  t,a,b\n  mfocrf    u,2\n  rlwinm    r,u,25,1" ],
                [ "int", "vector signed char", "vector signed char", "vcmpneb.  t,a,b\n  mfocrf    u,2\n  rlwinm    r,u,25,1" ],
                [ "int", "vector unsigned char", "vector unsigned char", "vcmpneb.  t,a,b\n  mfocrf    u,2\n  rlwinm    r,u,25,1" ],
                [ "int", "vector bool short", "vector bool short", "vcmpneh.  t,a,b\n  mfocrf    u,2\n  rlwinm    r,u,25,1" ],
                [ "int", "vector signed short", "vector signed short", "vcmpneh.  t,a,b\n  mfocrf    u,2\n  rlwinm    r,u,25,1" ],
                [ "int", "vector unsigned short", "vector unsigned short", "vcmpneh.  t,a,b\n  mfocrf    u,2\n  rlwinm    r,u,25,1" ],
                [ "int", "vector pixel", "vector pixel", "vcmpneh.  t,a,b\n  mfocrf    u,2\n  rlwinm    r,u,25,1" ],
                [ "int", "vector bool int", "vector bool int", "vcmpnew.  t,a,b\n  mfocrf    u,2\n  rlwinm    r,u,25,1" ],
                [ "int", "vector signed int", "vector signed int", "vcmpnew.  t,a,b\n  mfocrf    u,2\n  rlwinm    r,u,25,1" ],
                [ "int", "vector unsigned int", "vector unsigned int", "vcmpnew.  t,a,b\n  mfocrf    u,2\n  rlwinm    r,u,25,1" ],
                [ "int", "vector bool long long", "vector bool long long", "vcmpequd.  t,a,b\n  mfocrf     u,2\n  rlwinm     r,u,27,1" ],
                [ "int", "vector signed long long", "vector signed long long", "vcmpequd.  t,a,b\n  mfocrf     u,2\n  rlwinm     r,u,27,1" ],
                [ "int", "vector unsigned long long", "vector unsigned long long", "vcmpequd.  t,a,b\n  mfocrf     u,2\n  rlwinm     r,u,27,1" ],
                [ "int", "vector float", "vector float", "xvcmpeqsp.  t,a,b\n  mfocrf      u,2\n  rlwinm      r,u,27,1" ],
                [ "int", "vector double", "vector double", "xvcmpeqdp.  t,a,b\n  mfocrf      u,2\n  rlwinm      r,u,27,1" ]
            ]
        }
    },
    {
        "mnemonic": "vec_all_nge",
        "name": "Vector All Not Greater or Equal",
        "syntax": "r = vec_all_nge (a, b)",
        "purpose": "Tests whether all elements of a\n      are not greater than or equal to the corresponding elements of\n      b.",
        "result": "r is 1 if\n      all elements of a are not\n      greater than or equal to the corresponding elements of b. Otherwise, r is 0.",
        "endianness": "None.",
        "instructions": [ "xvcmpeqdp.", "mfocrf", "rlwinm", "xvcmpeqsp." ],
        "type_signatures": {
            "var_heads": [ "r", "a", "b", "Example Implementation" ],
            "list": [
                [ "int", "vector float", "vector float", "xvcmpgesp.  t,a,b\n  mfocrf      u,2\n  rlwinm      r,u,27,1" ],
                [ "int", "vector double", "vector double", "xvcmpgedp.  t,a,b\n  mfocrf      u,2\n  rlwinm      r,u,27,1" ]
            ]
        }
    },
    {
        "mnemonic": "vec_all_ngt",
        "name": "Vector All Not Greater Than",
        "syntax": "r = vec_all_ngt (a, b)",
        "purpose": "Tests whether all elements of a\n      are not greater than the corresponding elements of b.",
        "result": "r is 1 if\n      all elements of a are not\n      greater than the corresponding elements of b.  Otherwise, r is 0.",
        "endianness": "None.",
        "instructions": [ "xvcmpgtdp.", "mfocrf", "rlwinm", "xvcmpgtsp." ],
        "type_signatures": {
            "var_heads": [ "r", "a", "b", "Example Implementation" ],
            "list": [
                [ "int", "vector float", "vector float", "xvcmpgtsp.  t,a,b\n  mfocrf      u,2\n  rlwinm      r,u,27,1" ],
                [ "int", "vector double", "vector double", "xvcmpgtdp.  t,a,b\n  mfocrf      u,2\n  rlwinm      r,u,27,1" ]
            ]
        }
    },
    {
        "mnemonic": "vec_all_nle",
        "name": "Vector All Not Less or Equal",
        "syntax": "r = vec_all_nle (a, b)",
        "purpose": "Tests whether all elements of a\n      are not less than or equal to the corresponding elements of\n      b.",
        "result": "r is 1 if\n      all elements of a are not less\n      than or equal to the corresponding elements of b.  Otherwise, r is 0.",
        "endianness": "None.",
        "instructions": [ "xvcmpgedp.", "mfocrf", "rlwinm", "xvcmpgesp." ],
        "type_signatures": {
            "var_heads": [ "r", "a", "b", "Example Implementation" ],
            "list": [
                [ "int", "vector float", "vector float", "xvcmpgesp.  t,b,a\n  mfocrf      u,2\n  rlwinm      r,u,27,1" ],
                [ "int", "vector double", "vector double", "xvcmpgedp.  t,b,a\n  mfocrf      u,2\n  rlwinm      r,u,27,1" ]
            ]
        }
    },
    {
        "mnemonic": "vec_all_nlt",
        "name": "Vector All Not Less Than",
        "syntax": "r = vec_all_nlt (a, b)",
        "purpose": "Tests whether all elements of a\n      are not less than the corresponding elements of b.",
        "result": "r is 1 if\n      all elements of a are not less\n      than the corresponding elements of b.  Otherwise, r is 0.",
        "endianness": "None.",
        "instructions": [ "xvcmpgtdp.", "mfocrf", "rlwinm", "xvcmpgtsp." ],
        "type_signatures": {
            "var_heads": [ "r", "a", "b", "Example Implementation" ],
            "list": [
                [ "int", "vector float", "vector float", "xvcmpgtsp.  t,b,a\n  mfocrf      u,2\n  rlwinm      r,u,27,1" ],
                [ "int", "vector double", "vector double", "xvcmpgtdp.  t,b,a\n  mfocrf      u,2\n  rlwinm      r,u,27,1" ]
            ]
        }
    },
    {
        "mnemonic": "vec_all_numeric",
        "name": "Vector All Numeric",
        "syntax": "r = vec_all_numeric (a)",
        "purpose": "Tests whether all elements of the vector are numeric (not NaN).",
        "result": "r is 1 if\n      all elements of a are numeric\n      (not NaN).  Otherwise, r is\n      0.",
        "endianness": "None.",
        "instructions": [ "xvcmpeqdp.", "mfocrf", "rlwinm", "xvcmpeqsp." ],
        "type_signatures": {
            "var_heads": [ "r", "a", "Example Implementation" ],
            "list": [
                [ "int", "vector float", "xvcmpeqsp.  t,a,b\n  mfocrf      u,2\n  rlwinm      r,u,25,1" ],
                [ "int", "vector double", "xvcmpeqdp.  t,a,b\n  mfocrf      u,2\n  rlwinm      r,u,25,1" ]
            ]
        }
    },
    {
        "mnemonic": "vec_and",
        "name": "Vector AND",
        "syntax": "r = vec_and (a, b)",
        "purpose": "Performs a bitwise AND of two vectors.",
        "result": "The value of r is the bitwise AND\n      of a and b.",
        "endianness": "None.",
        "instructions": [ "xxland" ],
        "type_signatures": {
            "var_heads": [ "r", "a", "b", "Example Implementation", "Restrictions" ],
            "list": [
                [ "vector bool char", "vector bool char", "vector bool char", "xxland r,a,b" ],
                [ "vector signed char", "vector signed char", "vector signed char", "xxland r,a,b" ],
                [ "vector unsigned char", "vector unsigned char", "vector unsigned char", "xxland r,a,b" ],
                [ "vector bool short", "vector bool short", "vector bool short", "xxland r,a,b" ],
                [ "vector signed short", "vector signed short", "vector signed short", "xxland r,a,b" ],
                [ "vector unsigned short", "vector unsigned short", "vector unsigned short", "xxland r,a,b" ],
                [ "vector signed int", "vector signed int", "vector signed int", "xxland r,a,b" ],
                [ "vector bool int", "vector bool int", "vector bool int", "xxland r,a,b" ],
                [ "vector unsigned int", "vector unsigned int", "vector unsigned int", "xxland r,a,b" ],
                [ "vector bool long long", "vector bool long long", "vector bool long long", "xxland r,a,b", "" ],
                [ "vector signed long long", "vector signed long long", "vector signed long long", "xxland r,a,b", "" ],
                [ "vector unsigned long long", "vector unsigned long long", "vector unsigned long long", "xxland r,a,b", "" ],
                [ "vector float", "vector float", "vector float", "xxland r,a,b" ],
                [ "vector double", "vector double", "vector double", "xxland r,a,b" ]
            ]
        }
    },
    {
        "mnemonic": "vec_andc",
        "name": "Vector AND with Complement",
        "syntax": "r = vec_andc (a, b)",
        "purpose": "Performs a bitwise AND of one vector with the bitwise complement of\n      another vector.",
        "result": "The value of r is the bitwise AND\n      of a with the bitwise complement\n      of b.",
        "endianness": "None.",
        "instructions": [ "xxlandc" ],
        "type_signatures": {
            "var_heads": [ "r", "a", "b", "Example Implementation", "Restrictions" ],
            "list": [
                [ "vector bool char", "vector bool char", "vector bool char", "xxlandc r,a,b" ],
                [ "vector signed char", "vector signed char", "vector signed char", "xxlandc r,a,b" ],
                [ "vector unsigned char", "vector unsigned char", "vector unsigned char", "xxlandc r,a,b" ],
                [ "vector bool short", "vector bool short", "vector bool short", "xxlandc r,a,b" ],
                [ "vector signed short", "vector signed short", "vector signed short", "xxlandc r,a,b" ],
                [ "vector unsigned short", "vector unsigned short", "vector unsigned short", "xxlandc r,a,b" ],
                [ "vector signed int", "vector signed int", "vector signed int", "xxlandc r,a,b" ],
                [ "vector bool int", "vector bool int", "vector bool int", "xxlandc r,a,b" ],
                [ "vector unsigned int", "vector unsigned int", "vector unsigned int", "xxlandc r,a,b" ],
                [ "vector bool long long", "vector bool long long", "vector bool long long", "xxlandc r,a,b", "" ],
                [ "vector signed long long", "vector signed long long", "vector signed long long", "xxlandc r,a,b", "" ],
                [ "vector unsigned long long", "vector unsigned long long", "vector unsigned long long", "xxlandc r,a,b", "" ],
                [ "vector float", "vector float", "vector float", "xxlandc r,a,b" ],
                [ "vector double", "vector double", "vector double", "xxlandc r,a,b" ]
            ]
        }
    },
    {
        "mnemonic": "vec_any_eq",
        "name": "Vector Any Equal",
        "syntax": "r = vec_any_eq (a, b)",
        "purpose": "Tests whether any element of a\n      is equal to the corresponding element of b.",
        "result": "r is 1 if any\n      element of a is equal to the\n      corresponding element of b. Otherwise,\n      r is 0.",
        "endianness": "None.",
        "instructions": [ "vcmpneb.", "mfocrf", "rlwinm", "cntlzw", "srwi", "vcmpnew.", "vcmpequd.", "vcmpneh.", "xvcmpeqdp.", "xvcmpeqsp." ],
        "type_signatures": {
            "var_heads": [ "r", "a", "b", "Example Implementation" ],
            "list": [
                [ "int", "vector bool char", "vector bool char", "vcmpneb.  t,a,b\n  mfocrf    u,2\n  rlwinm    v,u,25,1\n  cntlzw    w,v\n  srwi      r,w,5" ],
                [ "int", "vector signed char", "vector signed char", "vcmpneb.  t,a,b\n  mfocrf    u,2\n  rlwinm    v,u,25,1\n  cntlzw    w,v\n  srwi      r,w,5" ],
                [ "int", "vector unsigned char", "vector unsigned char", "vcmpneb.  t,a,b\n  mfocrf    u,2\n  rlwinm    v,u,25,1\n  cntlzw    w,v\n  srwi      r,w,5" ],
                [ "int", "vector bool short", "vector bool short", "vcmpneh.  t,a,b\n  mfocrf    u,2\n  rlwinm    v,u,25,1\n  cntlzw    w,v\n  srwi      r,w,5" ],
                [ "int", "vector signed short", "vector signed short", "vcmpneh.  t,a,b\n  mfocrf    u,2\n  rlwinm    v,u,25,1\n  cntlzw    w,v\n  srwi      r,w,5" ],
                [ "int", "vector unsigned short", "vector unsigned short", "vcmpneh.  t,a,b\n  mfocrf    u,2\n  rlwinm    v,u,25,1\n  cntlzw    w,v\n  srwi      r,w,5" ],
                [ "int", "vector pixel", "vector pixel", "vcmpneh.  t,a,b\n  mfocrf    u,2\n  rlwinm    v,u,25,1\n  cntlzw    w,v\n  srwi      r,w,5" ],
                [ "int", "vector bool int", "vector bool int", "vcmpnew.  t,a,b\n  mfocrf    u,2\n  rlwinm    v,u,25,1\n  cntlzw    w,v\n  srwi      r,w,5" ],
                [ "int", "vector signed int", "vector signed int", "vcmpnew.  t,a,b\n  mfocrf    u,2\n  rlwinm    v,u,25,1\n  cntlzw    w,v\n  srwi      r,w,5" ],
                [ "int", "vector unsigned int", "vector unsigned int", "vcmpnew.  t,a,b\n  mfocrf    u,2\n  rlwinm    v,u,25,1\n  cntlzw    w,v\n  srwi      r,w,5" ],
                [ "int", "vector bool long long", "vector bool long long", "vcmpequd.  t,a,b\n  mfocrf     u,2\n  rlwinm     v,u,27,1\n  cntlzw     w,v\n  srwi       r,w,5" ],
                [ "int", "vector signed long long", "vector signed long long", "vcmpequd.  t,a,b\n  mfocrf     u,2\n  rlwinm     v,u,27,1\n  cntlzw     w,v\n  srwi       r,w,5" ],
                [ "int", "vector unsigned long long", "vector unsigned long long", "vcmpequd.  t,a,b\n  mfocrf     u,2\n  rlwinm     v,u,27,1\n  cntlzw     w,v\n  srwi       r,w,5" ],
                [ "int", "vector float", "vector float", "xvcmpeqsp.  t,a,b\n  mfocrf      u,2\n  rlwinm      v,u,27,1\n  cntlzw      w,v\n  srwi        r,w,5" ],
                [ "int", "vector double", "vector double", "xvcmpeqdp.  t,a,b\n  mfocrf      u,2\n  rlwinm      v,u,27,1\n  cntlzw      w,v\n  srwi        r,w,5" ]
            ]
        }
    },
    {
        "mnemonic": "vec_any_ge",
        "name": "Vector Any Greater or Equal",
        "syntax": "r = vec_any_ge (a, b)",
        "purpose": "Tests whether any element of a is\n      greater than or equal to the corresponding element of b.",
        "result": "r is 1 if any\n      element of a is greater than or equal\n      to the corresponding element of b.\n      Otherwise, r is 0.",
        "endianness": "None.",
        "instructions": [ "vcmpgtsb.", "mfocrf", "rlwinm", "cntlzw", "srwi", "vcmpgtub.", "vcmpgtsw.", "vcmpgtuw.", "vcmpgtsd.", "vcmpgtud.", "vcmpgtsh.", "vcmpgtuh.", "xvcmpgedp.", "xvcmpgesp." ],
        "type_signatures": {
            "var_heads": [ "r", "a", "b", "Example Implementation" ],
            "list": [
                [ "int", "vector signed char", "vector signed char", "vcmpgtsb.  t,b,a\n  mfocrf     u,2\n  rlwinm     v,u,25,1\n  cntlzw     w,v\n  srwi       r,w,5" ],
                [ "int", "vector unsigned char", "vector unsigned char", "vcmpgtub.  t,b,a\n  mfocrf     u,2\n  rlwinm     v,u,25,1\n  cntlzw     w,v\n  srwi       r,w,5" ],
                [ "int", "vector signed int", "vector signed int", "vcmpgtsw.  t,b,a\n  mfocrf     u,2\n  rlwinm     v,u,25,1\n  cntlzw     w,v\n  srwi       r,w,5" ],
                [ "int", "vector unsigned int", "vector unsigned int", "vcmpgtuw.  t,b,a\n  mfocrf     u,2\n  rlwinm     v,u,25,1\n  cntlzw     w,v\n  srwi       r,w,5" ],
                [ "int", "vector signed long long", "vector signed long long", "vcmpgtsd.  t,b,a\n  mfocrf     u,2\n  rlwinm     v,u,25,1\n  cntlzw     w,v\n  srwi       r,w,5" ],
                [ "int", "vector unsigned long long", "vector unsigned long long", "vcmpgtud.  t,b,a\n  mfocrf     u,2\n  rlwinm     v,u,25,1\n  cntlzw     w,v\n  srwi       r,w,5" ],
                [ "int", "vector signed short", "vector signed short", "vcmpgtsh.  t,b,a\n  mfocrf     u,2\n  rlwinm     v,u,25,1\n  cntlzw     w,v\n  srwi       r,w,5" ],
                [ "int", "vector unsigned short", "vector unsigned short", "vcmpgtuh.  t,b,a\n  mfocrf     u,2\n  rlwinm     v,u,25,1\n  cntlzw     w,v\n  srwi       r,w,5" ],
                [ "int", "vector double", "vector double", "xvcmpgedp.  t,a,b\n  mfocrf      u,2\n  rlwinm      v,u,27,1\n  cntlzw      w,v\n  srwi        r,w,5" ],
                [ "int", "vector float", "vector float", "vcmpgesp.  t,a,b\n  mfocrf     u,2\n  rlwinm     v,u,27,1\n  cntlzw     w,v\n  srwi       r,w,5" ]
            ]
        }
    },
    {
        "mnemonic": "vec_any_gt",
        "name": "Vector Any Greater Than",
        "syntax": "r = vec_any_gt (a, b)",
        "purpose": "Tests whether any element of a is\n      greater than the corresponding element of b.",
        "result": "r is 1 if any\n      element of a is greater than the\n      corresponding element of b. Otherwise,\n      r is 0.",
        "endianness": "None.",
        "instructions": [ "vcmpgtsb.", "mfocrf", "rlwinm", "cntlzw", "srwi", "vcmpgtub.", "vcmpgtsw.", "vcmpgtuw.", "vcmpgtsd.", "vcmpgtud.", "vcmpgtsh.", "vcmpgtuh.", "xvcmpgtdp.", "xvcmpgtsp." ],
        "type_signatures": {
            "var_heads": [ "r", "a", "b", "Example Implementation" ],
            "list": [
                [ "int", "vector signed char", "vector signed char", "vcmpgtsb.  t,a,b\n  mfocrf     u,2\n  rlwinm     v,u,27,1\n  cntlzw     w,v\n  srwi       r,w,5" ],
                [ "int", "vector unsigned char", "vector unsigned char", "vcmpgtub.  t,a,b\n  mfocrf     u,2\n  rlwinm     v,u,27,1\n  cntlzw     w,v\n  srwi       r,w,5" ],
                [ "int", "vector signed short", "vector signed short", "vcmpgtsh.  t,a,b\n  mfocrf     u,2\n  rlwinm     v,u,27,1\n  cntlzw     w,v\n  srwi       r,w,5" ],
                [ "int", "vector unsigned short", "vector unsigned short", "vcmpgtuh.  t,a,b\n  mfocrf     u,2\n  rlwinm     v,u,27,1\n  cntlzw     w,v\n  srwi       r,w,5" ],
                [ "int", "vector signed int", "vector signed int", "vcmpgtsw.  t,a,b\n  mfocrf     u,2\n  rlwinm     v,u,27,1\n  cntlzw     w,v\n  srwi       r,w,5" ],
                [ "int", "vector unsigned int", "vector unsigned int", "vcmpgtuw.  t,a,b\n  mfocrf     u,2\n  rlwinm     v,u,27,1\n  cntlzw     w,v\n  srwi       r,w,5" ],
                [ "int", "vector signed long long", "vector signed long long", "vcmpgtsd.  t,a,b\n  mfocrf     u,2\n  rlwinm     v,u,27,1\n  cntlzw     w,v\n  srwi       r,w,5" ],
                [ "int", "vector unsigned long long", "vector unsigned long long", "vcmpgtud.  t,a,b\n  mfocrf     u,2\n  rlwinm     v,u,27,1\n  cntlzw     w,v\n  srwi       r,w,5" ],
                [ "int", "vector float", "vector float", "xvcmpgtsp.  t,a,b\n  mfocrf      u,2\n  rlwinm      v,u,27,1\n  cntlzw      w,v\n  srwi        r,w,5" ],
                [ "int", "vector double", "vector double", "xvcmpgtdp.  t,a,b\n  mfocrf      u,2\n  rlwinm      v,u,27,1\n  cntlzw      w,v\n  srwi        r,w,5" ]
            ]
        }
    },
    {
        "mnemonic": "vec_any_le",
        "name": "Vector Any Less or Equal",
        "syntax": "r = vec_any_le (a, b)",
        "purpose": "Tests whether any element of a is less\n      than or equal to the corresponding element of b.",
        "result": "r is 1 if any\n      element of a is less than or equal to\n      the corresponding element of b.\n      Otherwise, r is 0.",
        "endianness": "None.",
        "instructions": [ "vcmpgtsb.", "mfocrf", "rlwinm", "cntlzw", "srwi", "vcmpgtub.", "vcmpgtsw.", "vcmpgtuw.", "vcmpgtsd.", "vcmpgtud.", "vcmpgtsh.", "vcmpgtuh.", "xvcmpgedp.", "xvcmpgesp." ],
        "type_signatures": {
            "var_heads": [ "r", "a", "b", "Example Implementation" ],
            "list": [
                [ "int", "vector signed char", "vector signed char", "vcmpgtsb.  t,a,b\n  mfocrf     u,2\n  rlwinm     v,u,25,1\n  cntlzw     w,v\n  srwi       r,w,5" ],
                [ "int", "vector unsigned char", "vector unsigned char", "vcmpgtub.  t,a,b\n  mfocrf     u,2\n  rlwinm     v,u,25,1\n  cntlzw     w,v\n  srwi       r,w,5" ],
                [ "int", "vector signed short", "vector signed short", "vcmpgtsh.  t,a,b\n  mfocrf     u,2\n  rlwinm     v,u,25,1\n  cntlzw     w,v\n  srwi       r,w,5" ],
                [ "int", "vector unsigned short", "vector unsigned short", "vcmpgtuh.  t,a,b\n  mfocrf     u,2\n  rlwinm     v,u,25,1\n  cntlzw     w,v\n  srwi       r,w,5" ],
                [ "int", "vector signed int", "vector signed int", "vcmpgtsw.  t,a,b\n  mfocrf     u,2\n  rlwinm     v,u,25,1\n  cntlzw     w,v\n  srwi       r,w,5" ],
                [ "int", "vector unsigned int", "vector unsigned int", "vcmpgtuw.  t,a,b\n  mfocrf     u,2\n  rlwinm     v,u,25,1\n  cntlzw     w,v\n  srwi       r,w,5" ],
                [ "int", "vector signed long long", "vector signed long long", "vcmpgtsd.  t,a,b\n  mfocrf     u,2\n  rlwinm     v,u,25,1\n  cntlzw     w,v\n  srwi       r,w,5" ],
                [ "int", "vector unsigned long long", "vector unsigned long long", "vcmpgtud.  t,a,b\n  mfocrf     u,2\n  rlwinm     v,u,25,1\n  cntlzw     w,v\n  srwi       r,w,5" ],
                [ "int", "vector float", "vector float", "xvcmpgesp.  t,b,a\n  mfocrf      u,2\n  rlwinm      v,u,27,1\n  cntlzw      w,v\n  srwi        r,w,5" ],
                [ "int", "vector double", "vector double", "xvcmpgedp.  t,b,a\n  mfocrf      u,2\n  rlwinm      v,u,27,1\n  cntlzw      w,v\n  srwi        r,w,5" ]
            ]
        }
    },
    {
        "mnemonic": "vec_any_lt",
        "name": "Vector Any Less Than",
        "syntax": "r = vec_any_lt (a, b)",
        "purpose": "Tests whether any element of a is less\n      than the corresponding element of b.",
        "result": "r is 1 if any\n      element of a is less than the\n      corresponding element of b. Otherwise,\n      r is 0.",
        "endianness": "None.",
        "instructions": [ "vcmpgtsb.", "mfocrf", "rlwinm", "cntlzw", "srwi", "vcmpgtub.", "vcmpgtsw.", "vcmpgtuw.", "vcmpgtsd.", "vcmpgtud.", "vcmpgtsh.", "vcmpgtuh.", "xvcmpgtdp.", "xvcmpgtsp." ],
        "type_signatures": {
            "var_heads": [ "r", "a", "b", "Example Implementation" ],
            "list": [
                [ "int", "vector signed char", "vector signed char", "vcmpgtsb.  t,b,a\n  mfocrf     u,2\n  rlwinm     v,u,27,1\n  cntlzw     w,v\n  srwi       r,w,5" ],
                [ "int", "vector unsigned char", "vector unsigned char", "vcmpgtub.  t,b,a\n  mfocrf     u,2\n  rlwinm     v,u,27,1\n  cntlzw     w,v\n  srwi       r,w,5" ],
                [ "int", "vector signed short", "vector signed short", "vcmpgtsh.  t,b,a\n  mfocrf     u,2\n  rlwinm     v,u,27,1\n  cntlzw     w,v\n  srwi       r,w,5" ],
                [ "int", "vector unsigned short", "vector unsigned short", "vcmpgtuh.  t,b,a\n  mfocrf     u,2\n  rlwinm     v,u,27,1\n  cntlzw     w,v\n  srwi       r,w,5" ],
                [ "int", "vector signed int", "vector signed int", "vcmpgtsw.  t,b,a\n  mfocrf     u,2\n  rlwinm     v,u,27,1\n  cntlzw     w,v\n  srwi       r,w,5" ],
                [ "int", "vector unsigned int", "vector unsigned int", "vcmpgtuw.  t,b,a\n  mfocrf     u,2\n  rlwinm     v,u,27,1\n  cntlzw     w,v\n  srwi       r,w,5" ],
                [ "int", "vector signed long long", "vector signed long long", "vcmpgtsd.  t,b,a\n  mfocrf     u,2\n  rlwinm     v,u,27,1\n  cntlzw     w,v\n  srwi       r,w,5" ],
                [ "int", "vector unsigned long long", "vector unsigned long long", "vcmpgtud.  t,b,a\n  mfocrf     u,2\n  rlwinm     v,u,27,1\n  cntlzw     w,v\n  srwi       r,w,5" ],
                [ "int", "vector float", "vector float", "xvcmpgtsp.  t,b,a\n  mfocrf      u,2\n  rlwinm      v,u,27,1\n  cntlzw      w,v\n  srwi        r,w,5" ],
                [ "int", "vector double", "vector double", "xvcmpgtdp.  t,b,a\n  mfocrf      u,2\n  rlwinm      v,u,27,1\n  cntlzw      w,v\n  srwi        r,w,5" ]
            ]
        }
    },
    {
        "mnemonic": "vec_any_nan",
        "name": "Vector Any Not-a-Number",
        "syntax": "r = vec_any_nan (a)",
        "purpose": "Tests whether any element of the source vector is a NaN.",
        "result": "r is 1 if any\n      element of a is a NaN. Otherwise,\n      r is 0.",
        "endianness": "None.",
        "instructions": [ "xvcmpeqdp.", "mfocrf", "rlwinm", "cntlzw", "srwi", "xvcmpeqsp." ],
        "type_signatures": {
            "var_heads": [ "r", "a", "Example Implementation" ],
            "list": [
                [ "int", "vector float", "xvcmpeqsp.  t,a,a\n  mfocrf      u,2\n  rlwinm      v,u,25,1\n  cntlzw      w,v\n  srwi        r,w,5" ],
                [ "int", "vector double", "xvcmpeqdp.  t,a,a\n  mfocrf      u,2\n  rlwinm      v,u,25,1\n  cntlzw      w,v\n  srwi        r,w,5" ]
            ]
        }
    },
    {
        "mnemonic": "vec_any_ne",
        "name": "Vector Any Not Equal",
        "syntax": "r = vec_any_ne (a, b)",
        "purpose": "Tests whether any element of a\n      is not equal to the corresponding element of b.",
        "result": "r is 1 if any\n      element of a is not equal to the\n      corresponding element of b. Otherwise,\n      r is 0.",
        "endianness": "None.",
        "instructions": [ "vcmpequb.", "mfocrf", "rlwinm", "cntlzw", "srwi", "vcmpequw.", "vcmpequd.", "vcmpequh.", "xvcmpeqdp.", "xvcmpeqsp." ],
        "type_signatures": {
            "var_heads": [ "r", "a", "b", "Example Implementation" ],
            "list": [
                [ "int", "vector bool char", "vector bool char", "vcmpequb.  t,a,b\n  mfocrf     u,2\n  rlwinm     v,u,25,1\n  cntlzw     w,v\n  srwi       r,w,5" ],
                [ "int", "vector signed char", "vector signed char", "vcmpequb.  t,a,b\n  mfocrf     u,2\n  rlwinm     v,u,25,1\n  cntlzw     w,v\n  srwi       r,w,5" ],
                [ "int", "vector unsigned char", "vector unsigned char", "vcmpequb.  t,a,b\n  mfocrf     u,2\n  rlwinm     v,u,25,1\n  cntlzw     w,v\n  srwi       r,w,5" ],
                [ "int", "vector bool short", "vector bool short", "vcmpequh.  t,a,b\n  mfocrf     u,2\n  rlwinm     v,u,25,1\n  cntlzw     w,v\n  srwi       r,w,5" ],
                [ "int", "vector signed short", "vector signed short", "vcmpequh.  t,a,b\n  mfocrf     u,2\n  rlwinm     v,u,25,1\n  cntlzw     w,v\n  srwi       r,w,5" ],
                [ "int", "vector unsigned short", "vector unsigned short", "vcmpequh.  t,a,b\n  mfocrf     u,2\n  rlwinm     v,u,25,1\n  cntlzw     w,v\n  srwi       r,w,5" ],
                [ "int", "vector pixel", "vector pixel", "vcmpequh.  t,a,b\n  mfocrf     u,2\n  rlwinm     v,u,25,1\n  cntlzw     w,v\n  srwi       r,w,5" ],
                [ "int", "vector bool int", "vector bool int", "vcmpequw.  t,a,b\n  mfocrf     u,2\n  rlwinm     v,u,25,1\n  cntlzw     w,v\n  srwi       r,w,5" ],
                [ "int", "vector signed int", "vector signed int", "vcmpequw.  t,a,b\n  mfocrf     u,2\n  rlwinm     v,u,25,1\n  cntlzw     w,v\n  srwi       r,w,5" ],
                [ "int", "vector unsigned int", "vector unsigned int", "vcmpequw.  t,a,b\n  mfocrf     u,2\n  rlwinm     v,u,25,1\n  cntlzw     w,v\n  srwi       r,w,5" ],
                [ "int", "vector bool long long", "vector bool long long", "vcmpequd.  t,a,b\n  mfocrf     u,2\n  rlwinm     v,u,25,1\n  cntlzw     w,v\n  srwi       r,w,5" ],
                [ "int", "vector signed long long", "vector signed long long", "vcmpequd.  t,a,b\n  mfocrf     u,2\n  rlwinm     v,u,25,1\n  cntlzw     w,v\n  srwi       r,w,5" ],
                [ "int", "vector unsigned long long", "vector unsigned long long", "vcmpequd.  t,a,b\n  mfocrf     u,2\n  rlwinm     v,u,25,1\n  cntlzw     w,v\n  srwi       r,w,5" ],
                [ "int", "vector float", "vector float", "xvcmpeqsp.  t,a,b\n  mfocrf      u,2\n  rlwinm      v,u,25,1\n  cntlzw      w,v\n  srwi        r,w,5" ],
                [ "int", "vector double", "vector double", "xvcmpeqdp.  t,a,b\n  mfocrf      u,2\n  rlwinm      v,u,25,1\n  cntlzw      w,v\n  srwi        r,w,5" ]
            ]
        }
    },
    {
        "mnemonic": "vec_any_nge",
        "name": "Vector Any Not Greater or Equal",
        "syntax": "r = vec_any_nge (a, b)",
        "purpose": "Tests whether any element of a is not\n      greater than or equal to the corresponding element of b.",
        "result": "r is 1 if any\n      element of a is not greater than or\n      equal to the corresponding element of b. Otherwise, r\n      is 0.",
        "endianness": "None.",
        "instructions": [ "xvcmpgedp.", "mfocrf", "rlwinm", "cntlzw", "srwi", "xvcmpgesp." ],
        "type_signatures": {
            "var_heads": [ "r", "a", "b", "Example Implementation" ],
            "list": [
                [ "int", "vector float", "vector float", "xvcmpgesp.  t,a,b\n  mfocrf      u,2\n  rlwinm      v,u,25,1\n  cntlzw      w,v\n  srwi        r,w,5" ],
                [ "int", "vector double", "vector double", "xvcmpgedp.  t,a,b\n  mfocrf      u,2\n  rlwinm      v,u,25,1\n  cntlzw      w,v\n  srwi        r,w,5" ]
            ]
        }
    },
    {
        "mnemonic": "vec_any_ngt",
        "name": "Vector Any Not Greater Than",
        "syntax": "r = vec_any_ngt (a, b)",
        "purpose": "Tests whether any element of a is not\n      greater than the corresponding element of b.",
        "result": "r is 1 if any\n      element of a is not greater than the\n      corresponding element of b. Otherwise,\n      r is 0.",
        "endianness": "None.",
        "instructions": [ "xvcmpgtdp.", "mfocrf", "rlwinm", "cntlzw", "srwi", "xvcmpgtsp." ],
        "type_signatures": {
            "var_heads": [ "r", "a", "b", "Example Implementation" ],
            "list": [
                [ "int", "vector float", "vector float", "xvcmpgtsp.  t,a,b\n  mfocrf      u,2\n  rlwinm      v,u,25,1\n  cntlzw      w,v\n  srwi        r,w,5" ],
                [ "int", "vector double", "vector double", "xvcmpgtdp.  t,a,b\n  mfocrf      u,2\n  rlwinm      v,u,25,1\n  cntlzw      w,v\n  srwi        r,w,5" ]
            ]
        }
    },
    {
        "mnemonic": "vec_any_nle",
        "name": "Vector Any Not Less or Equal",
        "syntax": "r = vec_any_nle (a, b)",
        "purpose": "Tests whether any element of a is not\n      less than or equal to the corresponding element of b.",
        "result": "r is 1 if any\n      element of a is not less than or equal\n      to the corresponding element of b.\n      Otherwise, r is 0.",
        "endianness": "None.",
        "instructions": [ "xvcmpgedp.", "mfocrf", "rlwinm", "cntlzw", "srwi", "xvcmpgesp." ],
        "type_signatures": {
            "var_heads": [ "r", "a", "b", "Example Implementation" ],
            "list": [
                [ "int", "vector float", "vector float", "xvcmpgesp.  t,b,a\n  mfocrf      u,2\n  rlwinm      v,u,25,1\n  cntlzw      w,v\n  srwi        r,w,5" ],
                [ "int", "vector double", "vector double", "xvcmpgedp.  t,b,a\n  mfocrf      u,2\n  rlwinm      v,u,25,1\n  cntlzw      w,v\n  srwi        r,w,5" ]
            ]
        }
    },
    {
        "mnemonic": "vec_any_nlt",
        "name": "Vector Any Not Less Than",
        "syntax": "r = vec_any_nlt (a, b)",
        "purpose": "Tests whether any element of a is not\n      less than the corresponding element of b.",
        "result": "r is 1 if any\n      element of a is not less than the\n      corresponding element of b. Otherwise,\n      r is 0.",
        "endianness": "None.",
        "instructions": [ "xvcmpgtdp.", "mfocrf", "rlwinm", "cntlzw", "srwi", "xvcmpgtsp." ],
        "type_signatures": {
            "var_heads": [ "r", "a", "b", "Example Implementation" ],
            "list": [
                [ "int", "vector float", "vector float", "xvcmpgtdp.  t,b,a\n  mfocrf      u,2\n  rlwinm      v,u,25,1\n  cntlzw      w,v\n  srwi        r,w,5" ],
                [ "int", "vector double", "vector double", "xvcmpgtdp.  t,b,a\n  mfocrf      u,2\n  rlwinm      v,u,25,1\n  cntlzw      w,v\n  srwi        r,w,5" ]
            ]
        }
    },
    {
        "mnemonic": "vec_any_numeric",
        "name": "Vector Any Numeric",
        "syntax": "r = vec_any_numeric (a)",
        "purpose": "Tests whether any element of the source vector is numeric (not a NaN).",
        "result": "r is 1 if any\n      element of a is numeric (not a NaN).\n      Otherwise, r is 0.",
        "endianness": "None.",
        "instructions": [ "xvcmpeqdp.", "mfocrf", "rlwinm", "cntlzw", "srwi", "xvcmpeqsp." ],
        "type_signatures": {
            "var_heads": [ "r", "a", "Example Implementation" ],
            "list": [
                [ "int", "vector float", "xvcmpeqsp.  t,a,a\n  mfocrf      u,2\n  rlwinm      v,u,27,1\n  cntlzw      w,v\n  srwi        r,w,5" ],
                [ "int", "vector double", "xvcmpeqdp.  t,a,a\n  mfocrf      u,2\n  rlwinm      v,u,27,1\n  cntlzw      w,v\n  srwi        r,w,5" ]
            ]
        }
    },
    {
        "mnemonic": "vec_any_out",
        "name": "Vector Any Out of Range",
        "syntax": "r = vec_any_out (a, b)",
        "purpose": "Tests whether the value of any element of a vector is outside of a\n      given range.",
        "result": "r is 1 if the\n      value of any element of a is greater\n      than the value of the corresponding element of b or less than the negative of the value of the\n      corresponding element of b. Otherwise,\n      r is 0.",
        "endianness": "None.",
        "instructions": [ "vcmpbfp.", "mfocrf", "rlwinm", "cntlzw", "srwi" ],
        "type_signatures": {
            "var_heads": [ "r", "a", "b", "Example Implementation" ],
            "list": [
                [ "int", "vector float", "vector float", "vcmpbfp.  t,a,b\n  mfocrf    u,2\n  rlwinm    v,u,27,1\n  cntlzw    w,v\n  srwi      r,w,5" ]
            ]
        }
    },
    {
        "mnemonic": "vec_avg",
        "name": "Vector Average",
        "syntax": "r = vec_avg (a, b)",
        "purpose": "Returns a vector containing the elementwise average of two vectors.",
        "result": "The value of each element of r is the\n      average of the value of the corresponding elements of a and b.",
        "endianness": "None.",
        "instructions": [ "vavgsb", "vavgub", "vavgsh", "vavguh", "vavgsw", "vavguw" ],
        "type_signatures": {
            "var_heads": [ "r", "a", "b", "Example Implementation" ],
            "list": [
                [ "vector signed char", "vector signed char", "vector signed char", "vavgsb r,a,b" ],
                [ "vector unsigned char", "vector unsigned char", "vector unsigned char", "vavgub r,a,b" ],
                [ "vector signed short", "vector signed short", "vector signed short", "vavgsh r,a,b" ],
                [ "vector unsigned short", "vector unsigned short", "vector unsigned short", "vavguh r,a,b" ],
                [ "vector signed int", "vector signed int", "vector signed int", "vavgsw r,a,b" ],
                [ "vector unsigned int", "vector unsigned int", "vector unsigned int", "vavguw r,a,b" ]
            ]
        }
    },
    {
        "mnemonic": "vec_bperm",
        "name": "Vector Bit Permute",
        "syntax": "r = vec_bperm (a, b)",
        "purpose": "Gathers up to 16 one-bit values from a quadword or from each\n      doubleword element in the specified order, zeroing other bits.",
        "result": "",
        "endianness": "",
        "instructions": [ "vbpermq", "vbpermd" ],
        "type_signatures": {
            "var_heads": [ "r", "a", "b", "Example Implementation", "Restrictions" ],
            "list": [
                [ "vector unsigned char", "vector unsigned char", "vector unsigned char", "vbpermq r,a,b" ],
                [ "vector unsigned long long", "vector unsigned __int128", "vector unsigned char", "vbpermq r,a,b", "" ],
                [ "vector unsigned long long", "vector unsigned long long", "vector unsigned char", "vbpermd r,a,b", "ISA 3.0 or later" ]
            ]
        }
    },
    {
        "mnemonic": "vec_ceil",
        "name": "Vector Ceiling",
        "syntax": "r = vec_ceil (a)",
        "purpose": "Returns a vector r that contains the\n      result of applying the floating-point ceiling function to each\n      element of a.",
        "result": "The value of each element of r is the\n      smallest representable floating-point integral value greater than or\n      equal to the value of the corresponding element of\n      a.",
        "endianness": "None.",
        "instructions": [ "xvrspip", "xvrdpip" ],
        "type_signatures": {
            "var_heads": [ "r", "a", "Example Implementation" ],
            "list": [
                [ "vector float", "vector float", "xvrspip  r,a" ],
                [ "vector double", "vector double", "xvrdpip  r,a" ]
            ]
        }
    },
    {
        "mnemonic": "vec_cipher_be",
        "name": "Vector AES Cipher Big-Endian",
        "syntax": "r = vec_cipher_be (a, b)",
        "purpose": "Performs one round of the AES cipher operation on an intermediate state\n      array a by using a given round key\n      b.",
        "result": "r contains the\n      resulting intermediate state, after one round of the AES cipher\n      operation on intermediate state array a,\n      using the round key specified by b.",
        "endianness": "",
        "instructions": [ "vcipher" ],
        "type_signatures": {
            "var_heads": [ "r", "a", "b", "Example Implementation" ],
            "list": [
                [ "vector unsigned char", "vector unsigned char", "vector unsigned char", "vcipher  r,a,b" ]
            ]
        }
    },
    {
        "mnemonic": "vec_cipherlast_be",
        "name": "Vector AES Cipher Last Big-Endian",
        "syntax": "r = vec_cipherlast_be (a, b)",
        "purpose": "Performs the final round of the AES cipher operation on an intermediate\n      state array a using the specified\n      round key b.",
        "result": "r contains the\n      resulting final state, after the final round of the AES cipher\n      operation on intermediate state array a,\n      using the round key specified by b.",
        "endianness": "",
        "instructions": [ "vcipherlast" ],
        "type_signatures": {
            "var_heads": [ "r", "a", "b", "Example Implementation" ],
            "list": [
                [ "vector unsigned char", "vector unsigned char", "vector unsigned char", "vcipherlast  r,a,b" ]
            ]
        }
    },
    {
        "mnemonic": "vec_cmpb",
        "name": "Vector Compare Bytes",
        "syntax": "r = vec_cmpb (a, b)",
        "purpose": "Performs a bounds comparison of each set of corresponding elements\n      of two vectors.",
        "result": "",
        "endianness": "None.",
        "instructions": [ "vcmpbfp" ],
        "type_signatures": {
            "var_heads": [ "r", "a", "b", "Example Implementation" ],
            "list": [
                [ "vector signed int", "vector float", "vector float", "vcmpbfp  r,a,b" ]
            ]
        }
    },
    {
        "mnemonic": "vec_cmpeq",
        "name": "Vector Compare Equal",
        "syntax": "r = vec_cmpeq (a, b)",
        "purpose": "Returns a vector containing the results of comparing each set of\n      corresponding elements of two vectors for equality.",
        "result": "For each element of r, the value\n      of each bit is 1 if the corresponding elements of a and b\n      are equal.  Otherwise, the value of each bit is 0.",
        "endianness": "None.",
        "instructions": [ "vcmpequb", "vcmpequh", "vcmpequw", "vcmpequd", "xvcmpeqsp", "xvcmpeqdp" ],
        "type_signatures": {
            "var_heads": [ "r", "a", "b", "Example Implementation" ],
            "list": [
                [ "vector bool char", "vector bool char", "vector bool char", "vcmpequb  r,a,b" ],
                [ "vector bool char", "vector signed char", "vector signed char", "vcmpequb  r,a,b" ],
                [ "vector bool char", "vector unsigned char", "vector unsigned char", "vcmpequb  r,a,b" ],
                [ "vector bool short", "vector bool short", "vector bool short", "vcmpequh  r,a,b" ],
                [ "vector bool short", "vector signed short", "vector signed short", "vcmpequh  r,a,b" ],
                [ "vector bool short", "vector unsigned short", "vector unsigned short", "vcmpequh  r,a,b" ],
                [ "vector bool int", "vector bool int", "vector bool int", "vcmpequw  r,a,b" ],
                [ "vector bool int", "vector signed int", "vector signed int", "vcmpequw  r,a,b" ],
                [ "vector bool int", "vector unsigned int", "vector unsigned int", "vcmpequw  r,a,b" ],
                [ "vector bool long long", "vector bool long long", "vector bool long long", "vcmpequd  r,a,b" ],
                [ "vector bool long long", "vector signed long long", "vector signed long long", "vcmpequd  r,a,b" ],
                [ "vector bool long long", "vector unsigned long long", "vector unsigned long long", "vcmpequd  r,a,b" ],
                [ "vector bool int", "vector float", "vector float", "xvcmpeqsp  r,a,b" ],
                [ "vector bool long long", "vector double", "vector double", "xvcmpeqdp  r,a,b" ]
            ]
        }
    },
    {
        "mnemonic": "vec_cmpge",
        "name": "Vector Compare Greater or Equal",
        "syntax": "r = vec_cmpge (a, b)",
        "purpose": "Returns a vector containing the results of a greater-than-or-equal-to\n      comparison between each set of corresponding elements of two\n      vectors.",
        "result": "For each element of r, the value\n      of each bit is 1 if the corresponding element of a is greater than or equal to the corresponding\n      element of b.  Otherwise, the value\n      of each bit is 0.",
        "endianness": "None.",
        "instructions": [ "vcmpgtsb", "xxlnor", "vcmpgtub", "vcmpgtsh", "vcmpgtuh", "vcmpgtsw", "vcmpgtuw", "vcmpgtsd", "vcmpgtud", "xvcmpgesp", "xvcmpgedp" ],
        "type_signatures": {
            "var_heads": [ "r", "a", "b", "Example Implementation" ],
            "list": [
                [ "vector bool char", "vector signed char", "vector signed char", "vcmpgtsb  t,b,a\n   xxlnor    r,t,t" ],
                [ "vector bool char", "vector unsigned char", "vector unsigned char", "vcmpgtub  t,b,a\n   xxlnor    r,t,t" ],
                [ "vector bool short", "vector signed short", "vector signed short", "vcmpgtsh  t,b,a\n   xxlnor    r,t,t" ],
                [ "vector bool short", "vector unsigned short", "vector unsigned short", "vcmpgtuh  t,b,a\n   xxlnor    r,t,t" ],
                [ "vector bool int", "vector signed int", "vector signed int", "vcmpgtsw  t,b,a\n   xxlnor    r,t,t" ],
                [ "vector bool int", "vector unsigned int", "vector unsigned int", "vcmpgtuw  t,b,a\n   xxlnor    r,t,t" ],
                [ "vector bool long long", "vector signed long long", "vector signed long long", "vcmpgtsd  t,b,a\n   xxlnor    r,t,t" ],
                [ "vector bool long long", "vector unsigned long long", "vector unsigned long long", "vcmpgtud  t,b,a\n   xxlnor    r,t,t" ],
                [ "vector bool int", "vector float", "vector float", "xvcmpgesp  r,a,b" ],
                [ "vector bool long long", "vector double", "vector double", "xvcmpgedp  r,a,b" ]
            ]
        }
    },
    {
        "mnemonic": "vec_cmpgt",
        "name": "Vector Compare Greater Than",
        "syntax": "r = vec_cmpgt (a, b)",
        "purpose": "Returns a vector containing the results of a greater-than\n      comparison between each set of corresponding elements of two\n      vectors.",
        "result": "For each element of r, the value\n      of each bit is 1 if the corresponding element of a is greater than the corresponding\n      element of b.  Otherwise, the value\n      of each bit is 0.",
        "endianness": "None.",
        "instructions": [ "vcmpgtsb", "vcmpgtub", "vcmpgtsh", "vcmpgtuh", "vcmpgtsw", "vcmpgtuw", "vcmpgtsd", "vcmpgtud", "xvcmpgtsp", "xvcmpgtdp" ],
        "type_signatures": {
            "var_heads": [ "r", "a", "b", "Example Implementation" ],
            "list": [
                [ "vector bool char", "vector signed char", "vector signed char", "vcmpgtsb  r,a,b" ],
                [ "vector bool char", "vector unsigned char", "vector unsigned char", "vcmpgtub  r,a,b" ],
                [ "vector bool short", "vector signed short", "vector signed short", "vcmpgtsh  r,a,b" ],
                [ "vector bool short", "vector unsigned short", "vector unsigned short", "vcmpgtuh  r,a,b" ],
                [ "vector bool int", "vector signed int", "vector signed int", "vcmpgtsw  r,a,b" ],
                [ "vector bool int", "vector unsigned int", "vector unsigned int", "vcmpgtuw  r,a,b" ],
                [ "vector bool long long", "vector signed long long", "vector signed long long", "vcmpgtsd  r,a,b" ],
                [ "vector bool long long", "vector unsigned long long", "vector unsigned long long", "vcmpgtud  r,a,b" ],
                [ "vector bool int", "vector float", "vector float", "xvcmpgtsp  r,a,b" ],
                [ "vector bool long long", "vector double", "vector double", "xvcmpgtdp  r,a,b" ]
            ]
        }
    },
    {
        "mnemonic": "vec_cmple",
        "name": "Vector Compare Less Than or Equal",
        "syntax": "r = vec_cmple (a, b)",
        "purpose": "Returns a vector containing the results of a less-than-or-equal\n      comparison between each set of corresponding elements of two\n      vectors.",
        "result": "For each element of r, the value\n      of each bit is 1 if the corresponding element of a is less than or equal to the corresponding\n      element of b.  Otherwise, the value\n      of each bit is 0.",
        "endianness": "None.",
        "instructions": [ "vcmpgtsb", "xxlnor", "vcmpgtub", "vcmpgtsh", "vcmpgtuh", "vcmpgtsw", "vcmpgtuw", "vcmpgtsd", "vcmpgtud", "xvcmpgesp", "xvcmpgedp" ],
        "type_signatures": {
            "var_heads": [ "r", "a", "b", "Example Implementation" ],
            "list": [
                [ "vector bool char", "vector signed char", "vector signed char", "vcmpgtsb  t,a,b\n   xxlnor    r,t,t" ],
                [ "vector bool char", "vector unsigned char", "vector unsigned char", "vcmpgtub  t,a,b\n   xxlnor    r,t,t" ],
                [ "vector bool short", "vector signed short", "vector signed short", "vcmpgtsh  t,a,b\n   xxlnor    r,t,t" ],
                [ "vector bool short", "vector unsigned short", "vector unsigned short", "vcmpgtuh  t,a,b\n   xxlnor    r,t,t" ],
                [ "vector bool int", "vector signed int", "vector signed int", "vcmpgtsw  t,a,b\n   xxlnor    r,t,t" ],
                [ "vector bool int", "vector unsigned int", "vector unsigned int", "vcmpgtuw  t,a,b\n   xxlnor    r,t,t" ],
                [ "vector bool long long", "vector signed long long", "vector signed long long", "vcmpgtsd  t,a,b\n   xxlnor    r,t,t" ],
                [ "vector bool long long", "vector unsigned long long", "vector unsigned long long", "vcmpgtud  t,a,b\n   xxlnor    r,t,t" ],
                [ "vector bool int", "vector float", "vector float", "xvcmpgesp  r,b,a" ],
                [ "vector bool long long", "vector double", "vector double", "xvcmpgedp  r,b,a" ]
            ]
        }
    },
    {
        "mnemonic": "vec_cmplt",
        "name": "Vector Compare Less Than",
        "syntax": "r = vec_cmplt (a, b)",
        "purpose": "Returns a vector containing the results of a less-than\n      comparison between each set of corresponding elements of two\n      vectors.",
        "result": "For each element of r, the value\n      of each bit is 1 if the corresponding element of a is less than the corresponding\n      element of b.  Otherwise, the value\n      of each bit is 0.",
        "endianness": "None.",
        "instructions": [ "vcmpgtsb", "vcmpgtub", "vcmpgtsh", "vcmpgtuh", "vcmpgtsw", "vcmpgtuw", "vcmpgtsd", "vcmpgtud", "xvcmpgtsp", "xvcmpgtdp" ],
        "type_signatures": {
            "var_heads": [ "r", "a", "b", "Example Implementation" ],
            "list": [
                [ "vector bool char", "vector signed char", "vector signed char", "vcmpgtsb  r,b,a" ],
                [ "vector bool char", "vector unsigned char", "vector unsigned char", "vcmpgtub  r,b,a" ],
                [ "vector bool short", "vector signed short", "vector signed short", "vcmpgtsh  r,b,a" ],
                [ "vector bool short", "vector unsigned short", "vector unsigned short", "vcmpgtuh  r,b,a" ],
                [ "vector bool int", "vector signed int", "vector signed int", "vcmpgtsw  r,b,a" ],
                [ "vector bool int", "vector unsigned int", "vector unsigned int", "vcmpgtuw  r,b,a" ],
                [ "vector bool long long", "vector signed long long", "vector signed long long", "vcmpgtsd  r,b,a" ],
                [ "vector bool long long", "vector unsigned long long", "vector unsigned long long", "vcmpgtud  r,b,a" ],
                [ "vector bool int", "vector float", "vector float", "xvcmpgtsp  r,b,a" ],
                [ "vector bool long long", "vector double", "vector double", "xvcmpgtdp  r,b,a" ]
            ]
        }
    },
    {
        "mnemonic": "vec_cmpne",
        "name": "Vector Compare Not Equal",
        "syntax": "r = vec_cmpne (a, b)",
        "purpose": "Returns a vector containing the results of comparing each set of\n      corresponding elements of two vectors for inequality.",
        "result": "For each element of r, the value\n      of each bit is 1 if the corresponding elements of a and b\n      are not equal.  Otherwise, the value of each bit is 0.",
        "endianness": "None.",
        "instructions": [ "vcmpneb", "vcmpneh", "vcmpnew", "vcmpequd", "xxlnor", "xvcmpeqsp", "xvcmpeqdp" ],
        "type_signatures": {
            "var_heads": [ "r", "a", "b", "Example Implementation" ],
            "list": [
                [ "vector bool char", "vector bool char", "vector bool char", "vcmpneb  r,a,b" ],
                [ "vector bool char", "vector signed char", "vector signed char", "vcmpneb  r,a,b" ],
                [ "vector bool char", "vector unsigned char", "vector unsigned char", "vcmpneb  r,a,b" ],
                [ "vector bool short", "vector bool short", "vector bool short", "vcmpneh  r,a,b" ],
                [ "vector bool short", "vector signed short", "vector signed short", "vcmpneh  r,a,b" ],
                [ "vector bool short", "vector unsigned short", "vector unsigned short", "vcmpneh  r,a,b" ],
                [ "vector bool int", "vector bool int", "vector bool int", "vcmpnew  r,a,b" ],
                [ "vector bool int", "vector signed int", "vector signed int", "vcmpnew  r,a,b" ],
                [ "vector bool int", "vector unsigned int", "vector unsigned int", "vcmpnew  r,a,b" ],
                [ "vector bool long long", "vector bool long long", "vector bool long long", "vcmpequd  t,a,b\n   xxlnor    r,t,t" ],
                [ "vector bool long long", "vector signed long long", "vector signed long long", "vcmpequd  t,a,b\n   xxlnor    r,t,t" ],
                [ "vector bool long long", "vector unsigned long long", "vector unsigned long long", "vcmpequd  t,a,b\n   xxlnor    r,t,t" ],
                [ "vector bool int", "vector float", "vector float", "xvcmpeqsp  t,a,b\n   xxlnor     r,t,t" ],
                [ "vector bool long long", "vector double", "vector double", "xvcmpeqdp  t,a,b\n   xxlnor     r,t,t" ]
            ]
        }
    },
    {
        "mnemonic": "vec_cmpnez",
        "name": "Vector Compare Not Equal or Zero",
        "syntax": "r = vec_cmpnez (a, b)",
        "purpose": "Returns a vector containing the results of comparing each set of\n      corresponding elements of two vectors for inequality, or for\n      an element with a zero value.",
        "result": "For each element of r, the value\n      of each bit is 1 if the corresponding elements of a and b\n      are not equal, or if the a element or\n      the b element is zero.  Otherwise,\n      the value of each bit is 0.",
        "endianness": "None.",
        "instructions": [ "vcmpnezb", "vcmpnezh", "vcmpnezw" ],
        "type_signatures": {
            "var_heads": [ "r", "a", "b", "Example Implementation", "Restrictions" ],
            "list": [
                [ "vector bool char", "vector signed char", "vector signed char", "vcmpnezb  r,a,b", "ISA 3.0 or later" ],
                [ "vector bool char", "vector unsigned char", "vector unsigned char", "vcmpnezb  r,a,b", "ISA 3.0 or later" ],
                [ "vector bool short", "vector signed short", "vector signed short", "vcmpnezh  r,a,b", "ISA 3.0 or later" ],
                [ "vector bool short", "vector unsigned short", "vector unsigned short", "vcmpnezh  r,a,b", "ISA 3.0 or later" ],
                [ "vector bool int", "vector signed int", "vector signed int", "vcmpnezw  r,a,b", "ISA 3.0 or later" ],
                [ "vector bool int", "vector unsigned int", "vector unsigned int", "vcmpnezw  r,a,b", "ISA 3.0 or later" ]
            ]
        }
    },
    {
        "mnemonic": "vec_cntlz",
        "name": "Vector Count Leading Zeros",
        "syntax": "r = vec_cntlz (a)",
        "purpose": "Returns a vector containing the number of most-significant bits\n      equal to zero of each corresponding element of the source vector.",
        "result": "The value of each element of r is\n      set to the number of leading zeros of the corresponding element\n      of a.",
        "endianness": "None.",
        "instructions": [ "vclzb", "vclzh", "vclzw", "vclzd" ],
        "type_signatures": {
            "var_heads": [ "r", "a", "Example Implementation", "Restrictions" ],
            "list": [
                [ "vector signed char", "vector signed char", "vclzb  r,a", "" ],
                [ "vector unsigned char", "vector unsigned char", "vclzb  r,a", "" ],
                [ "vector signed short", "vector signed short", "vclzh  r,a", "" ],
                [ "vector unsigned short", "vector unsigned short", "vclzh  r,a", "" ],
                [ "vector signed int", "vector signed int", "vclzw  r,a", "" ],
                [ "vector unsigned int", "vector unsigned int", "vclzw  r,a", "" ],
                [ "vector signed long long", "vector signed long long", "vclzd  r,a", "" ],
                [ "vector unsigned long long", "vector unsigned int long long", "vclzd  r,a", "" ]
            ]
        }
    },
    {
        "mnemonic": "vec_cntlz_lsbb",
        "name": "Vector Count Leading Zero Least-Significant Bits by Byte",
        "syntax": "r = vec_cntlz_lsbb (a)",
        "purpose": "Returns the number of leading byte elements (starting at the\n      lowest-numbered element) of a vector that have a least-significant\n      bit of zero.",
        "result": "The value of r is set to the\n      number of leading byte elements (starting at the lowest-numbered\n      element) of a that have a\n      least-significant bit of zero.",
        "endianness": "The element numbering within a register is left-to-right for\n      big-endian targets, and right-to-left for little-endian\n      targets.",
        "instructions": [ "vclzlsbb" ],
        "type_signatures": {
            "var_heads": [ "r", "a", "Example BE Implementation", "Example LE Implementation", "Restrictions" ],
            "list": [
                [ "signed int", "vector signed char", "vclzlsbb  r,a", "vctzlsbb  r,a", "ISA 3.0 or later" ],
                [ "signed int", "vector unsigned char", "vclzlsbb  r,a", "vctzlsbb  r,a", "ISA 3.0 or later" ]
            ]
        }
    },
    {
        "mnemonic": "vec_cnttz",
        "name": "Vector Count Trailing Zeros",
        "syntax": "r = vec_cnttz (a)",
        "purpose": "Returns a vector containing the number of least-significant bits\n      equal to zero of each corresponding element of the source vector.",
        "result": "The value of each element of r is\n      set to the number of trailing zeros of the corresponding element\n      of a.",
        "endianness": "None.",
        "instructions": [ "vctzb", "vctzh", "vctzw", "vctzd" ],
        "type_signatures": {
            "var_heads": [ "r", "a", "Example Implementation", "Restrictions" ],
            "list": [
                [ "vector signed char", "vector signed char", "vctzb  r,a", "ISA 3.0 or later" ],
                [ "vector unsigned char", "vector unsigned char", "vctzb  r,a", "ISA 3.0 or later" ],
                [ "vector signed short", "vector signed short", "vctzh  r,a", "ISA 3.0 or later" ],
                [ "vector unsigned short", "vector unsigned short", "vctzh  r,a", "ISA 3.0 or later" ],
                [ "vector signed int", "vector signed int", "vctzw  r,a", "ISA 3.0 or later" ],
                [ "vector unsigned int", "vector unsigned int", "vctzw  r,a", "ISA 3.0 or later" ],
                [ "vector signed long long", "vector signed long long", "vctzd  r,a", "ISA 3.0 or later" ],
                [ "vector unsigned long long", "vector unsigned int long long", "vctzd  r,a", "ISA 3.0 or later" ]
            ]
        }
    },
    {
        "mnemonic": "vec_cnttz_lsbb",
        "name": "Vector Count Trailing Zero Least-Significant Bits by Byte",
        "syntax": "r = vec_cnttz_lsbb (a)",
        "purpose": "Returns the number of trailing byte elements (starting at the\n      highest-numbered element) of a vector that have a least-significant\n      bit of zero.",
        "result": "The value of r is set to the\n      number of trailing byte elements (starting at the highest-numbered\n      element) of a that have a\n      least-significant bit of zero.",
        "endianness": "The element numbering within a register is left-to-right for\n      big-endian targets, and right-to-left for little-endian\n      targets.",
        "instructions": [ "vctzlsbb" ],
        "type_signatures": {
            "var_heads": [ "r", "a", "Example BE Implementation", "Example LE Implementation", "Restrictions" ],
            "list": [
                [ "signed int", "vector signed char", "vctzlsbb  r,a", "vclzlsbb  r,a", "ISA 3.0 or later" ],
                [ "signed int", "vector unsigned char", "vctzlsbb  r,a", "vclzlsbb  r,a", "ISA 3.0 or later" ]
            ]
        }
    },
    {
        "mnemonic": "vec_cpsgn",
        "name": "Vector Copy Sign",
        "syntax": "r = vec_cpsgn (a, b)",
        "purpose": "Returns a vector by copying the sign of the elements in one\n      vector to the sign of the corresponding elements of another\n      vector.",
        "result": "The value of each element of r is set\n      to the corresponding element of b\n      with its sign replaced by the sign from the corresponding element of\n      a.",
        "endianness": "None.",
        "instructions": [ "xvcpsgnsp", "xvcpsgndp" ],
        "type_signatures": {
            "var_heads": [ "r", "a", "b", "Example Implementation", "Restrictions" ],
            "list": [
                [ "vector float", "vector float", "vector float", "xvcpsgnsp  r,b,a", "" ],
                [ "vector double", "vector double", "vector double", "xvcpsgndp  r,b,a", "" ]
            ]
        }
    },
    {
        "mnemonic": "vec_ctf",
        "name": "Vector Convert to Floating-Point",
        "syntax": "r = vec_ctf (a, b)",
        "purpose": "Converts an integer vector into a floating-point vector.",
        "result": "The value of each element of r is the\n      closest floating-point approximation of the value of the\n      corresponding element of a divided\n      by 2 to the power of b, which must\n      be in the range 0–31.",
        "endianness": "None.",
        "instructions": [ "vcfsx", "vcfux" ],
        "type_signatures": {
            "var_heads": [ "r", "a", "b", "Example Implementation" ],
            "list": [
                [ "vector float", "vector signed int", "5-bit unsigned literal", "vcfsx  r,a,b" ],
                [ "vector float", "vector unsigned int", "5-bit unsigned literal", "vcfux  r,a,b" ],
                [ "vector double", "vector signed long long", "5-bit unsigned literal", "xvcvsxddp  r,a,b" ],
                [ "vector double", "vector unsigned long long", "5-bit unsigned literal", "xvcvuxddp  r,a,b" ]
            ]
        }
    },
    {
        "mnemonic": "vec_cts",
        "name": "Vector Convert to Signed Integer",
        "syntax": "r = vec_cts (a, b)",
        "purpose": "Converts a floating-point vector into a signed integer vector.",
        "result": "The value of each element of r is the\n      saturated signed-integer value, truncated towards zero, obtained by\n      multiplying the corresponding element of a multiplied by 2 to the power of b, which must be in the range 0–31.",
        "endianness": "None.",
        "instructions": [ "vctsxs" ],
        "type_signatures": {
            "var_heads": [ "r", "a", "b", "Example Implementation" ],
            "list": [
                [ "vector signed int", "vector float", "5-bit unsigned literal", "vctsxs  r,a,b" ]
            ]
        }
    },
    {
        "mnemonic": "vec_ctu",
        "name": "Vector Convert to Unsigned Integer",
        "syntax": "r = vec_ctu (a, b)",
        "purpose": "Converts a floating-point vector into an unsigned integer vector.",
        "result": "The value of each element of r is the\n      saturated unsigned-integer value, truncated towards zero, obtained by\n      multiplying the corresponding element of a multiplied by 2 to the power of b, which must be in the range 0–31.",
        "endianness": "None.",
        "instructions": [ "vctuxs" ],
        "type_signatures": {
            "var_heads": [ "r", "a", "b", "Example Implementation" ],
            "list": [
                [ "vector unsigned int", "vector float", "5-bit unsigned literal", "vctuxs  r,a,b" ]
            ]
        }
    },
    {
        "mnemonic": "vec_div",
        "name": "Vector Divide",
        "syntax": "r = vec_div (a, b)",
        "purpose": "Divides the elements in one vector by the corresponding elements\n      in another vector and places the quotients in the result vector.",
        "result": "The value of each element of r is\n      obtained by dividing the corresponding element of a by the corresponding element of b.",
        "endianness": "None.",
        "instructions": [ "xxspltd", "mfvsrd", "divd", "mtvsrd", "xxmrghd", "xvdivsp", "xvdivdp" ],
        "type_signatures": {
            "var_heads": [ "r", "a", "b", "Example Implementation" ],
            "list": [
                [ "vector signed long long", "vector signed long long", "vector signed long long", "xxspltd t,a,1\n   mfvsrd  u,t\n   xxspltd v,b,1\n   mfvsrd  w,v\n   divd    x,u,w\n   mfvsrd  u,a\n   mtvsrd  y,x\n   mfvsrd  w,b\n   divd    x,u,w\n   mtvsrd  z,x\n   xxmrghd r,z,y" ],
                [ "vector unsigned long long", "vector unsigned long long", "vector unsigned long long", "xxspltd t,a,1\n   mfvsrd  u,t\n   xxspltd v,b,1\n   mfvsrd  w,v\n   divd    x,u,w\n   mfvsrd  u,a\n   mtvsrd  y,x\n   mfvsrd  w,b\n   divd    x,u,w\n   mtvsrd  z,x\n   xxmrghd r,z,y" ],
                [ "vector float", "vector float", "vector float", "xvdivsp r,a,b" ],
                [ "vector double", "vector double", "vector double", "xvdivdp r,a,b" ]
            ]
        }
    },
    {
        "mnemonic": "vec_double",
        "name": "Vector Convert to Double Precision",
        "syntax": "r = vec_double (a)",
        "purpose": "Converts a vector of long integers into a vector of double-precision\n      numbers.",
        "result": "The value of each element of r is\n      obtained by converting the corresponding element of a to double precision floating-point.",
        "endianness": "None.",
        "instructions": [ "xvcvsxddp", "xvcvuxddp" ],
        "type_signatures": {
            "var_heads": [ "r", "a", "Example Implementation" ],
            "list": [
                [ "vector double", "vector signed long long", "xvcvsxddp r,a" ],
                [ "vector double", "vector unsigned long long", "xvcvuxddp r,a" ]
            ]
        }
    },
    {
        "mnemonic": "vec_doublee",
        "name": "Vector Convert Even Elements to Double Precision",
        "syntax": "r = vec_doublee (a)",
        "purpose": "Converts the even elements of a vector into a vector of double-precision\n      numbers.",
        "result": "Elements 0 and 1 of r are set to\n      the converted values of elements 0 and 2 of a.",
        "endianness": "Differences in element numbering require different implementations\n      for big- and little-endian code generation.",
        "instructions": [ "xxsldwi", "xvcvsxwdp", "xvcvuxwdp", "xvcvspdp" ],
        "type_signatures": {
            "var_heads": [ "r", "a", "Example LE Implementation", "Example BE Implementation", "Restrictions" ],
            "list": [
                [ "vector double", "vector signed int", "xxsldwi    t,a,a,1\n   xvcvsxwdp  r,t", "xvcvsxwdp  r,a", "" ],
                [ "vector double", "vector unsigned int", "xxsldwi    t,a,a,1\n   xvcvuxwdp  r,t", "xvcvuxwdp  r,a", "" ],
                [ "vector double", "vector float", "xxsldwi    t,a,a,1\n   xvcvspdp   r,t", "xvcvspdp   r,a", "" ]
            ]
        }
    },
    {
        "mnemonic": "vec_doubleh",
        "name": "Vector Convert High Elements to Double Precision",
        "syntax": "r = vec_doubleh (a)",
        "purpose": "Converts the high-order elements of a vector into a vector\n      of double-precision numbers.",
        "result": "Elements 0 and 1 of r are set to\n      the converted values of elements 0 and 1 of a.",
        "endianness": "Differences in element numbering require different implementations\n      for big- and little-endian code generation.",
        "instructions": [ "xxsldwi", "xvcvsxwdp", "xvcvuxwdp", "xvcvspdp" ],
        "type_signatures": {
            "var_heads": [ "r", "a", "Example LE Implementation", "Example BE Implementation", "Restrictions" ],
            "list": [
                [ "vector double", "vector signed int", "xxsldwi    t,a,a,3\n   xxsldwi    u,a,t,2\n   xvcvsxwdp  r,u", "xxsldwi    t,a,a,1\n   xxsldwi    u,t,a,3\n   xvcvsxwdp  r,u", "" ],
                [ "vector double", "vector unsigned int", "xxsldwi    t,a,a,3\n   xxsldwi    u,a,t,2\n   xvcvuxwdp  r,u", "xxsldwi    t,a,a,1\n   xxsldwi    u,t,a,3\n   xvcvuxwdp  r,u", "" ],
                [ "vector double", "vector float", "xxsldwi    t,a,a,3\n   xxsldwi    u,a,t,2\n   xvcvspdp   r,u", "xxsldwi    t,a,a,1\n   xxsldwi    u,t,a,3\n   xvcvspdp   r,u", "" ]
            ]
        }
    },
    {
        "mnemonic": "vec_doublel",
        "name": "Vector Convert Low Elements to Double Precision",
        "syntax": "r = vec_doublel (a)",
        "purpose": "Converts the low-order elements of a vector into a vector\n      of double-precision numbers.",
        "result": "Elements 0 and 1 of r are set to\n      the converted values of elements 2 and 3 of a.",
        "endianness": "Differences in element numbering require different implementations\n      for big- and little-endian code generation.",
        "instructions": [ "xxsldwi", "xvcvsxwdp", "xvcvuxwdp", "xvcvspdp" ],
        "type_signatures": {
            "var_heads": [ "r", "a", "Example LE Implementation", "Example BE Implementation", "Restrictions" ],
            "list": [
                [ "vector double", "vector signed int", "xxsldwi    t,a,a,1\n   xxsldwi    u,t,a,3\n   xvcvsxwdp  r,u", "xxsldwi    t,a,a,3\n   xxsldwi    u,a,t,2\n   xvcvsxwdp  r,u", "" ],
                [ "vector double", "vector unsigned int", "xxsldwi    t,a,a,1\n   xxsldwi    u,t,a,3\n   xvcvuxwdp  r,u", "xxsldwi    t,a,a,3\n   xxsldwi    u,a,t,2\n   xvcvuxwdp  r,u", "" ],
                [ "vector double", "vector float", "xxsldwi    t,a,a,1\n   xxsldwi    u,t,a,3\n   xvcvspdp   r,u", "xxsldwi    t,a,a,3\n   xxsldwi    u,a,t,2\n   xvcvspdp   r,u", "" ]
            ]
        }
    },
    {
        "mnemonic": "vec_doubleo",
        "name": "Vector Convert Odd Elements to Double Precision",
        "syntax": "r = vec_doubleo (a)",
        "purpose": "Converts the odd elements of a vector into a vector\n      of double-precision numbers.",
        "result": "Elements 0 and 1 of r are set to\n      the converted values of elements 1 and 3 of a.",
        "endianness": "Differences in element numbering require different implementations\n      for big- and little-endian code generation.",
        "instructions": [ "xvcvsxwdp", "xxsldwi", "xvcvuxwdp", "xvcvspdp" ],
        "type_signatures": {
            "var_heads": [ "r", "a", "Example LE Implementation", "Example BE Implementation", "Restrictions" ],
            "list": [
                [ "vector double", "vector signed int", "xvcvsxwdp  r,a", "xxsldwi    t,a,a,1\n   xvcvsxwdp  r,t", "" ],
                [ "vector double", "vector unsigned int", "xvcvuxwdp  r,a", "xxsldwi    t,a,a,1\n   xvcvuxwdp  r,t", "" ],
                [ "vector double", "vector float", "xvcvspdp   r,a", "xxsldwi    t,a,a,1\n   xvcvspdp   r,t", "" ]
            ]
        }
    },
    {
        "mnemonic": "vec_eqv",
        "name": "Vector Equivalence",
        "syntax": "r = vec_eqv (a, b)",
        "purpose": "Performs a bitwise equivalence (exclusive NOR) of two vectors.",
        "result": "The value of r is the bitwise XNOR\n      of a and b.",
        "endianness": "None.",
        "instructions": [ "xxleqv" ],
        "type_signatures": {
            "var_heads": [ "r", "a", "b", "Example Implementation" ],
            "list": [
                [ "vector bool char", "vector bool char", "vector bool char", "xxleqv r,a,b" ],
                [ "vector signed char", "vector signed char", "vector signed char", "xxleqv r,a,b" ],
                [ "vector unsigned char", "vector unsigned char", "vector unsigned char", "xxleqv r,a,b" ],
                [ "vector bool short", "vector bool short", "vector bool short", "xxleqv r,a,b" ],
                [ "vector signed short", "vector signed short", "vector signed short", "xxleqv r,a,b" ],
                [ "vector unsigned short", "vector unsigned short", "vector unsigned short", "xxleqv r,a,b" ],
                [ "vector signed int", "vector signed int", "vector signed int", "xxleqv r,a,b" ],
                [ "vector bool int", "vector bool int", "vector bool int", "xxleqv r,a,b" ],
                [ "vector unsigned int", "vector unsigned int", "vector unsigned int", "xxleqv r,a,b" ],
                [ "vector bool long long", "vector bool long long", "vector bool long long", "xxleqv r,a,b" ],
                [ "vector signed long long", "vector signed long long", "vector signed long long", "xxleqv r,a,b" ],
                [ "vector unsigned long long", "vector unsigned long long", "vector unsigned long long", "xxleqv r,a,b" ],
                [ "vector float", "vector float", "vector float", "xxleqv r,a,b" ],
                [ "vector double", "vector double", "vector double", "xxleqv r,a,b" ]
            ]
        }
    },
    {
        "mnemonic": "vec_expte",
        "name": "Vector Exponential Estimate",
        "syntax": "r = vec_expte (a)",
        "purpose": "Returns a vector r containing\n      estimates of 2 raised to the power of the corresponding elements\n      of a.",
        "result": "The value of each element of r is the\n      estimated value of 2 raised to the power of the corresponding element of\n      a.",
        "endianness": "None.",
        "instructions": [ "vexptefp" ],
        "type_signatures": {
            "var_heads": [ "r", "a", "Example Implementation" ],
            "list": [
                [ "vector float", "vector float", "vexptefp  r,a" ]
            ]
        }
    },
    {
        "mnemonic": "vec_extract",
        "name": "Vector Extract",
        "syntax": "r = vec_extract (a, b)",
        "purpose": "Returns the value of the bth\n      element of vector a.",
        "result": "The value of each element of r is the\n      element of a at position\n      b modulo the number of elements of\n      a.",
        "endianness": "The element numbering within a register is left-to-right for big-endian\n      targets, and right-to-left for little-endian targets.",
        "instructions": [ "vextubrx", "extsb", "vextublx", "slwi", "vextuwrx", "extsw", "vextuwlx", "xori", "rldic", "mtvsrdd", "vslo", "mfvsrd", "vextuhrx", "extsh", "vextuhlx", "rldicl", "subfic", "sldi", "xscvspdp" ],
        "type_signatures": {
            "var_heads": [ "r", "a", "b", "Example ISA 3.0 LE\n  Implementation", "Example ISA 3.0 BE\n  Implementation" ],
            "list": [
                [ "signed char", "vector signed char", "signed int", "vextubrx t,b,a\n extsb    r,t", "vextublx t,b,a\n extsb    r,t" ],
                [ "unsigned char", "vector bool char", "signed int", "vextubrx t,b,a", "vextublx t,b,a" ],
                [ "unsigned char", "vector unsigned char", "signed int", "vextubrx t,b,a", "vextublx t,b,a" ],
                [ "signed short", "vector signed short", "signed int", "slwi     t,b,1\n vextuhrx u,t,a\n extsh    r,u", "slwi     t,b,1\n vextuhlx u,t,a\n extsh    r,u" ],
                [ "unsigned short", "vector bool short", "signed int", "slwi     t,b,1\n vextuhrx r,t,a", "slwi     t,b,1\n vextuhlx r,t,a" ],
                [ "unsigned short", "vector unsigned short", "signed int", "slwi     t,b,1\n vextuhrx r,t,a", "slwi     t,b,1\n vextuhlx r,t,a" ],
                [ "signed int", "vector signed int", "signed int", "slwi     t,b,2\n vextuwrx u,t,a\n extsw    r,u", "slwi     t,b,2\n vextuwlx u,t,a\n extsw    r,u" ],
                [ "unsigned int", "vector bool int", "signed int", "slwi     t,b,2\n vextuwrx r,t,a", "slwi     t,b,2\n vextuwlx r,t,a" ],
                [ "unsigned int", "vector unsigned int", "signed int", "slwi     t,b,2\n vextuwrx r,t,a", "slwi     t,b,2\n vextuwlx r,t,a" ],
                [ "signed long long", "vector signed long long", "signed int", "xori    t,b,0x1\n rldic   u,t,6,57\n mtvsrdd v,u,u\n vslo    w,a,v\n mfvsrd  r,w", "rldic   t,b,6,57\n mtvsrdd u,t,t\n vslo    v,a,u\n mfvsrd  r,v" ],
                [ "unsigned long long", "vector bool long long", "signed int", "xori    t,b,0x1\n rldic   u,t,6,57\n mtvsrdd v,u,u\n vslo    w,a,v\n mfvsrd  r,w", "rldic   t,b,6,57\n mtvsrdd u,t,t\n vslo    v,a,u\n mfvsrd  r,v" ],
                [ "unsigned long long", "vector unsigned long long", "signed int", "xori    t,b,0x1\n rldic   u,t,6,57\n mtvsrdd v,u,u\n vslo    w,a,v\n mfvsrd  r,w", "rldic   t,b,6,57\n mtvsrdd u,t,t\n vslo    v,a,u\n mfvsrd  r,v" ],
                [ "float", "vector float", "signed int", "rldicl   t,b,0,62\n subfic   u,t,3\n sldi     v,u,5\n mtvsrdd  w,v,v\n vslo     x,a,w\n xscvspdp r,x", "sldi     t,b,5\n mtvsrdd  u,t,t\n vslo     v,a,u\n xscvspdp r,v" ],
                [ "double", "vector double", "signed int", "xori    t,b,0x1\n rldic   u,t,6,57\n mtvsrdd v,u,u\n vslo    r,a,v", "rldic   t,b,6,57\n mtvsrdd u,t,t\n vslo    r,a,u" ]
            ]
        }
    },
    {
        "mnemonic": "vec_extract_exp",
        "name": "Vector Extract Exponent",
        "syntax": "r = vec_extract_exp (a)",
        "purpose": "Extracts exponents from a vector of floating-point numbers.",
        "result": "Each element of r is extracted\n      from the exponent field of the corresponding floating-point\n      vector element of a.",
        "endianness": "None.",
        "instructions": [ "xvxexpdp", "xvxexpsp" ],
        "type_signatures": {
            "var_heads": [ "r", "a", "Example Implementation", "Restrictions" ],
            "list": [
                [ "vector unsigned int", "vector float", "xvxexpsp r,a", "ISA 3.0 or later" ],
                [ "vector unsigned long long", "vector double", "xvxexpdp r,a", "ISA 3.0 or later" ]
            ]
        }
    },
    {
        "mnemonic": "vec_extract_fp32_from_shorth",
        "name": "Vector Extract Floats from High Elements of Vector Short Int",
        "syntax": "r = vec_extract_fp32_from_shorth (a)",
        "purpose": "Extracts four single-precision floating-point numbers from the high\n      elements of a vector of eight 16-bit elements, interpreting each\n      element as a 16-bit floating-point number in IEEE format.",
        "result": "The first four elements of a are\n      interpreted as 16-bit floating-point numbers in IEEE format, and\n      extended to single-precision format, returning a vector with four\n      single-precision IEEE numbers.",
        "endianness": "The element numbering within a register is left-to-right for big-endian\n      targets, and right-to-left for little-endian targets.",
        "instructions": [ "lxv", "vperm", "vpermr", "xvcvhpsp" ],
        "type_signatures": {
            "var_heads": [ "r", "a", "Example Implementation", "Restrictions" ],
            "list": [
                [ "vector float", "vector unsigned short", "lxv      t,0(pcv)\n  vperm[r] u,a,a,t\n  xvcvhpsp r,u", "ISA 3.0 or later" ]
            ]
        }
    },
    {
        "mnemonic": "vec_extract_fp32_from_shortl",
        "name": "Vector Extract Floats from Low Elements of Vector Short Int",
        "syntax": "r = vec_extract_fp32_from_shortl (a)",
        "purpose": "Extracts four single-precision floating-point numbers from the low\n      elements of a vector of eight 16-bit elements, interpreting each\n      element as a 16-bit floating-point number in IEEE format.",
        "result": "The last four elements of a are\n      interpreted as 16-bit floating-point numbers in IEEE format, and\n      extended to single-precision format, returning a vector with four\n      single-precision IEEE numbers.",
        "endianness": "The element numbering within a register is left-to-right for big-endian\n      targets, and right-to-left for little-endian targets.",
        "instructions": [ "lxv", "vperm", "vpermr", "xvcvhpsp" ],
        "type_signatures": {
            "var_heads": [ "r", "a", "Example Implementation", "Restrictions" ],
            "list": [
                [ "vector float", "vector unsigned short", "lxv      t,0(pcv)\n  vperm[r] u,a,a,t\n  xvcvhpsp r,u", "ISA 3.0 or later" ]
            ]
        }
    },
    {
        "mnemonic": "vec_extract_sig",
        "name": "Vector Extract Significand",
        "syntax": "r = vec_extract_sig (a)",
        "purpose": "Extracts a vector of significands (mantissas) from a vector of\n      floating-point numbers.",
        "result": "Each element of\n      r is extracted from the significand\n      (mantissa) field of the corresponding floating-point element of\n      a.",
        "endianness": "None.",
        "instructions": [ "xvxsigdp", "xvxsigsp" ],
        "type_signatures": {
            "var_heads": [ "r", "a", "Example Implementation", "Restrictions" ],
            "list": [
                [ "vector unsigned int", "vector float", "xvxsigsp r,a", "ISA 3.0 or later" ],
                [ "vector unsigned long long", "vector double", "xvxsigdp r,a", "ISA 3.0 or later" ]
            ]
        }
    },
    {
        "mnemonic": "vec_extract4b",
        "name": "Vector Extract Four Bytes",
        "syntax": "r = vec_extract4b (a, b)",
        "purpose": "Extracts a word from vector a at\n      constant byte position b.",
        "result": "The first\n      doubleword element of r contains\n      the zero-extended extracted word from a.\n      The second doubleword is set to 0. b\n      specifies the least-significant byte number (0–12) of the word\n      to be extracted.",
        "endianness": "The element numbering within a register is left-to-right for big-endian\n      targets, and right-to-left for little-endian targets.",
        "instructions": [ "xxextractuw" ],
        "type_signatures": {
            "var_heads": [ "r", "a", "b", "Example LE Implementation", "Example BE Implementation", "Restrictions" ],
            "list": [
                [ "vector unsigned long long", "vector unsigned char", "const int (range [0,12])", "xxextractuw r,a,12-b", "xxextractuw r,a,b", "ISA 3.0 or later" ]
            ]
        }
    },
    {
        "mnemonic": "vec_first_match_index",
        "name": "Vector Index of First Match",
        "syntax": "r = vec_first_match_index (a, b)",
        "purpose": "Performs a comparison of equality on each of the corresponding\n      elements of a and b, and returns the first position of\n      equality.",
        "result": "Returns the\n      element index of the position of the first character match in\n      natural element order.  If no match, returns the number of\n      characters as an element count in the vector argument.",
        "endianness": "The element numbering within a register is left-to-right for big-endian\n      targets, and right-to-left for little-endian targets.",
        "instructions": [ "vcmpneb", "vcmpneh", "vcmpnew", "xxlnor", "vctzlsbb", "vclzlsbb", "rldicl" ],
        "type_signatures": {
            "var_heads": [ "r", "a", "b", "Example LE\nImplementation", "Example BE\nImplementation", "Restrictions" ],
            "list": [
                [ "unsigned int", "vector signed char", "vector signed char", "vcmpneb  t,a,b\n  xxlnor    u,t,t\n  vctzlsbb  r,u", "vcmpneb  t,a,b\n  xxlnor    u,t,t\n  vclzlsbb  r,u", "ISA 3.0 or later" ],
                [ "unsigned int", "vector unsigned char", "vector unsigned char", "vcmpneb  t,a,b\n  xxlnor    u,t,t\n  vctzlsbb  r,u", "vcmpneb  t,a,b\n  xxlnor    u,t,t\n  vclzlsbb  r,u", "ISA 3.0 or later" ],
                [ "unsigned int", "vector signed short", "vector signed short", "vcmpneh  t,a,b\n  xxlnor    u,t,t\n  vctzlsbb  v,u\n  rldicl    r,v,63,33", "vcmpneh  t,a,b\n  xxlnor    u,t,t\n  vclzlsbb  v,u\n  rldicl    r,v,63,33", "ISA 3.0 or later" ],
                [ "unsigned int", "vector unsigned short", "vector unsigned short", "vcmpneh  t,a,b\n  xxlnor    u,t,t\n  vctzlsbb  v,u\n  rldicl    r,v,63,33", "vcmpneh  t,a,b\n  xxlnor    u,t,t\n  vclzlsbb  v,u\n  rldicl    r,v,63,33", "ISA 3.0 or later" ],
                [ "unsigned int", "vector signed int", "vector signed int", "vcmpnew  t,a,b\n  xxlnor    u,t,t\n  vctzlsbb  v,u\n  rldicl    r,v,62,34", "vcmpnew  t,a,b\n  xxlnor    u,t,t\n  vclzlsbb  v,u\n  rldicl    r,v,62,34", "ISA 3.0 or later" ],
                [ "unsigned int", "vector unsigned int", "vector unsigned int", "vcmpnew  t,a,b\n  xxlnor    u,t,t\n  vctzlsbb  v,u\n  rldicl    r,v,62,34", "vcmpnew  t,a,b\n  xxlnor    u,t,t\n  vclzlsbb  v,u\n  rldicl    r,v,62,34", "ISA 3.0 or later" ]
            ]
        }
    },
    {
        "mnemonic": "vec_first_match_or_eos_index",
        "name": "Vector Index of First Match or End of String",
        "syntax": "r = vec_first_match_or_eos_index (a, b)",
        "purpose": "Performs a comparison of equality on each of the corresponding\n      elements of a and b. Returns the first position of\n      equality, or the zero string terminator.",
        "result": "Returns the\n      element index of the position, in natural element order, of\n      either the first character match or an end-of-string (EOS)\n      terminator. If no match or terminator, returns the number of\n      characters as an element count in the vector argument.",
        "endianness": "The element numbering within a register is left-to-right for big-endian\n      targets, and right-to-left for little-endian targets.",
        "instructions": [ "xxspltib", "vcmpneb", "vcmpnezb", "vcmpneh", "vcmpnezh", "vcmpnew", "vcmpnezw", "xxland", "xxlnand", "vctzlsbb", "vclzlsbb", "rldicl" ],
        "type_signatures": {
            "var_heads": [ "r", "a", "b", "Example LE\nImplementation", "Example BE\nImplementation", "Restrictions" ],
            "list": [
                [ "unsigned int", "vector signed char", "vector signed char", "xxspltib  t,0\n vcmpneb   u,a,t\n vcmpneb   v,b,t\n vcmpnezb  w,a,b\n xxland    x,u,v\n xxlnand   y,x,w\n vctzlsbb  r,y", "xxspltib  t,0\n vcmpneb   u,a,t\n vcmpneb   v,b,t\n vcmpnezb  w,a,b\n xxland    x,u,v\n xxlnand   y,x,w\n vclzlsbb  r,y", "ISA 3.0 or later" ],
                [ "unsigned int", "vector unsigned char", "vector unsigned char", "xxspltib  t,0\n vcmpneb   u,a,t\n vcmpneb   v,b,t\n vcmpnezb  w,a,b\n xxland    x,u,v\n xxlnand   y,x,w\n vctzlsbb  r,y", "xxspltib  t,0\n vcmpneb   u,a,t\n vcmpneb   v,b,t\n vcmpnezb  w,a,b\n xxland    x,u,v\n xxlnand   y,x,w\n vclzlsbb  r,y", "ISA 3.0 or later" ],
                [ "unsigned int", "vector signed short", "vector signed short", "xxspltib  t,0\n vcmpneh   u,a,t\n vcmpneh   v,b,t\n vcmpnezh  w,a,b\n xxland    x,u,v\n xxlnand   y,x,w\n vctzlsbb  z,y\n rldicl    r,z,63,33", "xxspltib  t,0\n vcmpneh   u,a,t\n vcmpneh   v,b,t\n vcmpnezh  w,a,b\n xxland    x,u,v\n xxlnand   y,x,w\n vclzlsbb  z,y\n rldicl    r,z,63,33", "ISA 3.0 or later" ],
                [ "unsigned int", "vector unsigned short", "vector unsigned short", "xxspltib  t,0\n vcmpneh   u,a,t\n vcmpneh   v,b,t\n vcmpnezh  w,a,b\n xxland    x,u,v\n xxlnand   y,x,w\n vctzlsbb  z,y\n rldicl    r,z,63,33", "xxspltib  t,0\n vcmpneh   u,a,t\n vcmpneh   v,b,t\n vcmpnezh  w,a,b\n xxland    x,u,v\n xxlnand   y,x,w\n vclzlsbb  z,y\n rldicl    r,z,63,33", "ISA 3.0 or later" ],
                [ "unsigned int", "vector signed int", "vector signed int", "xxspltib  t,0\n vcmpnew   u,a,t\n vcmpnew   v,b,t\n vcmpnezw  w,a,b\n xxland    x,u,v\n xxlnand   y,x,w\n vctzlsbb  z,y\n rldicl    r,z,62,34", "xxspltib  t,0\n vcmpnew   u,a,t\n vcmpnew   v,b,t\n vcmpnezw  w,a,b\n xxland    x,u,v\n xxlnand   y,x,w\n vclzlsbb  z,y\n rldicl    r,z,62,34", "ISA 3.0 or later" ],
                [ "unsigned int", "vector unsigned int", "vector unsigned int", "xxspltib  t,0\n vcmpnew   u,a,t\n vcmpnew   v,b,t\n vcmpnezw  w,a,b\n xxland    x,u,v\n xxlnand   y,x,w\n vctzlsbb  z,y\n rldicl    r,z,62,34", "xxspltib  t,0\n vcmpnew   u,a,t\n vcmpnew   v,b,t\n vcmpnezw  w,a,b\n xxland    x,u,v\n xxlnand   y,x,w\n vclzlsbb  z,y\n rldicl    r,z,62,34", "ISA 3.0 or later" ]
            ]
        }
    },
    {
        "mnemonic": "vec_first_mismatch_index",
        "name": "Vector Index of First Mismatch",
        "syntax": "r = vec_first_mismatch_index (a, b)",
        "purpose": "Performs a comparison of inequality on each of the corresponding\n      elements of a and b, and returns the first position of\n      inequality.",
        "result": "Returns the\n      element index of the position of the first character mismatch in\n      natural element order. If no mismatch, returns the number of\n      characters as an element count in the vector argument.",
        "endianness": "The element numbering within a register is left-to-right for big-endian\n      targets, and right-to-left for little-endian targets.",
        "instructions": [ "vcmpneb", "vcmpneh", "vcmpnew", "vctzlsbb", "vclzlsbb", "rldicl" ],
        "type_signatures": {
            "var_heads": [ "r", "a", "b", "Example LE\nImplementation", "Example BE\nImplementation", "Restrictions" ],
            "list": [
                [ "unsigned int", "vector signed char", "vector signed char", "vcmpneb   t,a,b\n vctzlsbb  r,t", "vcmpneb   t,a,b\n vclzlsbb  r,t", "ISA 3.0 or later" ],
                [ "unsigned int", "vector unsigned char", "vector unsigned char", "vcmpneb   t,a,b\n vctzlsbb  r,t", "vcmpneb   t,a,b\n vclzlsbb  r,t", "ISA 3.0 or later" ],
                [ "unsigned int", "vector signed short", "vector signed short", "vcmpneh   t,a,b\n vctzlsbb  u,t\n rldicl    r,u,63,33", "vcmpneh   t,a,b\n vclzlsbb  u,t\n rldicl    r,u,63,33", "ISA 3.0 or later" ],
                [ "unsigned int", "vector unsigned short", "vector unsigned short", "vcmpneh   t,a,b\n vctzlsbb  u,t\n rldicl    r,u,63,33", "vcmpneh   t,a,b\n vclzlsbb  u,t\n rldicl    r,u,63,33", "ISA 3.0 or later" ],
                [ "unsigned int", "vector signed int", "vector signed int", "vcmpnew   t,a,b\n vctzlsbb  u,t\n rldicl    r,u,62,34", "vcmpnew   t,a,b\n vclzlsbb  u,t\n rldicl    r,u,62,34", "ISA 3.0 or later" ],
                [ "unsigned int", "vector unsigned int", "vector unsigned int", "vcmpnew   t,a,b\n vctzlsbb  u,t\n rldicl    r,u,62,34", "vcmpnew   t,a,b\n vclzlsbb  u,t\n rldicl    r,u,62,34", "ISA 3.0 or later" ]
            ]
        }
    },
    {
        "mnemonic": "vec_first_mismatch_or_eos_index",
        "name": "Vector Index of First Mismatch or End of String",
        "syntax": "r = vec_first_mismatch_or_eos_index (a, b)",
        "purpose": "Performs a comparison of inequality on each of the corresponding\n      elements of a and b. Returns the first position of\n      inequality, or the zero string terminator.",
        "result": "Returns the\n      element index of the position, in natural element order, of\n      either the first character mismatch or an end-of-string (EOS)\n      terminator. If no mismatch or terminator, returns the number of\n      characters as an element count in the vector argument.",
        "endianness": "The element numbering within a register is left-to-right for big-endian\n      targets, and right-to-left for little-endian targets.",
        "instructions": [ "xxspltib", "vcmpneb", "vcmpnezb", "vcmpneh", "vcmpnezh", "vcmpnew", "vcmpnezw", "xxland", "xxlorc", "vctzlsbb", "vclzlsbb", "rldicl" ],
        "type_signatures": {
            "var_heads": [ "r", "a", "b", "Example LE\nImplementation", "Example BE\nImplementation", "Restrictions" ],
            "list": [
                [ "unsigned int", "vector signed char", "vector signed char", "xxspltib  t,0\n vcmpneb   u,a,t\n vcmpneb   v,b,t\n vcmpnezb  w,a,b\n xxland    x,u,v\n xxlorc    y,w,x\n vctzlsbb  r,y", "xxspltib  t,0\n vcmpneb   u,a,t\n vcmpneb   v,b,t\n vcmpnezb  w,a,b\n xxland    x,u,v\n xxlorc    y,w,x\n vclzlsbb  r,y", "ISA 3.0 or later" ],
                [ "unsigned int", "vector unsigned char", "vector unsigned char", "xxspltib  t,0\n vcmpneb   u,a,t\n vcmpneb   v,b,t\n vcmpnezb  w,a,b\n xxland    x,u,v\n xxlorc    y,w,x\n vctzlsbb  r,y", "xxspltib  t,0\n vcmpneb   u,a,t\n vcmpneb   v,b,t\n vcmpnezb  w,a,b\n xxland    x,u,v\n xxlorc    y,w,x\n vclzlsbb  r,y", "ISA 3.0 or later" ],
                [ "unsigned int", "vector signed short", "vector signed short", "xxspltib  t,0\n vcmpneh   u,a,t\n vcmpneh   v,b,t\n vcmpnezh  w,a,b\n xxland    x,u,v\n xxlorc    y,w,x\n vctzlsbb  z,y\n rldicl    r,z,63,33", "xxspltib  t,0\n vcmpneh   u,a,t\n vcmpneh   v,b,t\n vcmpnezh  w,a,b\n xxland    x,u,v\n xxlorc    y,w,x\n vclzlsbb  z,y\n rldicl    r,z,63,33", "ISA 3.0 or later" ],
                [ "unsigned int", "vector unsigned short", "vector unsigned short", "xxspltib  t,0\n vcmpneh   u,a,t\n vcmpneh   v,b,t\n vcmpnezh  w,a,b\n xxland    x,u,v\n xxlorc    y,w,x\n vctzlsbb  z,y\n rldicl    r,z,63,33", "xxspltib  t,0\n vcmpneh   u,a,t\n vcmpneh   v,b,t\n vcmpnezh  w,a,b\n xxland    x,u,v\n xxlorc    y,w,x\n vclzlsbb  z,y\n rldicl    r,z,63,33", "ISA 3.0 or later" ],
                [ "unsigned int", "vector signed int", "vector signed int", "xxspltib  t,0\n vcmpnew   u,a,t\n vcmpnew   v,b,t\n vcmpnezw  w,a,b\n xxland    x,u,v\n xxlorc    y,w,x\n vctzlsbb  z,y\n rldicr    r,z,62,34", "xxspltib  t,0\n vcmpnew   u,a,t\n vcmpnew   v,b,t\n vcmpnezw  w,a,b\n xxland    x,u,v\n xxlorc    y,w,x\n vclzlsbb  z,y\n rldicr    r,z,62,34", "ISA 3.0 or later" ],
                [ "unsigned int", "vector unsigned int", "vector unsigned int", "xxspltib  t,0\n vcmpnew   u,a,t\n vcmpnew   v,b,t\n vcmpnezw  w,a,b\n xxland    x,u,v\n xxlorc    y,w,x\n vctzlsbb  z,y\n rldicr    r,z,62,34", "xxspltib  t,0\n vcmpnew   u,a,t\n vcmpnew   v,b,t\n vcmpnezw  w,a,b\n xxland    x,u,v\n xxlorc    y,w,x\n vclzlsbb  z,y\n rldicr    r,z,62,34", "ISA 3.0 or later" ]
            ]
        }
    },
    {
        "mnemonic": "vec_float",
        "name": "Vector Convert Integer to Floating-Point",
        "syntax": "r = vec_float (a)",
        "purpose": "Converts a vector of integers to a vector of single-precision\n      floating-point numbers.",
        "result": "Elements of\n      r are obtained by converting the\n      respective elements of a to\n      single-precision floating-point numbers.",
        "endianness": "None.",
        "instructions": [ "xvcvsxwsp", "xvcvuxwsp" ],
        "type_signatures": {
            "var_heads": [ "r", "a", "Example Implementation" ],
            "list": [
                [ "vector float", "vector signed int", "xvcvsxwsp r,a" ],
                [ "vector float", "vector unsigned int", "xvcvuxwsp r,a" ]
            ]
        }
    },
    {
        "mnemonic": "vec_float2",
        "name": "Vector Convert Two Vectors to Floating-Point",
        "syntax": "r = vec_float2 (a, b)",
        "purpose": "Converts two vectors of long long integers or double-precision\n      floating-point numbers to a vector of single-precision numbers.",
        "result": "Elements of\n      r are obtained by converting the\n      elements of a and\n      b to single-precision numbers.\n      Elements 0 and 1 of r are converted\n      from elements 0 and 1 of a,\n      respectively, and elements 2 and 3 of r\n      are converted from elements 0 and 1 of b, respectively.",
        "endianness": "The element numbering within a register is left-to-right for big-endian\n      targets, and right-to-left for little-endian targets.",
        "instructions": [ "xxpermdi", "xvcvsxdsp", "vmrgow", "vmrgew" ],
        "type_signatures": {
            "var_heads": [ "r", "a", "b", "Example LE Implementation", "Example BE Implementation" ],
            "list": [
                [ "vector float", "vector signed long long", "vector signed long long", "xxpermdi  t,b,a,0\n xxpermdi  u,b,a,3\n xvcvsxdsp v,t\n xvcvsxdsp w,u\n vmrgow    r,v,w", "xxpermdi  t,b,a,0\n xxpermdi  u,b,a,3\n xvcvsxdsp v,t\n xvcvsxdsp w,u\n vmrgew    r,v,w" ],
                [ "vector float", "vector unsigned long long", "vector unsigned long long", "xxpermdi  t,b,a,0\n xxpermdi  u,b,a,3\n xvcvsxdsp v,t\n xvcvsxdsp w,u\n vmrgow    r,v,w", "xxpermdi  t,b,a,0\n xxpermdi  u,b,a,3\n xvcvsxdsp v,t\n xvcvsxdsp w,u\n vmrgew    r,v,w" ],
                [ "vector float", "vector double", "vector double", "xxpermdi  t,b,a,0\n xxpermdi  u,b,a,3\n xvcvsxdsp v,t\n xvcvsxdsp w,u\n vmrgow    r,v,w", "xxpermdi  t,b,a,0\n xxpermdi  u,b,a,3\n xvcvsxdsp v,t\n xvcvsxdsp w,u\n vmrgew    r,v,w" ]
            ]
        }
    },
    {
        "mnemonic": "vec_floate",
        "name": "Vector Convert to Floating-Point in Even Elements",
        "syntax": "r = vec_floate (a)",
        "purpose": "Converts the elements of a source vector to single-precision\n      floating-point and stores the results in the even elements of\n      the target vector.",
        "result": "The even-numbered\n      elements of r are obtained by\n      converting the elements of a to\n      single-precision numbers, using the current floating-point rounding\n      mode.",
        "endianness": "The element numbering within a register is left-to-right for big-endian\n      targets, and right-to-left for little-endian targets.",
        "instructions": [ "xvcvsxdsp", "vsldoi", "xvcvuxdsp", "xvcvdpsp" ],
        "type_signatures": {
            "var_heads": [ "r", "a", "Example LE Implementation", "Example BE Implementation" ],
            "list": [
                [ "vector float", "vector signed long long", "xvcvsxdsp  r,a", "xvcvsxdsp  t,a\n vsldoi     r,t,t,4" ],
                [ "vector float", "vector unsigned long long", "xvcvuxdsp  r,a", "xvcvuxdsp  t,a\n vsldoi     r,t,t,4" ],
                [ "vector float", "vector double", "xvcvdpsp  r,a", "xvcvdpsp  t,a\n vsldoi    r,t,t,4" ]
            ]
        }
    },
    {
        "mnemonic": "vec_floato",
        "name": "Vector Convert to Floating-Point in Odd Elements",
        "syntax": "r = vec_floato (a)",
        "purpose": "Converts the elements of a source vector to single-precision\n      floating-point and stores the results in the odd elements of the\n      target vector.",
        "result": "The odd-numbered\n      elements of r are obtained by\n      converting the elements of a to\n      single-precision numbers, using the current floating-point rounding\n      mode.",
        "endianness": "The element numbering within a register is left-to-right for big-endian\n      targets, and right-to-left for little-endian targets.",
        "instructions": [ "xvcvsxdsp", "vsldoi", "xvcvuxdsp", "xvcvdpsp" ],
        "type_signatures": {
            "var_heads": [ "r", "a", "Example LE Implementation", "Example BE Implementation" ],
            "list": [
                [ "vector float", "vector signed long long", "xvcvsxdsp t,a\n  vsldoi    r,t,t,4", "xvcvsxdsp r,a" ],
                [ "vector float", "vector unsigned long long", "xvcvuxdsp t,a\n  vsldoi    r,t,t,4", "xvcvuxdsp r,a" ],
                [ "vector float", "vector double", "xvcvdpsp  t,a\n  vsldoi    r,t,t,4", "xvcvdpsp  r,a" ]
            ]
        }
    },
    {
        "mnemonic": "vec_floor",
        "name": "Vector Floor",
        "syntax": "r = vec_floor (a)",
        "purpose": "Returns a vector containing the largest representable floating-point\n      integral values less than or equal to the values of the corresponding\n      elements of the source vector.",
        "result": "Each element of\n      r contains the largest representable\n      floating-point integral value less than or equal to the value of the\n      corresponding element of a.",
        "endianness": "None.",
        "instructions": [ "xvrdpim", "xvrspim" ],
        "type_signatures": {
            "var_heads": [ "r", "a", "Example Implementation" ],
            "list": [
                [ "vector float", "vector float", "xvrspim  r,a" ],
                [ "vector double", "vector double", "xvrdpim  r,a" ]
            ]
        }
    },
    {
        "mnemonic": "vec_gb",
        "name": "Vector Gather Bits by Byte",
        "syntax": "r = vec_gb (a)",
        "purpose": "Performs a gather-bits operation on the input.",
        "result": "Within each\n      doubleword, let x(i) (0 ≤ i < 8) denote the byte elements, with\n      x(0) the most-significant byte. For each pair of i and j (0 ≤ i\n      < 8, 0 ≤ j < 8), the jth bit of the\n      ith byte element of\n      r is set to the value of the\n      ith bit of the jth byte\n      element of a.",
        "endianness": "None.",
        "instructions": [ "vgbbd" ],
        "type_signatures": {
            "var_heads": [ "r", "a", "Example Implementation" ],
            "list": [
                [ "vector unsigned char", "vector unsigned char", "vgbbd  r,a" ]
            ]
        }
    },
    {
        "mnemonic": "vec_insert",
        "name": "Vector Insert",
        "syntax": "r = vec_insert (a, b, c)",
        "purpose": "Returns a copy of vector b  with\n      element c replaced by the value of\n      a.",
        "result": "r contains a copy of vector\n      b with element c replaced by the value of a. This function uses modular arithmetic on\n      c to determine the element number.\n      For example, if c is out of range, the\n      compiler uses c modulo the number of\n      elements in the vector to determine the element position.",
        "endianness": "The element numbering within a register is left-to-right for big-endian\n      targets, and right-to-left for little-endian targets.",
        "instructions": [ "mtvsrwz", "vinsertb", "xxinsertw", "mtvsrd", "xxpermdi", "vinserth", "xscvdpspn", "xxextractuw" ],
        "type_signatures": {
            "var_heads": [ "r", "a", "b", "c", "Example ISA 3.0 LE Implementation", "Example ISA 3.0 BE Implementation" ],
            "list": [
                [ "vector signed char", "signed char", "vector signed char", "signed int", "mtvsrwz  t,b\n vinsertb r,t,15-c", "mtvsrwz  t,b\n vinsertb r,t,c" ],
                [ "vector unsigned char", "unsigned char", "vector unsigned char", "signed int", "mtvsrwz  t,b\n vinsertb r,t,15-c", "mtvsrwz  t,b\n vinsertb r,t,c" ],
                [ "vector signed short", "signed short", "vector signed short", "signed int", "mtvsrwz  t,b\n vinserth r,t,a,(7-c)*2", "mtvsrd   t,b\n vinserth r,t,a,c*2" ],
                [ "vector unsigned short", "unsigned short", "vector unsigned short", "signed int", "mtvsrwz  t,b\n vinserth r,t,a,(7-c)*2", "mtvsrd   t,b\n vinserth r,t,a,c*2" ],
                [ "vector signed int", "signed int", "vector signed int", "signed int", "mtvsrwz   t,b\n xxinsertw r,t,(3-c)*4", "mtvsrwz  t,b\n vinsertb r,t,c*4" ],
                [ "vector unsigned int", "unsigned int", "vector unsigned int", "signed int", "mtvsrwz   t,b\n xxinsertw r,t,(3-c)*4", "mtvsrwz  t,b\n vinsertb r,t,c*4" ],
                [ "vector signed long long", "signed long long", "vector signed long long", "signed int", "mtvsrd   t,b\n xxpermdi r,t,a,c", "mtvsrd   t,b\n xxpermdi r,t,a,1-c" ],
                [ "vector unsigned long long", "unsigned long long", "vector unsigned long long", "signed int", "mtvsrd   t,b\n xxpermdi r,t,a,c", "mtvsrd   t,b\n xxpermdi r,t,a,1-c" ],
                [ "vector float", "float", "vector float", "signed int", "xscvdpspn   t,a\n xxextractuw u,t,0\n xxinsertw   r/b,u,(3-c)*4", "xscvdpspn   t,a\n xxextractuw u,t,0\n xxinsertw   r/b,u,c*4" ],
                [ "vector double", "double", "vector double", "signed int", "xxpermdi r,b,a,1 [c=0]\n        [or]\n xxpermdi r,a,b,1 [c=1]", "xxpermdi r,a,b,1 [c=0]\n        [or]\n xxpermdi r,b,a,1 [c=1]" ]
            ]
        }
    },
    {
        "mnemonic": "vec_insert_exp",
        "name": "Vector Insert Exponent",
        "syntax": "r = vec_insert_exp (a, b)",
        "purpose": "Inserts exponents into a vector of floating-point numbers.",
        "result": "Each element of\n      r is generated by combining the exponent\n      specified by the corresponding element of b with the sign and significand of the\n      corresponding element of a.",
        "endianness": "None.",
        "instructions": [ "xviexpdp", "xviexpsp" ],
        "type_signatures": {
            "var_heads": [ "r", "a", "b", "Example Implementation", "Restrictions" ],
            "list": [
                [ "vector float", "vector unsigned int", "vector unsigned int", "xviexpsp  r,a,b", "ISA 3.0 or later" ],
                [ "vector float", "vector float", "vector unsigned int", "xviexpsp  r,a,b", "ISA 3.0 or later" ],
                [ "vector double", "vector unsigned long long", "vector unsigned long long", "xviexpdp  r,a,b", "ISA 3.0 or later" ],
                [ "vector double", "vector double", "vector unsigned long long", "xviexpdp  r,a,b", "ISA 3.0 or later" ]
            ]
        }
    },
    {
        "mnemonic": "vec_insert4b",
        "name": "Vector Insert Four Bytes",
        "syntax": "r = vec_insert4b (a, b, c)",
        "purpose": "Inserts a word into a vector at a byte position.",
        "result": "Let W be the first\n      doubleword element of a, truncated to\n      32 bits. The result vector r is formed\n      by inserting W into b at the byte\n      position (0–12) specified by c.",
        "endianness": "The element and byte numbering within a register is left-to-right for\n      big-endian targets, and right-to-left for little-endian targets.",
        "instructions": [ "xxpermdi", "xxinsertw" ],
        "type_signatures": {
            "var_heads": [ "r", "a", "b", "c", "Example LE Implementation", "Example BE Implementation", "Restrictions" ],
            "list": [
                [ "vector unsigned char", "vector signed int", "vector unsigned char", "const int (range [0,12])", "xxpermdi  t,a,a,1\n xxinsertw b,t,12-c", "xxinsertw b,t,c", "ISA 3.0 or later" ],
                [ "vector unsigned char", "vector unsigned int", "vector unsigned char", "const int (range [0,12])", "xxpermdi  t,a,a,1\n xxinsertw b,t,12-c", "xxinsertw b,t,c", "ISA 3.0 or later" ]
            ]
        }
    },
    {
        "mnemonic": "vec_ld",
        "name": "Vector Load Indexed",
        "syntax": "r = vec_ld (a, b)",
        "purpose": "Loads a 16-byte vector from the memory address specified by the\n      displacement and the pointer, ignoring the four low-order bits\n      of the calculated address.",
        "result": "The value of\n      r is obtained by adding a and b,\n      masking off the four low-order bits of the result, and\n      loading the 16-byte vector from the resultant memory address.",
        "endianness": "None.",
        "instructions": [ "lvx" ],
        "type_signatures": {
            "var_heads": [ "r", "a", "b", "Example ISA 3.0\nImplementation" ],
            "list": [
                [ "vector bool char", "signed long long", "const vector bool char *", "lvx  r,b,a" ],
                [ "vector signed char", "signed long long", "const signed char *", "lvx  r,b,a" ],
                [ "vector signed char", "signed long long", "const vector signed char *", "lvx  r,b,a" ],
                [ "vector unsigned char", "signed long long", "const unsigned char *", "lvx  r,b,a" ],
                [ "vector unsigned char", "signed long long", "const vector unsigned char *", "lvx  r,b,a" ],
                [ "vector bool short", "signed long long", "const vector bool short *", "lvx  r,b,a" ],
                [ "vector signed short", "signed long long", "const signed short *", "lvx  r,b,a" ],
                [ "vector signed short", "signed long long", "const vector signed short *", "lvx  r,b,a" ],
                [ "vector unsigned short", "signed long long", "const unsigned short *", "lvx  r,b,a" ],
                [ "vector unsigned short", "signed long long", "const vector unsigned short *", "lvx  r,b,a" ],
                [ "vector pixel", "signed long long", "const vector pixel *", "lvx  r,b,a" ],
                [ "vector bool int", "signed long long", "const vector bool int *", "lvx  r,b,a" ],
                [ "vector signed int", "signed long long", "const signed int *", "lvx  r,b,a" ],
                [ "vector signed int", "signed long long", "const vector signed int *", "lvx  r,b,a" ],
                [ "vector unsigned int", "signed long long", "const unsigned int *", "lvx  r,b,a" ],
                [ "vector unsigned int", "signed long long", "const vector unsigned int *", "lvx  r,b,a" ],
                [ "vector bool long long", "signed long long", "const vector bool long long *", "lvx  r,b,a" ],
                [ "vector signed long long", "signed long long", "const signed long long *", "lvx  r,b,a" ],
                [ "vector signed long long", "signed long long", "const vector signed long long *", "lvx  r,b,a" ],
                [ "vector unsigned long long", "signed long long", "const unsigned long long *", "lvx  r,b,a" ],
                [ "vector unsigned long long", "signed long long", "const vector unsigned long long *", "lvx  r,b,a" ],
                [ "vector signed __int128", "signed long long", "const signed __int128 *", "lvx  r,b,a" ],
                [ "vector signed __int128", "signed long long", "const vector signed __int128 *", "lvx  r,b,a" ],
                [ "vector unsigned __int128", "signed long long", "const unsigned __int128 *", "lvx  r,b,a" ],
                [ "vector unsigned __int128", "signed long long", "const vector unsigned __int128 *", "lvx  r,b,a" ],
                [ "vector float", "signed long long", "const float *", "lvx  r,b,a" ],
                [ "vector float", "signed long long", "const vector float *", "lvx  r,b,a" ],
                [ "vector double", "signed long long", "const double *", "lvx  r,b,a" ],
                [ "vector double", "signed long long", "const vector double *", "lvx  r,b,a" ]
            ]
        }
    },
    {
        "mnemonic": "vec_lde",
        "name": "Vector Load Element Indexed",
        "syntax": "r = vec_lde (a, b)",
        "purpose": "Loads a single element into the position in the vector register\n      corresponding to its address, leaving the remaining elements of\n      the register undefined.",
        "result": "The integer value a is added to the\n      pointer value b.  The resulting\n      address is rounded down to the nearest address that is a multiple of\n      es, where es is 1 for\n      char pointers, 2 for short pointers, and 4 for float or int pointers.\n      The element at this address is loaded into an element of r, leaving all other elements of r undefined.  The position of the loaded\n      element in r is determined by taking the\n      address modulo 16.",
        "endianness": "None.",
        "instructions": [ "lvebx", "lvewx", "lvehx" ],
        "type_signatures": {
            "var_heads": [ "r", "a", "b", "Example ISA 3.0\nImplementation" ],
            "list": [
                [ "vector signed char", "signed long long", "const signed char *", "lvebx  r,b,a" ],
                [ "vector unsigned char", "signed long long", "const unsigned char *", "lvebx  r,b,a" ],
                [ "vector signed short", "signed long long", "const signed short *", "lvehx  r,b,a" ],
                [ "vector unsigned short", "signed long long", "const unsigned short *", "lvehx  r,b,a" ],
                [ "vector signed int", "signed long long", "const signed int *", "lvewx  r,b,a" ],
                [ "vector unsigned int", "signed long long", "const unsigned int *", "lvewx  r,b,a" ],
                [ "vector float", "signed long long", "const float *", "lvewx  r,b,a" ]
            ]
        }
    },
    {
        "mnemonic": "vec_ldl",
        "name": "Vector Load Indexed Least Recently Used",
        "syntax": "r = vec_ldl (a, b)",
        "purpose": "Loads a 16-byte vector from the memory address specified by the\n      displacement and the pointer, ignoring the four low-order bits\n      of the calculated address, and marks the cache line loaded from\n      as least recently used.",
        "result": "The value of\n      r is obtained by adding a and b,\n      masking off the four low-order bits of the result, and\n      loading the 16-byte vector from the resultant memory address.",
        "endianness": "None.",
        "instructions": [ "lvxl" ],
        "type_signatures": {
            "var_heads": [ "r", "a", "b", "Example ISA 3.0\nImplementation" ],
            "list": [
                [ "vector bool char", "signed long long", "const vector bool char *", "lvxl  r,b,a" ],
                [ "vector signed char", "signed long long", "const signed char *", "lvxl  r,b,a" ],
                [ "vector signed char", "signed long long", "const vector signed char *", "lvxl  r,b,a" ],
                [ "vector unsigned char", "signed long long", "const unsigned char *", "lvxl  r,b,a" ],
                [ "vector unsigned char", "signed long long", "const vector unsigned char *", "lvxl  r,b,a" ],
                [ "vector bool short", "signed long long", "const vector bool short *", "lvxl  r,b,a" ],
                [ "vector signed short", "signed long long", "const signed short *", "lvxl  r,b,a" ],
                [ "vector signed short", "signed long long", "const vector signed short *", "lvxl  r,b,a" ],
                [ "vector unsigned short", "signed long long", "const unsigned short *", "lvxl  r,b,a" ],
                [ "vector unsigned short", "signed long long", "const vector unsigned short *", "lvxl  r,b,a" ],
                [ "vector pixel", "signed long long", "const vector pixel *", "lvxl  r,b,a" ],
                [ "vector bool int", "signed long long", "const vector bool int *", "lvxl  r,b,a" ],
                [ "vector signed int", "signed long long", "const signed int *", "lvxl  r,b,a" ],
                [ "vector signed int", "signed long long", "const vector signed int *", "lvxl  r,b,a" ],
                [ "vector unsigned int", "signed long long", "const unsigned int *", "lvxl  r,b,a" ],
                [ "vector unsigned int", "signed long long", "const vector unsigned int *", "lvxl  r,b,a" ],
                [ "vector bool long long", "signed long long", "const vector bool long long *", "lvxl  r,b,a" ],
                [ "vector signed long long", "signed long long", "const signed long long *", "lvxl  r,b,a" ],
                [ "vector signed long long", "signed long long", "const vector signed long long *", "lvxl  r,b,a" ],
                [ "vector unsigned long long", "signed long long", "const unsigned long long *", "lvxl  r,b,a" ],
                [ "vector unsigned long long", "signed long long", "const vector unsigned long long *", "lvxl  r,b,a" ],
                [ "vector float", "signed long long", "const float *", "lvxl  r,b,a" ],
                [ "vector float", "signed long long", "const vector float *", "lvxl  r,b,a" ],
                [ "vector double", "signed long long", "const double *", "lvxl  r,b,a" ],
                [ "vector double", "signed long long", "const vector double *", "lvxl  r,b,a" ]
            ]
        }
    },
    {
        "mnemonic": "vec_loge",
        "name": "Vector Base-2 Logarithm Estimate",
        "syntax": "r = vec_loge (a)",
        "purpose": "Returns a vector containing estimates of the base-2 logarithms of the\n      corresponding elements of the source vector.",
        "result": "Each element of\n      r contains an estimated value of the\n      base-2 logarithm of the corresponding element of a.",
        "endianness": "None.",
        "instructions": [ "vlogefp" ],
        "type_signatures": {
            "var_heads": [ "r", "a", "Example Implementation" ],
            "list": [
                [ "vector float", "vector float", "vlogefp  r,a" ]
            ]
        }
    },
    {
        "mnemonic": "vec_madd",
        "name": "Vector Multiply-Add",
        "syntax": "r = vec_madd (a, b, c)",
        "purpose": "Returns a vector containing the results of performing a fused\n      multiply-add operation for each corresponding set of elements of the\n      source vectors.",
        "result": "The value of each\n      element of r is the product of the\n      values of the corresponding elements of a and b, added\n      to the value of the corresponding element of c.",
        "endianness": "None.",
        "instructions": [ "vmladduhm", "xvmaddmdp", "xvmaddmsp" ],
        "type_signatures": {
            "var_heads": [ "r", "a", "b", "c", "Example Implementation" ],
            "list": [
                [ "vector signed short", "vector signed short", "vector signed short", "vector signed short", "vmladduhm r,a,b,c" ],
                [ "vector signed short", "vector signed short", "vector unsigned short", "vector unsigned short", "vmladduhm r,a,b,c" ],
                [ "vector signed short", "vector unsigned short", "vector signed short", "vector signed short", "vmladduhm r,a,b,c" ],
                [ "vector unsigned short", "vector unsigned short", "vector unsigned short", "vector unsigned short", "vmladduhm r,a,b,c" ],
                [ "vector float", "vector float", "vector float", "vector float", "xvmaddmsp r/a,b,c" ],
                [ "vector double", "vector double", "vector double", "vector double", "xvmaddmdp r/a,b,c" ]
            ]
        }
    },
    {
        "mnemonic": "vec_madds",
        "name": "Vector Multiply-Add Saturated",
        "syntax": "r = vec_madds (a, b, c)",
        "purpose": "Returns a vector containing the results of performing a saturated\n      multiply-high-and-add operation for each corresponding set of elements\n      of the source vectors.",
        "result": "The value of each\n      element of r is produced as follows:\n      The values of the corresponding elements of a and b are\n      multiplied. The value of the 17 most-significant bits of this product\n      is then added, using 16-bit-saturated addition, to the value of the\n      corresponding element of c.",
        "endianness": "None.",
        "instructions": [ "vmhaddshs" ],
        "type_signatures": {
            "var_heads": [ "r", "a", "b", "c", "Example Implementation" ],
            "list": [
                [ "vector signed short", "vector signed short", "vector signed short", "vector signed short", "vmhaddshs r,a,b,c" ]
            ]
        }
    },
    {
        "mnemonic": "vec_max",
        "name": "Vector Maximum",
        "syntax": "r = vec_max (a, b)",
        "purpose": "Returns a vector containing the maximum value from each set of\n      corresponding elements of the source vectors.",
        "result": "The value of each element of r is the\n      maximum of the values of the corresponding elements of a and b.",
        "endianness": "None.",
        "instructions": [ "vmaxsb", "vmaxub", "vmaxsw", "vmaxuw", "vmaxsd", "vmaxud", "vmaxsh", "vmaxuh", "xvmaxdp", "xvmaxsp" ],
        "type_signatures": {
            "var_heads": [ "r", "a", "b", "Example Implementation" ],
            "list": [
                [ "vector signed char", "vector signed char", "vector signed char", "vmaxsb  r,a,b" ],
                [ "vector unsigned char", "vector unsigned char", "vector unsigned char", "vmaxub  r,a,b" ],
                [ "vector signed short", "vector signed short", "vector signed short", "vmaxsh  r,a,b" ],
                [ "vector unsigned short", "vector unsigned short", "vector unsigned short", "vmaxuh  r,a,b" ],
                [ "vector signed int", "vector signed int", "vector signed int", "vmaxsw  r,a,b" ],
                [ "vector unsigned int", "vector unsigned int", "vector unsigned int", "vmaxuw  r,a,b" ],
                [ "vector signed long long", "vector signed long long", "vector signed long long", "vmaxsd  r,a,b" ],
                [ "vector unsigned long long", "vector unsigned long long", "vector unsigned long long", "vmaxud  r,a,b" ],
                [ "vector float", "vector float", "vector float", "xvmaxsp  r,a,b" ],
                [ "vector double", "vector double", "vector double", "xvmaxdp  r,a,b" ]
            ]
        }
    },
    {
        "mnemonic": "vec_mergee",
        "name": "Vector Merge Even",
        "syntax": "r = vec_mergee (a, b)",
        "purpose": "Merges the even-numbered values from two vectors.",
        "result": "The even-numbered\n      elements of a are stored into the\n      even-numbered elements of r. The\n      even-numbered elements of b are stored\n      into the odd-numbered elements of r.",
        "endianness": "The element numbering within a register is left-to-right for big-endian\n      targets, and right-to-left for little-endian targets.",
        "instructions": [ "vmrgow", "vmrgew", "xxpermdi" ],
        "type_signatures": {
            "var_heads": [ "r", "a", "b", "Example LE Implementation", "Example BE Implementation" ],
            "list": [
                [ "vector bool int", "vector bool int", "vector bool int", "vmrgow  r,b,a", "vmrgew  r,a,b" ],
                [ "vector signed int", "vector signed int", "vector signed int", "vmrgow  r,b,a", "vmrgew  r,a,b" ],
                [ "vector unsigned int", "vector unsigned int", "vector unsigned int", "vmrgow  r,b,a", "vmrgew  r,a,b" ],
                [ "vector bool long long", "vector bool long long", "vector bool long long", "xxpermdi  r,b,a,3", "xxpermdi  r,a,b,0" ],
                [ "vector signed long long", "vector signed long long", "vector signed long long", "xxpermdi  r,b,a,3", "xxpermdi  r,a,b,0" ],
                [ "vector unsigned long long", "vector unsigned long long", "vector unsigned long long", "xxpermdi  r,b,a,3", "xxpermdi  r,a,b,0" ],
                [ "vector float", "vector float", "vector float", "vmrgow  r,b,a", "vmrgew  r,a,b" ],
                [ "vector double", "vector double", "vector double", "xxpermdi  r,b,a,3", "xxpermdi  r,a,b,0" ]
            ]
        }
    },
    {
        "mnemonic": "vec_mergeh",
        "name": "Vector Merge High",
        "syntax": "r = vec_mergeh (a, b)",
        "purpose": "Merges the first halves (in element order) of two vectors.",
        "result": "The\n      nth element of r,\n      if n is an even number, is given the value of the\n      (n/2)th element of a.  The (n+1)th element\n      of r, if n is an\n      even number, is given the value of the (n/2)th\n      element of b.",
        "endianness": "The element numbering within a register is left-to-right for big-endian\n      targets, and right-to-left for little-endian targets.",
        "instructions": [ "vmrglb", "xxpermdi", "vmrghb", "vmrglw", "vmrghw", "vmrglh", "vmrghh" ],
        "type_signatures": {
            "var_heads": [ "r", "a", "b", "Example LE Implementation", "Example BE Implementation" ],
            "list": [
                [ "vector bool char", "vector bool char", "vector bool char", "vmrglb r,b,a", "vmrghb r,a,b" ],
                [ "vector signed char", "vector signed char", "vector signed char", "vmrglb r,b,a", "vmrghb r,a,b" ],
                [ "vector unsigned char", "vector unsigned char", "vector unsigned char", "vmrglb r,b,a", "vmrghb r,a,b" ],
                [ "vector bool short", "vector bool short", "vector bool short", "vmrglh r,b,a", "vmrghh r,a,b" ],
                [ "vector signed short", "vector signed short", "vector signed short", "vmrglh r,b,a", "vmrghh r,a,b" ],
                [ "vector unsigned short", "vector unsigned short", "vector unsigned short", "vmrglh r,b,a", "vmrghh r,a,b" ],
                [ "vector pixel", "vector pixel", "vector pixel", "vmrglh r,b,a", "vmrghh r,a,b" ],
                [ "vector bool int", "vector bool int", "vector bool int", "vmrglw r,b,a", "vmrghw r,a,b" ],
                [ "vector signed int", "vector signed int", "vector signed int", "vmrglw r,b,a", "vmrghw r,a,b" ],
                [ "vector unsigned int", "vector unsigned int", "vector unsigned int", "vmrglw r,b,a", "vmrghw r,a,b" ],
                [ "vector bool long long", "vector bool long long", "vector bool long long", "xxpermdi r,b,a,3", "xxpermdi r,a,b,0" ],
                [ "vector signed long long", "vector signed long long", "vector signed long long", "xxpermdi r,b,a,3", "xxpermdi r,a,b,0" ],
                [ "vector unsigned long long", "vector unsigned long long", "vector unsigned long long", "xxpermdi r,b,a,3", "xxpermdi r,a,b,0" ],
                [ "vector float", "vector float", "vector float", "vmrglw r,b,a", "vmrghw r,a,b" ],
                [ "vector double", "vector double", "vector double", "xxpermdi r,b,a,3", "xxpermdi r,a,b,0" ]
            ]
        }
    },
    {
        "mnemonic": "vec_mergel",
        "name": "Vector Merge Low",
        "syntax": "r = vec_mergel (a, b)",
        "purpose": "Merges the last halves (in element order) of two vectors.",
        "result": "Let\n      m be the number of elements in r.  The nth element of\n      r, if n is an even\n      number, is given the value of the m/2 +\n      (n/2)th element of a.  The (n+1)th element\n      of r, if n is an\n      even number, is given the value of the m/2 +\n      (n/2)th element of b.",
        "endianness": "The element numbering within a register is left-to-right for big-endian\n      targets, and right-to-left for little-endian targets.",
        "instructions": [ "vmrghb", "vmrglb", "vmrghw", "vmrglw", "xxpermdi", "vmrghh", "vmrglh" ],
        "type_signatures": {
            "var_heads": [ "r", "a", "b", "Example LE Implementation", "Example BE Implementation" ],
            "list": [
                [ "vector bool char", "vector bool char", "vector bool char", "vmrghb r,b,a", "vmrglb r,a,b" ],
                [ "vector signed char", "vector signed char", "vector signed char", "vmrghb r,b,a", "vmrglb r,a,b" ],
                [ "vector unsigned char", "vector unsigned char", "vector unsigned char", "vmrghb r,b,a", "vmrglb r,a,b" ],
                [ "vector bool short", "vector bool short", "vector bool short", "vmrghh r,b,a", "vmrglh r,a,b" ],
                [ "vector signed short", "vector signed short", "vector signed short", "vmrghh r,b,a", "vmrglh r,a,b" ],
                [ "vector unsigned short", "vector unsigned short", "vector unsigned short", "vmrghh r,b,a", "vmrglh r,a,b" ],
                [ "vector pixel", "vector pixel", "vector pixel", "vmrghh r,b,a", "vmrglh r,a,b" ],
                [ "vector bool int", "vector bool int", "vector bool int", "vmrghw r,b,a", "vmrglw r,a,b" ],
                [ "vector signed int", "vector signed int", "vector signed int", "vmrghw r,b,a", "vmrglw r,a,b" ],
                [ "vector unsigned int", "vector unsigned int", "vector unsigned int", "vmrghw r,b,a", "vmrglw r,a,b" ],
                [ "vector bool long long", "vector bool long long", "vector bool long long", "xxpermdi r,b,a,0", "xxpermdi r,a,b,3" ],
                [ "vector signed long long", "vector signed long long", "vector signed long long", "xxpermdi r,b,a,0", "xxpermdi r,a,b,3" ],
                [ "vector unsigned long long", "vector unsigned long long", "vector unsigned long long", "xxpermdi r,b,a,0", "xxpermdi r,a,b,3" ],
                [ "vector float", "vector float", "vector float", "vmrghw r,b,a", "vmrglw r,a,b" ],
                [ "vector double", "vector double", "vector double", "xxpermdi r,b,a,0", "xxpermdi r,a,b,3" ]
            ]
        }
    },
    {
        "mnemonic": "vec_mergeo",
        "name": "Vector Merge Odd",
        "syntax": "r = vec_mergeo (a, b)",
        "purpose": "Merges the odd-numbered values from two vectors.",
        "result": "The odd-numbered\n      elements of a are stored into the\n      even-numbered elements of r. The\n      odd-numbered elements of b are stored\n      into the odd-numbered elements of r.",
        "endianness": "The element numbering within a register is left-to-right for big-endian\n      targets, and right-to-left for little-endian targets.",
        "instructions": [ "vmrgew", "vmrgow", "xxpermdi" ],
        "type_signatures": {
            "var_heads": [ "r", "a", "b", "Example LE Implementation", "Example BE Implementation" ],
            "list": [
                [ "vector bool int", "vector bool int", "vector bool int", "vmrgew r,b,a", "vmrgow r,a,b" ],
                [ "vector signed int", "vector signed int", "vector signed int", "vmrgew r,b,a", "vmrgow r,a,b" ],
                [ "vector unsigned int", "vector unsigned int", "vector unsigned int", "vmrgew r,b,a", "vmrgow r,a,b" ],
                [ "vector bool long long", "vector bool long long", "vector bool long long", "xxpermdi r,b,a,0", "xxpermdi r,a,b,3" ],
                [ "vector signed long long", "vector signed long long", "vector signed long long", "xxpermdi r,b,a,0", "xxpermdi r,a,b,3" ],
                [ "vector unsigned long long", "vector unsigned long long", "vector unsigned long long", "xxpermdi r,b,a,0", "xxpermdi r,a,b,3" ],
                [ "vector float", "vector float", "vector float", "vmrgew r,b,a", "vmrgow r,a,b" ],
                [ "vector double", "vector double", "vector double", "xxpermdi r,b,a,0", "xxpermdi r,a,b,3" ]
            ]
        }
    },
    {
        "mnemonic": "vec_mfvscr",
        "name": "Vector Move From Vector Status and Control Register",
        "syntax": "r = vec_mfvscr ()",
        "purpose": "Copies the contents of the Vector Status and Control Register\n      (VSCR) into the result vector.",
        "result": "The high-order 16\n      bits of the VSCR are copied into the seventh element of r, using big-endian (left-to-right) order. The\n      low-order 16 bits of the VSCR are copied into the eighth element of\n      r, using big-endian order.  All other\n      elements of r are set to zero.",
        "endianness": "The contents of the VSCR are placed in the low-order 32 bits of the\n      result vector, regardless of endianness.",
        "instructions": [ "mfvscr" ],
        "type_signatures": {
            "var_heads": [ "r", "Example\nImplementation" ],
            "list": [
                [ "vector unsigned short", "mfvscr  a" ]
            ]
        }
    },
    {
        "mnemonic": "vec_min",
        "name": "Vector Minimum",
        "syntax": "r = vec_min (a, b)",
        "purpose": "Returns a vector containing the minimum value from each set of\n      corresponding elements of the source vectors.",
        "result": "The value of each\n      element of r is the minimum of the\n      values of the corresponding elements of a and b.",
        "endianness": "None.",
        "instructions": [ "vminsb", "vminub", "vminsw", "vminuw", "vminsd", "vminud", "vminsh", "vminuh", "xvmindp", "xvminsp" ],
        "type_signatures": {
            "var_heads": [ "r", "a", "b", "Example Implementation" ],
            "list": [
                [ "vector signed char", "vector signed char", "vector signed char", "vminsb  r,a,b" ],
                [ "vector unsigned char", "vector unsigned char", "vector unsigned char", "vminub  r,a,b" ],
                [ "vector signed short", "vector signed short", "vector signed short", "vminsh  r,a,b" ],
                [ "vector unsigned short", "vector unsigned short", "vector unsigned short", "vminuh  r,a,b" ],
                [ "vector signed int", "vector signed int", "vector signed int", "vminsw  r,a,b" ],
                [ "vector unsigned int", "vector unsigned int", "vector unsigned int", "vminuw  r,a,b" ],
                [ "vector signed long long", "vector signed long long", "vector signed long long", "vminsd  r,a,b" ],
                [ "vector unsigned long long", "vector unsigned long long", "vector unsigned long long", "vminud  r,a,b" ],
                [ "vector float", "vector float", "vector float", "xvminsp  r,a,b" ],
                [ "vector double", "vector double", "vector double", "xvmindp  r,a,b" ]
            ]
        }
    },
    {
        "mnemonic": "vec_mradds",
        "name": "Vector Multiply-High Round and Add Saturated",
        "syntax": "r = vec_mradds (a, b, c)",
        "purpose": "Returns a vector containing the results of performing a saturated\n      multiply-high-round-and-add operation for each corresponding set of\n      elements of the source vectors.",
        "result": "The value of each\n      element of r is produced as follows.\n      The values of the corresponding elements of a and b are\n      multiplied and rounded such that the 15 least-significant bits are 0.\n      The value of the 17 most-significant bits of this rounded product is\n      then added, using 16-bit-saturated addition, to the value of the\n      corresponding element of c.",
        "endianness": "None.",
        "instructions": [ "vmhraddshs" ],
        "type_signatures": {
            "var_heads": [ "r", "a", "b", "c", "Example Implementation" ],
            "list": [
                [ "vector signed short", "vector signed short", "vector signed short", "vector signed short", "vmhraddshs r,a,b,c" ]
            ]
        }
    },
    {
        "mnemonic": "vec_msub",
        "name": "Vector Multiply-Subtract",
        "syntax": "r = vec_msub (a, b, c)",
        "purpose": "Returns a vector containing the results of performing a multiply-subtract\n      operation using the source vectors.",
        "result": "Each element of\n      r is produced by multiplying the\n      corresponding element of a by the\n      corresponding element of b and then\n      subtracting the corresponding element of c.",
        "endianness": "None.",
        "instructions": [ "xvmsubmdp", "xvmsubmsp" ],
        "type_signatures": {
            "var_heads": [ "r", "a", "b", "c", "Example Implementation" ],
            "list": [
                [ "vector float", "vector float", "vector float", "vector float", "xvmsubmsp r/a,b,c" ],
                [ "vector double", "vector double", "vector double", "vector double", "xvmsubmdp r/a,b,c" ]
            ]
        }
    },
    {
        "mnemonic": "vec_msum",
        "name": "Vector Multiply-Sum",
        "syntax": "r = vec_msum (a, b, c)",
        "purpose": "Returns a vector containing the results of performing a multiply-sum\n      operation using the source vectors.",
        "result": "",
        "endianness": "None.",
        "instructions": [ "vmsummbm", "vmsumshm", "vmsumubm", "vmsumuhm" ],
        "type_signatures": {
            "var_heads": [ "r", "a", "b", "c", "Example Implementation" ],
            "list": [
                [ "vector signed int", "vector signed char", "vector unsigned char", "vector signed int", "vmsummbm r,a,b,c" ],
                [ "vector signed int", "vector signed short", "vector signed short", "vector signed int", "vmsumshm r,a,b,c" ],
                [ "vector unsigned int", "vector unsigned char", "vector unsigned char", "vector unsigned int", "vmsumubm r,a,b,c" ],
                [ "vector unsigned int", "vector unsigned short", "vector unsigned short", "vector unsigned int", "vmsumuhm r,a,b,c" ]
            ]
        }
    },
    {
        "mnemonic": "vec_msums",
        "name": "Vector Multiply-Sum Saturated",
        "syntax": "r = vec_msums (a, b, c)",
        "purpose": "Returns a vector containing the results of performing a saturated\n      multiply-sum operation using the source vectors.",
        "result": "Assume that the\n      elements of each vector are numbered beginning with 0. The value of each\n      element n of r\n      is obtained as follows. For p =\n      2n to 2n+1, multiply element\n      p of a by element\n      p of b. Add the\n      sum of these products to element n of\n      c. All additions are performed using\n      32-bit saturated arithmetic.",
        "endianness": "None.",
        "instructions": [ "vmsumshs", "vmsumuhs" ],
        "type_signatures": {
            "var_heads": [ "r", "a", "b", "c", "Example Implementation" ],
            "list": [
                [ "vector signed int", "vector signed short", "vector signed short", "vector signed int", "vmsumshs r,a,b,c" ],
                [ "vector unsigned int", "vector unsigned short", "vector unsigned short", "vector unsigned int", "vmsumuhs r,a,b,c" ]
            ]
        }
    },
    {
        "mnemonic": "vec_mtvscr",
        "name": "Vector Move to Vector Status and Control Register",
        "syntax": "vec_mtvscr (a)",
        "purpose": "Copies a value into the Vector Status and Control Register\n      (VSCR).  The low-order 32 bits of a are copied into the VSCR.",
        "result": "None.",
        "endianness": "None.",
        "instructions": [ "mtvscr" ],
        "type_signatures": {
            "var_heads": [ "a", "Example\nImplementation" ],
            "list": [
                [ "vector bool char", "mtvscr  a" ],
                [ "vector signed char", "mtvscr  a" ],
                [ "vector unsigned char", "mtvscr  a" ],
                [ "vector bool short", "mtvscr  a" ],
                [ "vector signed short", "mtvscr  a" ],
                [ "vector unsigned short", "mtvscr  a" ],
                [ "vector pixel", "mtvscr  a" ],
                [ "vector bool int", "mtvscr  a" ],
                [ "vector signed int", "mtvscr  a" ],
                [ "vector unsigned int", "mtvscr  a" ]
            ]
        }
    },
    {
        "mnemonic": "vec_mul",
        "name": "Vector Multiply",
        "syntax": "r = vec_mul (a, b)",
        "purpose": "Compute the products of corresponding elements of two vectors.",
        "result": "Each element of\n      r receives the product of\n      the corresponding elements of a and\n      b.",
        "endianness": "None.",
        "instructions": [ "vmulesb", "vmulosb", "lxvw4x", "vperm", "vmuluwm", "xxspltib", "vmladduhm", "xvmuldp", "xvmulsp" ],
        "type_signatures": {
            "var_heads": [ "r", "a", "b", "Example Implementation" ],
            "list": [
                [ "vector signed char", "vector signed char", "vector signed char", "vmulesb  t,a,b\n  vmulosb  u,a,b\n  lxvw4x   v,0,pcv\n  vperm    r,t,u,v" ],
                [ "vector unsigned char", "vector unsigned char", "vector unsigned char", "vmulesb  t,a,b\n  vmulosb  u,a,b\n  lxvw4x   v,0,pcv\n  vperm    r,t,u,v" ],
                [ "vector signed short", "vector signed short", "vector signed short", "xxspltib  t,0\n  vmladduhm r,a,b,t" ],
                [ "vector unsigned short", "vector unsigned short", "vector unsigned short", "xxspltib  t,0\n  vmladduhm r,a,b,t" ],
                [ "vector signed int", "vector signed int", "vector signed int", "vmuluwm r,a,b" ],
                [ "vector unsigned int", "vector unsigned int", "vector unsigned int", "vmuluwm r,a,b" ],
                [ "vector signed long long", "vector signed long long", "vector signed long long", "[scalarized]" ],
                [ "vector unsigned long long", "vector unsigned long long", "vector unsigned long long", "[scalarized]" ],
                [ "vector float", "vector float", "vector float", "xvmulsp r,a,b" ],
                [ "vector double", "vector double", "vector double", "xvmuldp r,a,b" ]
            ]
        }
    },
    {
        "mnemonic": "vec_mule",
        "name": "Vector Multiply Even",
        "syntax": "r = vec_mule (a, b)",
        "purpose": "Multiplies the even-numbered elements of the source vectors to\n      produce the target vector.",
        "result": "Each element\n      n of r is the\n      product of element 2n of a and element 2n of\n      b.",
        "endianness": "The element numbering within a register is left-to-right for big-endian\n      targets, and right-to-left for little-endian targets.",
        "instructions": [ "vmulosh", "vmulesh", "vmulouh", "vmuleuh", "vmulosw", "vmulesw", "vmulouw", "vmuleuw", "vmulosb", "vmulesb", "vmuloub", "vmuleub" ],
        "type_signatures": {
            "var_heads": [ "r", "a", "b", "Example LE Implementation", "Example BE Implementation" ],
            "list": [
                [ "vector signed short", "vector signed char", "vector signed char", "vmulosb r,a,b", "vmulesb r,a,b" ],
                [ "vector unsigned short", "vector unsigned char", "vector unsigned char", "vmuloub r,a,b", "vmuleub r,a,b" ],
                [ "vector signed int", "vector signed short", "vector signed short", "vmulosh r,a,b", "vmulesh r,a,b" ],
                [ "vector unsigned int", "vector unsigned short", "vector unsigned short", "vmulouh r,a,b", "vmuleuh r,a,b" ],
                [ "vector signed long long", "vector signed int", "vector signed int", "vmulosw r,a,b", "vmulesw r,a,b" ],
                [ "vector unsigned long long", "vector unsigned int", "vector unsigned int", "vmulouw r,a,b", "vmuleuw r,a,b" ]
            ]
        }
    },
    {
        "mnemonic": "vec_mulo",
        "name": "Vector Multiply Odd",
        "syntax": "r = vec_mulo (a, b)",
        "purpose": "Multiplies the odd-numbered elements of the source vectors to\n      produce the target vector.",
        "result": "Each element\n      n of r is the\n      product of element 2n+1 of a and element 2n+1 of\n      b.",
        "endianness": "The element numbering within a register is left-to-right for big-endian\n      targets, and right-to-left for little-endian targets.",
        "instructions": [ "vmulesh", "vmulosh", "vmuleuh", "vmulouh", "vmulesw", "vmulosw", "vmuleuw", "vmulouw", "vmulesb", "vmulosb", "vmuleub", "vmuloub" ],
        "type_signatures": {
            "var_heads": [ "r", "a", "b", "Example LE Implementation", "Example BE Implementation" ],
            "list": [
                [ "vector signed short", "vector signed char", "vector signed char", "vmulesb r,a,b", "vmulosb r,a,b" ],
                [ "vector unsigned short", "vector unsigned char", "vector unsigned char", "vmuleub r,a,b", "vmuloub r,a,b" ],
                [ "vector signed int", "vector signed short", "vector signed short", "vmulesh r,a,b", "vmulosh r,a,b" ],
                [ "vector unsigned int", "vector unsigned short", "vector unsigned short", "vmuleuh r,a,b", "vmulouh r,a,b" ],
                [ "vector signed long long", "vector signed int", "vector signed int", "vmulesw r,a,b", "vmulosw r,a,b" ],
                [ "vector unsigned long long", "vector unsigned int", "vector unsigned int", "vmuleuw r,a,b", "vmulouw r,a,b" ]
            ]
        }
    },
    {
        "mnemonic": "vec_nabs",
        "name": "Vector Negated Absolute Value",
        "syntax": "r = vec_nabs (a)",
        "purpose": "Returns a vector containing the negated absolute values of the contents\n      of the source vector.",
        "result": "The value of each\n      element of r is the negated absolute\n      value of the corresponding element of a. For integer vectors, the arithmetic is\n      modular.",
        "endianness": "None.",
        "instructions": [ "vspltisw", "vsububm", "vminsb", "vsubuwm", "vminsw", "vsubudm", "vminsd", "vsubuhm", "vminsh", "xvnabsdp", "xvnabssp" ],
        "type_signatures": {
            "var_heads": [ "r", "a", "Example Implementation" ],
            "list": [
                [ "vector signed char", "vector signed char", "vspltisw t,0\n  vsububm  u,t,a\n  vminsb   r,u,a" ],
                [ "vector signed short", "vector signed short", "vspltisw t,0\n  vsubuhm  u,t,a\n  vminsh   r,u,a" ],
                [ "vector signed int", "vector signed int", "vspltisw t,0\n  vsubuwm  u,t,a\n  vminsw   r,u,a" ],
                [ "vector signed long long", "vector signed long long", "vspltisw t,0\n  vsubudm  u,t,a\n  vminsd   r,u,a" ],
                [ "vector float", "vector float", "xvnabssp  r,a" ],
                [ "vector double", "vector double", "xvnabsdp  r,a" ]
            ]
        }
    },
    {
        "mnemonic": "vec_nand",
        "name": "Vector NAND",
        "syntax": "r = vec_nand (a, b)",
        "purpose": "Performs a bitwise NAND of two vectors.",
        "result": "r is the bitwise\n      NAND of a and b.",
        "endianness": "None.",
        "instructions": [ "xxlnand" ],
        "type_signatures": {
            "var_heads": [ "r", "a", "b", "Example Implementation" ],
            "list": [
                [ "vector bool char", "vector bool char", "vector bool char", "xxlnand  r,a,b" ],
                [ "vector signed char", "vector signed char", "vector signed char", "xxlnand  r,a,b" ],
                [ "vector unsigned char", "vector unsigned char", "vector unsigned char", "xxlnand  r,a,b" ],
                [ "vector bool short", "vector bool short", "vector bool short", "xxlnand  r,a,b" ],
                [ "vector signed short", "vector signed short", "vector signed short", "xxlnand  r,a,b" ],
                [ "vector unsigned short", "vector unsigned short", "vector unsigned short", "xxlnand  r,a,b" ],
                [ "vector bool int", "vector bool int", "vector bool int", "xxlnand  r,a,b" ],
                [ "vector signed int", "vector signed int", "vector signed int", "xxlnand  r,a,b" ],
                [ "vector unsigned int", "vector unsigned int", "vector unsigned int", "xxlnand  r,a,b" ],
                [ "vector bool long long", "vector bool long long", "vector bool long long", "xxlnand  r,a,b" ],
                [ "vector signed long long", "vector signed long long", "vector signed long long", "xxlnand  r,a,b" ],
                [ "vector unsigned long long", "vector unsigned long long", "vector unsigned long long", "xxlnand  r,a,b" ],
                [ "vector float", "vector float", "vector float", "xxlnand  r,a,b" ],
                [ "vector double", "vector double", "vector double", "xxlnand  r,a,b" ]
            ]
        }
    },
    {
        "mnemonic": "vec_ncipher_be",
        "name": "Vector AES Inverse Cipher Big-Endian",
        "syntax": "r = vec_ncipher_be (a, b)",
        "purpose": "Performs one round of the AES inverse cipher operation on an\n      intermediate state array a by using a\n      given round key b.",
        "result": "r contains the\n      resulting intermediate state, after one round of the AES inverse cipher\n      operation on intermediate state array a,\n      using the round key specified by b.",
        "endianness": "",
        "instructions": [ "vncipher" ],
        "type_signatures": {
            "var_heads": [ "r", "a", "b", "Example Implementation" ],
            "list": [
                [ "vector unsigned char", "vector unsigned char", "vector unsigned char", "vncipher  r,a,b" ]
            ]
        }
    },
    {
        "mnemonic": "vec_ncipherlast_be",
        "name": "Vector AES Inverse Cipher Last Big-Endian",
        "syntax": "r = vec_ncipherlast_be (a, b)",
        "purpose": "Performs the final round of the AES inverse cipher operation on an\n      intermediate state array a using the\n      specified round key b.",
        "result": "r contains the\n      resulting final state, after the final round of the AES inverse cipher\n      operation on intermediate state array a,\n      using the round key specified by b.",
        "endianness": "",
        "instructions": [ "vncipherlast" ],
        "type_signatures": {
            "var_heads": [ "r", "a", "b", "Example Implementation" ],
            "list": [
                [ "vector unsigned char", "vector unsigned char", "vector unsigned char", "vncipherlast  r,a,b" ]
            ]
        }
    },
    {
        "mnemonic": "vec_nearbyint",
        "name": "Vector Nearby Integer",
        "syntax": "r = vec_nearbyint (a)",
        "purpose": "Returns a vector containing the floating-point integral values nearest to\n      the values of the corresponding elements of the source vector.",
        "result": "Each\n      element of r contains the\n      nearest representable floating-point integral value to the value\n      of the corresponding element of a. When an input element value is exactly\n      between two integer values, the input value with the larger\n      absolute value is selected.  The current floating-point rounding\n      mode is ignored.",
        "endianness": "None.",
        "instructions": [ "xvrdpi", "xvrspi" ],
        "type_signatures": {
            "var_heads": [ "r", "a", "Example Implementation" ],
            "list": [
                [ "vector float", "vector float", "xvrspi  r,a" ],
                [ "vector double", "vector double", "xvrdpi  r,a" ]
            ]
        }
    },
    {
        "mnemonic": "vec_neg",
        "name": "Vector Negate",
        "syntax": "r = vec_neg (a)",
        "purpose": "Returns a vector containing the negated values of the contents of the\n      source vector.",
        "result": "The value of each\n      element of r is the negated value of\n      the corresponding element of a. For\n      integer vectors, the arithmetic is modular.",
        "endianness": "None.",
        "instructions": [ "vspltisw", "vsububm", "vsubuwm", "vsubudm", "vsubuhm", "xvnegdp", "xvnegsp" ],
        "type_signatures": {
            "var_heads": [ "r", "a", "Example Implementation" ],
            "list": [
                [ "vector signed char", "vector signed char", "vspltisw  t,0\n  vsububm   r,t,a" ],
                [ "vector signed short", "vector signed short", "vspltisw  t,0\n  vsubuhm   r,t,a" ],
                [ "vector signed int", "vector signed int", "vspltisw  t,0\n  vsubuwm   r,t,a" ],
                [ "vector signed long long", "vector signed long long", "vspltisw  t,0\n  vsubudm   r,t,a" ],
                [ "vector float", "vector float", "xvnegsp  r,a" ],
                [ "vector double", "vector double", "xvnegdp  r,a" ]
            ]
        }
    },
    {
        "mnemonic": "vec_nmadd",
        "name": "Vector Negated Multiply-Add",
        "syntax": "r = vec_nmadd (a, b, c)",
        "purpose": "Returns a vector containing the results of performing a negated\n      multiply-add operation on the source vectors.",
        "result": "The value of each\n      element of r is the product of the\n      corresponding elements of a and\n      b, added to the corresponding elements\n      of c, then multiplied by\n      –1.0.",
        "endianness": "None.",
        "instructions": [ "xvnmaddadp", "xvnmaddasp" ],
        "type_signatures": {
            "var_heads": [ "r", "a", "b", "c", "Example Implementation" ],
            "list": [
                [ "vector float", "vector float", "vector float", "vector float", "xvnmaddasp  r/c,a,b" ],
                [ "vector double", "vector double", "vector double", "vector double", "xvnmaddadp  r/c,a,b" ]
            ]
        }
    },
    {
        "mnemonic": "vec_nmsub",
        "name": "Vector Negated Multiply-Subtract",
        "syntax": "r = vec_nmsub (a, b, c)",
        "purpose": "Returns a vector containing the results of performing a negated\n      multiply-subtract operation on the source vectors.",
        "result": "The value of each\n      element of r is the value of the\n      corresponding element of c subtracted\n      from the product of the corresponding elements of a and b, and\n      then multiplied by –1.0.",
        "endianness": "None.",
        "instructions": [ "xvnmsubmdp", "xvnmsubmsp" ],
        "type_signatures": {
            "var_heads": [ "r", "a", "b", "c", "Example Implementation" ],
            "list": [
                [ "vector float", "vector float", "vector float", "vector float", "xvnmsubmsp  r/a,b,c" ],
                [ "vector double", "vector double", "vector double", "vector double", "xvnmsubmdp  r/a,b,c" ]
            ]
        }
    },
    {
        "mnemonic": "vec_nor",
        "name": "Vector NOR",
        "syntax": "r = vec_nor (a, b)",
        "purpose": "Performs a bitwise NOR of two vectors.",
        "result": "r is the bitwise NOR\n      of a and b.",
        "endianness": "None.",
        "instructions": [ "xxlnor" ],
        "type_signatures": {
            "var_heads": [ "r", "a", "b", "Example Implementation" ],
            "list": [
                [ "vector bool char", "vector bool char", "vector bool char", "xxlnor  r,a,b" ],
                [ "vector signed char", "vector signed char", "vector signed char", "xxlnor  r,a,b" ],
                [ "vector unsigned char", "vector unsigned char", "vector unsigned char", "xxlnor  r,a,b" ],
                [ "vector bool short", "vector bool short", "vector bool short", "xxlnor  r,a,b" ],
                [ "vector signed short", "vector signed short", "vector signed short", "xxlnor  r,a,b" ],
                [ "vector unsigned short", "vector unsigned short", "vector unsigned short", "xxlnor  r,a,b" ],
                [ "vector bool int", "vector bool int", "vector bool int", "xxlnor  r,a,b" ],
                [ "vector signed int", "vector signed int", "vector signed int", "xxlnor  r,a,b" ],
                [ "vector unsigned int", "vector unsigned int", "vector unsigned int", "xxlnor  r,a,b" ],
                [ "vector bool long long", "vector bool long long", "vector bool long long", "xxlnor  r,a,b" ],
                [ "vector signed long long", "vector signed long long", "vector signed long long", "xxlnor  r,a,b" ],
                [ "vector unsigned long long", "vector unsigned long long", "vector unsigned long long", "xxlnor  r,a,b" ],
                [ "vector float", "vector float", "vector float", "xxlnor  r,a,b" ],
                [ "vector double", "vector double", "vector double", "xxlnor  r,a,b" ]
            ]
        }
    },
    {
        "mnemonic": "vec_or",
        "name": "Vector OR",
        "syntax": "r = vec_or (a, b)",
        "purpose": "Performs a bitwise OR of two vectors.",
        "result": "r is the bitwise OR\n      of a and b.",
        "endianness": "None.",
        "instructions": [ "xxlor" ],
        "type_signatures": {
            "var_heads": [ "r", "a", "b", "Example Implementation" ],
            "list": [
                [ "vector bool char", "vector bool char", "vector bool char", "xxlor  r,a,b" ],
                [ "vector signed char", "vector signed char", "vector signed char", "xxlor  r,a,b" ],
                [ "vector unsigned char", "vector unsigned char", "vector unsigned char", "xxlor  r,a,b" ],
                [ "vector bool short", "vector bool short", "vector bool short", "xxlor  r,a,b" ],
                [ "vector signed short", "vector signed short", "vector signed short", "xxlor  r,a,b" ],
                [ "vector unsigned short", "vector unsigned short", "vector unsigned short", "xxlor  r,a,b" ],
                [ "vector bool int", "vector bool int", "vector bool int", "xxlor  r,a,b" ],
                [ "vector signed int", "vector signed int", "vector signed int", "xxlor  r,a,b" ],
                [ "vector unsigned int", "vector unsigned int", "vector unsigned int", "xxlor  r,a,b" ],
                [ "vector bool long long", "vector bool long long", "vector bool long long", "xxlor  r,a,b" ],
                [ "vector signed long long", "vector signed long long", "vector signed long long", "xxlor  r,a,b" ],
                [ "vector unsigned long long", "vector unsigned long long", "vector unsigned long long", "xxlor  r,a,b" ],
                [ "vector float", "vector float", "vector float", "xxlor  r,a,b" ],
                [ "vector double", "vector double", "vector double", "xxlor  r,a,b" ]
            ]
        }
    },
    {
        "mnemonic": "vec_orc",
        "name": "Vector OR with Complement",
        "syntax": "r = vec_orc (a, b)",
        "purpose": "Performs a bitwise OR of the first vector with the bitwise-complemented\n      second vector.",
        "result": "r is the bitwise OR\n      of a and the bitwise complement of\n      b.",
        "endianness": "None.",
        "instructions": [ "xxlorc" ],
        "type_signatures": {
            "var_heads": [ "r", "a", "b", "Example Implementation" ],
            "list": [
                [ "vector bool char", "vector bool char", "vector bool char", "xxlorc  r,a,b" ],
                [ "vector signed char", "vector signed char", "vector signed char", "xxlorc  r,a,b" ],
                [ "vector unsigned char", "vector unsigned char", "vector unsigned char", "xxlorc  r,a,b" ],
                [ "vector bool short", "vector bool short", "vector bool short", "xxlorc  r,a,b" ],
                [ "vector signed short", "vector signed short", "vector signed short", "xxlorc  r,a,b" ],
                [ "vector unsigned short", "vector unsigned short", "vector unsigned short", "xxlorc  r,a,b" ],
                [ "vector bool int", "vector bool int", "vector bool int", "xxlorc  r,a,b" ],
                [ "vector signed int", "vector signed int", "vector signed int", "xxlorc  r,a,b" ],
                [ "vector unsigned int", "vector unsigned int", "vector unsigned int", "xxlorc  r,a,b" ],
                [ "vector bool long long", "vector bool long long", "vector bool long long", "xxlorc  r,a,b" ],
                [ "vector signed long long", "vector signed long long", "vector signed long long", "xxlorc  r,a,b" ],
                [ "vector unsigned long long", "vector unsigned long long", "vector unsigned long long", "xxlorc  r,a,b" ],
                [ "vector float", "vector float", "vector float", "xxlorc  r,a,b" ],
                [ "vector double", "vector double", "vector double", "xxlorc  r,a,b" ]
            ]
        }
    },
    {
        "mnemonic": "vec_pack",
        "name": "Vector Pack",
        "syntax": "r = vec_pack (a, b)",
        "purpose": "Packs information from each element of two vectors into the result\n      vector.",
        "result": "Let v represent the concatenation of vectors\n      a and b.  For integer types, the value of each element\n      of r is taken from the low-order half\n      of the corresponding element of v. For\n      floating-point types, the value of each element of r is the corresponding element of v, rounded to the result type.",
        "endianness": "The element numbering within a register is left-to-right for big-endian\n      targets, and right-to-left for little-endian targets.",
        "instructions": [ "vpkuhum", "vpkudum", "vpkuwum", "xxpermdi", "xvcvdpsp", "vmrgow", "vmrgew" ],
        "type_signatures": {
            "var_heads": [ "r", "a", "b", "Example LE Implementation", "Example BE Implementation" ],
            "list": [
                [ "vector bool char", "vector bool short", "vector bool short", "vpkuhum r,b,a", "vpkuhum r,a,b" ],
                [ "vector signed char", "vector signed short", "vector signed short", "vpkuhum r,b,a", "vpkuhum r,a,b" ],
                [ "vector unsigned char", "vector unsigned short", "vector unsigned short", "vpkuhum r,b,a", "vpkuhum r,a,b" ],
                [ "vector bool short", "vector bool int", "vector bool int", "vpkuwum r,b,a", "vpkuwum r,a,b" ],
                [ "vector signed short", "vector signed int", "vector signed int", "vpkuwum r,b,a", "vpkuwum r,a,b" ],
                [ "vector unsigned short", "vector unsigned int", "vector unsigned int", "vpkuwum r,b,a", "vpkuwum r,a,b" ],
                [ "vector bool int", "vector bool long long", "vector bool long long", "vpkudum r,b,a", "vpkudum r,a,b" ],
                [ "vector signed int", "vector signed long long", "vector signed long long", "vpkudum r,b,a", "vpkudum r,a,b" ],
                [ "vector unsigned int", "vector unsigned long long", "vector unsigned long long", "vpkudum r,b,a", "vpkudum r,a,b" ],
                [ "vector float", "vector double", "vector double", "xxpermdi  t,b,a,0\n xxpermdi  u,b,a,3\n xvcvdpsp  t,t\n xvcvdpsp  u,u\n vmrgow    r,t,u", "xxpermdi  t,a,b,0\n xxpermdi  u,a,b,3\n xvcvdpsp  t,t\n xvcvdpsp  u,u\n vmrgew    r,t,u" ]
            ]
        }
    },
    {
        "mnemonic": "vec_pack_to_short_fp32",
        "name": "Vector Pack 32-bit Float to Short",
        "syntax": "r = vec_pack_to_short_fp32 (a, b)",
        "purpose": "Packs eight single-precision 32-bit floating-point numbers from two\n      source vectors into a vector of eight 16-bit floating-point numbers.",
        "result": "Let v represent the 16-element concatenation of\n      a and b.  Each value of r contains the result of converting the\n      corresponding single-precision element of v to half-precision.",
        "endianness": "The element numbering within a register is left-to-right for big-endian\n      targets, and right-to-left for little-endian targets.",
        "instructions": [ "vctuxs", "vpkswss" ],
        "type_signatures": {
            "var_heads": [ "r", "a", "b", "Example LE Implementation", "Example BE Implementation", "Restrictions" ],
            "list": [
                [ "vector unsigned short", "vector float", "vector float", "xvcvsphp t,a\n xvcvsphp u,b\n vpkuwum  r,t,u", "xvcvsphp t,a\n xvcvsphp u,b\n vpkuwum  r,u,t", "ISA 3.0 or later" ]
            ]
        }
    },
    {
        "mnemonic": "vec_packpx",
        "name": "Vector Pack Pixel",
        "syntax": "r = vec_packpx (a, b)",
        "purpose": "Packs information from each element of two vectors into the result\n      vector.",
        "result": "Let v be the concatenation of a and b.  The\n      value of each element of r is taken\n      from the corresponding element of v as\n      follows:",
        "endianness": "The element numbering within a register is left-to-right for big-endian\n      targets, and right-to-left for little-endian targets.",
        "instructions": [ "vpkpx" ],
        "type_signatures": {
            "var_heads": [ "r", "a", "b", "Example LE Implementation", "Example BE Implementation" ],
            "list": [
                [ "vector pixel", "vector unsigned int", "vector unsigned int", "vpkpx r,b,a", "vpkpx r,a,b" ]
            ]
        }
    },
    {
        "mnemonic": "vec_packs",
        "name": "Vector Pack Saturated",
        "syntax": "r = vec_packs (a, b)",
        "purpose": "Packs information from each element of two vectors into the result\n      vector, using saturated values.",
        "result": "Let v be the concatenation of a and b. The\n      value of each element of r is the\n      saturated value of the corresponding element of v.",
        "endianness": "The element numbering within a register is left-to-right for big-endian\n      targets, and right-to-left for little-endian targets.",
        "instructions": [ "vpkshss", "vpkuhus", "vpksdss", "vpkudus", "vpkswss", "vpkuwus" ],
        "type_signatures": {
            "var_heads": [ "r", "a", "b", "Example LE Implementation", "Example BE Implementation" ],
            "list": [
                [ "vector signed char", "vector signed short", "vector signed short", "vpkshss  r,b,a", "vpkshss  r,a,b" ],
                [ "vector unsigned char", "vector unsigned short", "vector unsigned short", "vpkuhus  r,b,a", "vpkuhus  r,a,b" ],
                [ "vector signed short", "vector signed int", "vector signed int", "vpkswss  r,b,a", "vpkswss  r,a,b" ],
                [ "vector unsigned short", "vector unsigned int", "vector unsigned int", "vpkuwus  r,b,a", "vpkuwus  r,a,b" ],
                [ "vector signed int", "vector signed long long", "vector signed long long", "vpksdss  r,b,a", "vpksdss  r,a,b" ],
                [ "vector unsigned int", "vector unsigned long long", "vector unsigned long long", "vpkudus  r,b,a", "vpkudus  r,a,b" ]
            ]
        }
    },
    {
        "mnemonic": "vec_packsu",
        "name": "Vector Pack Saturated Unsigned",
        "syntax": "r = vec_packsu (a, b)",
        "purpose": "Packs information from each element of two vectors into the result\n      vector, using unsigned saturated values.",
        "result": "Let v be the concatenation of a and b. The\n      value of each element of r is the\n      saturated value of the corresponding element of v.",
        "endianness": "The element numbering within a register is left-to-right for big-endian\n      targets, and right-to-left for little-endian targets.",
        "instructions": [ "vpkshus", "vpkuhus", "vpksdus", "vpkudus", "vpkswus", "vpkuwus" ],
        "type_signatures": {
            "var_heads": [ "r", "a", "b", "Example LE Implementation", "Example BE Implementation" ],
            "list": [
                [ "vector unsigned char", "vector signed short", "vector signed short", "vpkshus r,b,a", "vpkshus r,a,b" ],
                [ "vector unsigned char", "vector unsigned short", "vector unsigned short", "vpkuhus r,b,a", "vpkuhus r,a,b" ],
                [ "vector unsigned short", "vector signed int", "vector signed int", "vpkswus r,b,a", "vpkswus r,a,b" ],
                [ "vector unsigned short", "vector unsigned int", "vector unsigned int", "vpkuwus r,b,a", "vpkuwus r,a,b" ],
                [ "vector unsigned int", "vector signed long long", "vector signed long long", "vpksdus r,b,a", "vpksdus r,a,b" ],
                [ "vector unsigned int", "vector unsigned long long", "vector unsigned long long", "vpkudus r,b,a", "vpkudus r,a,b" ]
            ]
        }
    },
    {
        "mnemonic": "vec_parity_lsbb",
        "name": "Vector Parity over Least-Significant Bits of Bytes",
        "syntax": "r = vec_parity_lsbb (a)",
        "purpose": "Compute parity on the least-significant bit of each byte.",
        "result": "Each element of\n      r contains the parity computed over the\n      low-order bit of each of the bytes in the corresponding element of\n      a.",
        "endianness": "None.",
        "instructions": [ "vprtybw", "vprtybq", "vprtybd" ],
        "type_signatures": {
            "var_heads": [ "r", "a", "Example Implementation", "Restrictions" ],
            "list": [
                [ "vector unsigned int", "vector signed int", "vprtybw  r,a", "ISA 3.0 or later" ],
                [ "vector unsigned int", "vector unsigned int", "vprtybw  r,a", "ISA 3.0 or later" ],
                [ "vector unsigned long long", "vector signed long long", "vprtybd  r,a", "ISA 3.0 or later" ],
                [ "vector unsigned long long", "vector unsigned long long", "vprtybd  r,a", "ISA 3.0 or later" ],
                [ "vector unsigned __int128", "vector signed __int128", "vprtybq  r,a", "ISA 3.0 or later" ],
                [ "vector unsigned __int128", "vector unsigned __int128", "vprtybq  r,a", "ISA 3.0 or later" ]
            ]
        }
    },
    {
        "mnemonic": "vec_perm",
        "name": "Vector Permute",
        "syntax": "r = vec_perm (a, b, c)",
        "purpose": "Returns a vector that contains elements selected from two\n      vectors, in the order specified by a third vector.",
        "result": "Let v be the concatenation of a and b.  Each\n      byte of r selected by using the\n      least-significant 5 bits of the corresponding byte of c as an index into v.",
        "endianness": "The element numbering within a register is left-to-right for big-endian\n      targets, and right-to-left for little-endian targets.",
        "instructions": [ "vpermr", "vperm" ],
        "type_signatures": {
            "var_heads": [ "r", "a", "b", "c", "Example LE Implementation", "Example BE Implementation" ],
            "list": [
                [ "vector bool char", "vector bool char", "vector bool char", "vector unsigned char", "vpermr r,b,a,c", "vperm r,a,b,c" ],
                [ "vector signed char", "vector signed char", "vector signed char", "vector unsigned char", "vpermr r,b,a,c", "vperm r,a,b,c" ],
                [ "vector unsigned char", "vector unsigned char", "vector unsigned char", "vector unsigned char", "vpermr r,b,a,c", "vperm r,a,b,c" ],
                [ "vector bool short", "vector bool short", "vector bool short", "vector unsigned char", "vpermr r,b,a,c", "vperm r,a,b,c" ],
                [ "vector signed short", "vector signed short", "vector signed short", "vector unsigned char", "vpermr r,b,a,c", "vperm r,a,b,c" ],
                [ "vector unsigned short", "vector unsigned short", "vector unsigned short", "vector unsigned char", "vpermr r,b,a,c", "vperm r,a,b,c" ],
                [ "vector pixel", "vector pixel", "vector pixel", "vector unsigned char", "vpermr r,b,a,c", "vperm r,a,b,c" ],
                [ "vector bool int", "vector bool int", "vector bool int", "vector unsigned char", "vpermr r,b,a,c", "vperm r,a,b,c" ],
                [ "vector signed int", "vector signed int", "vector signed int", "vector unsigned char", "vpermr r,b,a,c", "vperm r,a,b,c" ],
                [ "vector unsigned int", "vector unsigned int", "vector unsigned int", "vector unsigned char", "vpermr r,b,a,c", "vperm r,a,b,c" ],
                [ "vector bool long long", "vector bool long long", "vector bool long long", "vector unsigned char", "vpermr r,b,a,c", "vperm r,a,b,c" ],
                [ "vector signed long long", "vector signed long long", "vector signed long long", "vector unsigned char", "vpermr r,b,a,c", "vperm r,a,b,c" ],
                [ "vector unsigned long long", "vector unsigned long long", "vector unsigned long long", "vector unsigned char", "vpermr r,b,a,c", "vperm r,a,b,c" ],
                [ "vector float", "vector float", "vector float", "vector unsigned char", "vpermr r,b,a,c", "vperm r,a,b,c" ],
                [ "vector double", "vector double", "vector double", "vector unsigned char", "vpermr r,b,a,c", "vperm r,a,b,c" ]
            ]
        }
    },
    {
        "mnemonic": "vec_permxor",
        "name": "Vector Permute and Exclusive-OR",
        "syntax": "r = vec_permxor (a, b, c)",
        "purpose": "Applies a permute and exclusive-OR operation on two vectors of byte\n      elements, with the selected elements identified by a third vector.",
        "result": "For each\n      i (0 ≤ i < 16), let\n      x be bits 0–3 and\n      y be bits 4–7 of byte element\n      i of c.  Byte\n      element i of r\n      is set to the exclusive-OR of byte elements x\n      of a and y\n      of b.",
        "endianness": "The element numbering within a register is left-to-right for big-endian\n      targets, and right-to-left for little-endian targets.",
        "instructions": [ "xxlnor", "vpermxor" ],
        "type_signatures": {
            "var_heads": [ "r", "a", "b", "c", "Example LE Implementation", "Example BE Implementation" ],
            "list": [
                [ "vector bool char", "vector bool char", "vector bool char", "vector bool char", "xxlnor   t,c,c\n vpermxor r,a,b,t", "vpermxor r,a,b,c" ],
                [ "vector signed char", "vector signed char", "vector signed char", "vector signed char", "xxlnor   t,c,c\n vpermxor r,a,b,t", "vpermxor r,a,b,c" ],
                [ "vector unsigned char", "vector unsigned char", "vector unsigned char", "vector unsigned char", "xxlnor   t,c,c\n vpermxor r,a,b,t", "vpermxor r,a,b,c" ]
            ]
        }
    },
    {
        "mnemonic": "vec_pmsum_be",
        "name": "Vector Polynomial Multiply-Sum Big-Endian",
        "syntax": "r = vec_pmsum_be (a, b)",
        "purpose": "Performs the exclusive-OR operation (implementing polynomial addition)\n      on each even-odd pair of the polynomial-multiplication result of the\n      corresponding elements of a and\n      b.",
        "result": "Each element\n      i of r is\n      computed by an exclusive-OR operation of the polynomial\n      multiplication of input elements 2 × i of\n      a and b and input elements 2 ×\n      i + 1 of a and\n      b.",
        "endianness": "",
        "instructions": [ "vpmsumh", "vpmsumd", "vpmsumw", "vpmsumb" ],
        "type_signatures": {
            "var_heads": [ "r", "a", "b", "Example Implementation" ],
            "list": [
                [ "vector unsigned short", "vector unsigned char", "vector unsigned char", "vpmsumb  r,a,b" ],
                [ "vector unsigned int", "vector unsigned short", "vector unsigned short", "vpmsumh  r,a,b" ],
                [ "vector unsigned long long", "vector unsigned int", "vector unsigned int", "vpmsumw  r,a,b" ],
                [ "vector unsigned __int128", "vector unsigned long long", "vector unsigned long long", "vpmsumd  r,a,b" ]
            ]
        }
    },
    {
        "mnemonic": "vec_popcnt",
        "name": "Vector Population Count",
        "syntax": "r = vec_popcnt (a)",
        "purpose": "Returns a vector containing the number of bits set in each element of\n      the source vector.",
        "result": "The value of each\n      element of r is the number of bits set\n      in the corresponding element of a.",
        "endianness": "None.",
        "instructions": [ "vpopcntb", "vpopcntw", "vpopcntd", "vpopcnth" ],
        "type_signatures": {
            "var_heads": [ "r", "a", "Example Implementation" ],
            "list": [
                [ "vector unsigned char", "vector signed char", "vpopcntb  r,a" ],
                [ "vector unsigned char", "vector unsigned char", "vpopcntb  r,a" ],
                [ "vector unsigned short", "vector signed short", "vpopcnth  r,a" ],
                [ "vector unsigned short", "vector unsigned short", "vpopcnth  r,a" ],
                [ "vector unsigned int", "vector signed int", "vpopcntw  r,a" ],
                [ "vector unsigned int", "vector unsigned int", "vpopcntw  r,a" ],
                [ "vector unsigned long long", "vector signed long long", "vpopcntd  r,a" ],
                [ "vector unsigned long long", "vector unsigned long long", "vpopcntd  r,a" ]
            ]
        }
    },
    {
        "mnemonic": "vec_re",
        "name": "Vector Reciprocal Estimate",
        "syntax": "r = vec_re (a)",
        "purpose": "Returns a vector containing estimates of the reciprocals of the\n      corresponding elements of the source vector.",
        "result": "Each element of\n      r contains the estimated value of the\n      reciprocal of the corresponding element of a.",
        "endianness": "None.",
        "instructions": [ "xvredp", "xvresp" ],
        "type_signatures": {
            "var_heads": [ "r", "a", "Example Implementation" ],
            "list": [
                [ "vector float", "vector float", "xvresp  r,a" ],
                [ "vector double", "vector double", "xvredp  r,a" ]
            ]
        }
    },
    {
        "mnemonic": "vec_recipdiv",
        "name": "Vector Reciprocal Divide",
        "syntax": "r = vec_recipdiv (a, b)",
        "purpose": "Returns a vector containing refined approximations of the\n      division of the corresponding elements of a by the corresponding elements of\n      b.",
        "result": "Each element of\n      r contains a refined approximation of\n      the division of the corresponding element of a by the corresponding element of b.",
        "endianness": "None.",
        "instructions": [ "xvredp", "xvnmsubadp", "xvmaddmdp", "xvmuldp", "xvresp", "xvmulsp", "xvnmsubasp", "xvmaddmsp" ],
        "type_signatures": {
            "var_heads": [ "r", "a", "b", "Example Implementation" ],
            "list": [
                [ "vector float", "vector float", "vector float", "xvresp      t,b\n  xvmulsp     u,a,t\n  xvnmsubasp  r/a,b,u\n  xvmaddmsp   r/a,t,u" ],
                [ "vector double", "vector double", "vector double", "xvredp      t,b\n  xvnmsubadp  z,b,t\n  xvmaddadp   u,z,t\n  xvmuldp     v,a,u\n  xvnmsubadp  r/a,b,v\n  xvmaddmdp   r/a,u,v" ]
            ]
        }
    },
    {
        "mnemonic": "vec_revb",
        "name": "Vector Reverse Bytes",
        "syntax": "r = vec_revb (a)",
        "purpose": "Reverse the bytes of each vector element of a vector.",
        "result": "Each element of\n      r contains the byte-reversed value of\n      the corresponding element of a.",
        "endianness": "None.",
        "instructions": [ "xxbrw", "xxbrq", "xxbrd", "xxbrh" ],
        "type_signatures": {
            "var_heads": [ "r", "a", "Example ISA 3.0 Implementation", "Restrictions" ],
            "list": [
                [ "vector bool char", "vector bool char", "[none]", "Deprecated" ],
                [ "vector signed char", "vector signed char", "[none]", "Deprecated" ],
                [ "vector unsigned char", "vector unsigned char", "[none]", "Deprecated" ],
                [ "vector bool short", "vector bool short", "xxbrh  r,a", "Deprecated" ],
                [ "vector signed short", "vector signed short", "xxbrh  r,a", "" ],
                [ "vector unsigned short", "vector unsigned short", "xxbrh  r,a", "" ],
                [ "vector bool int", "vector bool int", "xxbrw  r,a", "Deprecated" ],
                [ "vector signed int", "vector signed int", "xxbrw  r,a", "" ],
                [ "vector unsigned int", "vector unsigned int", "xxbrw  r,a", "" ],
                [ "vector bool long long", "vector bool long long", "xxbrd  r,a", "Deprecated" ],
                [ "vector signed long long", "vector signed long long", "xxbrd  r,a", "" ],
                [ "vector unsigned long long", "vector unsigned long long", "xxbrd  r,a", "" ],
                [ "vector signed __int128", "vector signed __int128", "xxbrq  r,a", "" ],
                [ "vector unsigned __int128", "vector unsigned __int128", "xxbrq  r,a", "" ],
                [ "vector float", "vector float", "xxbrw  r,a", "" ],
                [ "vector double", "vector double", "xxbrd  r,a", "" ]
            ]
        }
    },
    {
        "mnemonic": "vec_reve",
        "name": "Vector Reverse Elements",
        "syntax": "r = vec_reve (a)",
        "purpose": "Reverse the elements of a vector.",
        "result": "Returns a vector\n      with the elements of the source vector in reversed order.",
        "endianness": "The vpermr instruction is most naturally used to implement this built-in\n      function for a little-endian target, and the vperm instruction for a\n      big-endian target.  This is not technically necessary, however, provided\n      the correct permute control vector is used.  Note that use of vpermr\n      requires ISA 3.0.",
        "instructions": [ "vperm", "vpermr" ],
        "type_signatures": {
            "var_heads": [ "r", "a", "Example Implementation" ],
            "list": [
                [ "vector bool char", "vector bool char", "vperm[r]  r,a,a,pcv" ],
                [ "vector signed char", "vector signed char", "vperm[r]  r,a,a,pcv" ],
                [ "vector unsigned char", "vector unsigned char", "vperm[r]  r,a,a,pcv" ],
                [ "vector bool short", "vector bool short", "vperm[r]  r,a,a,pcv" ],
                [ "vector signed short", "vector signed short", "vperm[r]  r,a,a,pcv" ],
                [ "vector unsigned short", "vector unsigned short", "vperm[r]  r,a,a,pcv" ],
                [ "vector bool int", "vector bool int", "vperm[r]  r,a,a,pcv" ],
                [ "vector signed int", "vector signed int", "vperm[r]  r,a,a,pcv" ],
                [ "vector unsigned int", "vector unsigned int", "vperm[r]  r,a,a,pcv" ],
                [ "vector bool long long", "vector bool long long", "vperm[r]  r,a,a,pcv" ],
                [ "vector signed long long", "vector signed long long", "vperm[r]  r,a,a,pcv" ],
                [ "vector unsigned long long", "vector unsigned long long", "vperm[r]  r,a,a,pcv" ],
                [ "vector float", "vector float", "vperm[r]  r,a,a,pcv" ],
                [ "vector double", "vector double", "vperm[r]  r,a,a,pcv" ]
            ]
        }
    },
    {
        "mnemonic": "vec_rint",
        "name": "Vector Round to Nearest Integer",
        "syntax": "r = vec_rint (a)",
        "purpose": "Returns a vector containing the floating-point integral values nearest\n      to the values of the corresponding elements of the source vector.",
        "result": "Each element of\n      r contains the nearest representable\n      floating-point integral value to the value of the corresponding element\n      of a. When an input element value is\n      exactly between two integer values, the result value is selected based\n      on the rounding mode specified by the Floating-Point Rounding Control\n      field (RN) of the FPSCR register.",
        "endianness": "None.",
        "instructions": [ "xvrdpic", "xvrspic" ],
        "type_signatures": {
            "var_heads": [ "r", "a", "Example Implementation" ],
            "list": [
                [ "vector float", "vector float", "xvrspic  r,a" ],
                [ "vector double", "vector double", "xvrdpic  r,a" ]
            ]
        }
    },
    {
        "mnemonic": "vec_rl",
        "name": "Vector Rotate Left",
        "syntax": "r = vec_rl (a, b)",
        "purpose": "Rotates each element of a vector left by a given number of bits.",
        "result": "Each element of\n      r is obtained by rotating the\n      corresponding element of a left by the\n      number of bits specified by the corresponding element of\n      b.",
        "endianness": "None.",
        "instructions": [ "vrlb", "vrlw", "vrld", "vrlh" ],
        "type_signatures": {
            "var_heads": [ "r", "a", "b", "Example Implementation" ],
            "list": [
                [ "vector signed char", "vector signed char", "vector unsigned char", "vrlb  r,a,b" ],
                [ "vector unsigned char", "vector unsigned char", "vector unsigned char", "vrlb  r,a,b" ],
                [ "vector signed short", "vector signed short", "vector unsigned short", "vrlh  r,a,b" ],
                [ "vector unsigned short", "vector unsigned short", "vector unsigned short", "vrlh  r,a,b" ],
                [ "vector signed int", "vector signed int", "vector unsigned int", "vrlw  r,a,b" ],
                [ "vector unsigned int", "vector unsigned int", "vector unsigned int", "vrlw  r,a,b" ],
                [ "vector signed long long", "vector signed long long", "vector unsigned long long", "vrld  r,a,b" ],
                [ "vector unsigned long long", "vector unsigned long long", "vector unsigned long long", "vrld  r,a,b" ]
            ]
        }
    },
    {
        "mnemonic": "vec_rlmi",
        "name": "Vector Rotate Left then Mask Insert",
        "syntax": "r = vec_rlmi (a, b, c)",
        "purpose": "Rotates each element of a vector left and inserts each element under\n      a mask.",
        "result": "Each element of\n      r is obtained by rotating the\n      corresponding element of vector b left\n      and inserting it under mask into the corresponding element of\n      a. Bits 11:15 of the corresponding\n      element of c contain the mask\n      beginning, bits 19:23 contain the mask end, and bits 27:31 contain the\n      shift count.",
        "endianness": "The referenced bit numbers within the elements of c are in left-to-right order.",
        "instructions": [ "vrlwmi", "vrldmi" ],
        "type_signatures": {
            "var_heads": [ "r", "a", "b", "c", "Example Implementation", "Restrictions" ],
            "list": [
                [ "vector unsigned int", "vector unsigned int", "vector unsigned int", "vector unsigned int", "vrlwmi r/a,b,c", "ISA 3.0 or later" ],
                [ "vector unsigned long long", "vector unsigned long long", "vector unsigned long long", "vector unsigned long long", "vrldmi r/a,b,c", "ISA 3.0 or later" ]
            ]
        }
    },
    {
        "mnemonic": "vec_rlnm",
        "name": "Vector Rotate Left then AND with Mask",
        "syntax": "r = vec_rlnm (a, b, c)",
        "purpose": "Rotates each element of a vector left, then logically ANDs it with a\n      mask.",
        "result": "Each element of\n      a is rotated left, then logically ANDed\n      with a mask specified by b and\n      c.",
        "endianness": "None.",
        "instructions": [ "vspltisw", "vslw", "xxlor", "vrlwnm", "xxspltib", "vextsb2d", "vsld", "vrldnm" ],
        "type_signatures": {
            "var_heads": [ "r", "a", "b", "c", "Example Implementation", "Restrictions" ],
            "list": [
                [ "vector unsigned int", "vector unsigned int", "vector unsigned int", "vector unsigned int", "vspltisw t,8\n vslw     u,b,t\n xxlor    v,u,c\n vrlwnm   r,a,v", "ISA 3.0 or later" ],
                [ "vector unsigned long long", "vector unsigned long long", "vector unsigned long long", "vector unsigned long long", "xxspltib t,8\n vextsb2d u,t\n vsld     v,b,u\n xxlor    w,v,c\n vrldnm   r,a,w", "ISA 3.0 or later" ]
            ]
        }
    },
    {
        "mnemonic": "vec_round",
        "name": "Vector Round",
        "syntax": "r = vec_round (a)",
        "purpose": "Returns a vector containing the rounded values of the corresponding\n      elements of the source vector.",
        "result": "Each element of\n      r contains the value of the\n      corresponding element of a, rounded\n      to the nearest representable floating-point integer, using IEEE\n      round-to-nearest rounding.  The current floating-point rounding\n      mode is ignored.",
        "endianness": "None.",
        "instructions": [ "xvrdpi", "vrfin" ],
        "type_signatures": {
            "var_heads": [ "r", "a", "Example Implementation" ],
            "list": [
                [ "vector float", "vector float", "vrfin  r,a" ],
                [ "vector double", "vector double", "xvrdpi  r,a" ]
            ]
        }
    },
    {
        "mnemonic": "vec_rsqrt",
        "name": "Vector Reciprocal Square Root",
        "syntax": "r = vec_rsqrt (a)",
        "purpose": "Returns a vector containing a refined approximation of the reciprocal\n      square roots of the corresponding elements of the source vector. This\n      function provides an implementation-dependent greater precision than\n      vec_rsqrte.",
        "result": "Each element of\n      r contains a refined approximation of\n      the reciprocal square root of the corresponding element of\n      a.",
        "endianness": "None.",
        "instructions": [ "xvrsqrtedp", "xvmuldp", "xxlor", "xvnmsubadp", "xvmaddadp", "xvnmsubmdp", "xvadddp", "xvrsqrtesp", "xvmulsp", "xvnmsubmsp", "xvmaddmsp" ],
        "type_signatures": {
            "var_heads": [ "r", "a", "Example Implementation" ],
            "list": [
                [ "vector float", "vector float", "xvrsqrtesp  t,a\n  xvmulsp     u,t,a\n  xvmulsp     v,t,h\n  xvnmsubmsp  v,u,h\n  xvmaddmsp   r/v,t,t" ],
                [ "vector double", "vector double", "xvrsqrtedp  t,a\n  xvmuldp     u,t,a\n  xvmuldp     v,t,h\n  xxlor       w,h,h\n  xvnmsubadp  w,u,v\n  xvmaddadp   v,v,w\n  xvmaddadp   u,u,w\n  xvnmsubmdp  u,v,h\n  xvmaddadp   v,v,u\n  xvadddp     r,v,v" ]
            ]
        }
    },
    {
        "mnemonic": "vec_rsqrte",
        "name": "Vector Reciprocal Square Root Estimate",
        "syntax": "r = vec_rsqrte (a)",
        "purpose": "Returns a vector containing estimates of the reciprocal square roots of\n      the corresponding elements of the source vector.",
        "result": "Each element of\n      r contains the estimated value of the\n      reciprocal square root of the corresponding element of a.",
        "endianness": "None.",
        "instructions": [ "xvrsqrtedp", "xvrsqrtesp" ],
        "type_signatures": {
            "var_heads": [ "r", "a", "Example Implementation" ],
            "list": [
                [ "vector float", "vector float", "xvrsqrtesp  r,a" ],
                [ "vector double", "vector double", "xvrsqrtedp  r,a" ]
            ]
        }
    },
    {
        "mnemonic": "vec_sbox_be",
        "name": "Vector AES SubBytes Big-Endian",
        "syntax": "r = vec_sbox_be (a)",
        "purpose": "Performs the SubBytes operation, as defined in Federal Information\n      Processing Standards FIPS-197, on a state_array contained in\n      a.",
        "result": "r contains the\n      result of the SubBytes operation, as defined in Federal Information\n      Processing Standard FIPS-197, on the state array represented by\n      a.",
        "endianness": "",
        "instructions": [ "vsbox" ],
        "type_signatures": {
            "var_heads": [ "r", "a", "Example Implementation" ],
            "list": [
                [ "vector unsigned char", "vector unsigned char", "vsbox  r,a" ]
            ]
        }
    },
    {
        "mnemonic": "vec_sel",
        "name": "Vector Select",
        "syntax": "r = vec_sel (a, b, c)",
        "purpose": "Returns a vector selecting bits from two source vectors\n      depending on the corresponding bit values of a third source\n      vector.",
        "result": "Each bit of\n      r has the value of the corresponding\n      bit of a if the corresponding bit of\n      c is 0. Otherwise, the bit of\n      r has the value of the corresponding\n      bit of b.",
        "endianness": "None.",
        "instructions": [ "xxsel" ],
        "type_signatures": {
            "var_heads": [ "r", "a", "b", "c", "Example Implementation" ],
            "list": [
                [ "vector bool char", "vector bool char", "vector bool char", "vector bool char", "xxsel  r,a,b,c" ],
                [ "vector bool char", "vector bool char", "vector bool char", "vector unsigned char", "xxsel  r,a,b,c" ],
                [ "vector signed char", "vector signed char", "vector signed char", "vector bool char", "xxsel  r,a,b,c" ],
                [ "vector signed char", "vector signed char", "vector signed char", "vector unsigned char", "xxsel  r,a,b,c" ],
                [ "vector unsigned char", "vector unsigned char", "vector unsigned char", "vector bool char", "xxsel  r,a,b,c" ],
                [ "vector unsigned char", "vector unsigned char", "vector unsigned char", "vector unsigned char", "xxsel  r,a,b,c" ],
                [ "vector bool short", "vector bool short", "vector bool short", "vector bool short", "xxsel  r,a,b,c" ],
                [ "vector bool short", "vector bool short", "vector bool short", "vector unsigned short", "xxsel  r,a,b,c" ],
                [ "vector signed short", "vector signed short", "vector signed short", "vector bool short", "xxsel  r,a,b,c" ],
                [ "vector signed short", "vector signed short", "vector signed short", "vector unsigned short", "xxsel  r,a,b,c" ],
                [ "vector unsigned short", "vector unsigned short", "vector unsigned short", "vector bool short", "xxsel  r,a,b,c" ],
                [ "vector unsigned short", "vector unsigned short", "vector unsigned short", "vector unsigned short", "xxsel  r,a,b,c" ],
                [ "vector bool int", "vector bool int", "vector bool int", "vector bool int", "xxsel  r,a,b,c" ],
                [ "vector bool int", "vector bool int", "vector bool int", "vector unsigned int", "xxsel  r,a,b,c" ],
                [ "vector signed int", "vector signed int", "vector signed int", "vector bool int", "xxsel  r,a,b,c" ],
                [ "vector signed int", "vector signed int", "vector signed int", "vector unsigned int", "xxsel  r,a,b,c" ],
                [ "vector unsigned int", "vector unsigned int", "vector unsigned int", "vector bool int", "xxsel  r,a,b,c" ],
                [ "vector unsigned int", "vector unsigned int", "vector unsigned int", "vector unsigned int", "xxsel  r,a,b,c" ],
                [ "vector bool long long", "vector bool long long", "vector bool long long", "vector bool long long", "xxsel  r,a,b,c" ],
                [ "vector bool long long", "vector bool long long", "vector bool long long", "vector unsigned long long", "xxsel  r,a,b,c" ],
                [ "vector signed long long", "vector signed long long", "vector signed long long", "vector bool long long", "xxsel  r,a,b,c" ],
                [ "vector signed long long", "vector signed long long", "vector signed long long", "vector unsigned long long", "xxsel  r,a,b,c" ],
                [ "vector unsigned long long", "vector unsigned long long", "vector unsigned long long", "vector bool long long", "xxsel  r,a,b,c" ],
                [ "vector unsigned long long", "vector unsigned long long", "vector unsigned long long", "vector unsigned long long", "xxsel  r,a,b,c" ],
                [ "vector float", "vector float", "vector float", "vector bool int", "xxsel  r,a,b,c" ],
                [ "vector float", "vector float", "vector float", "vector unsigned int", "xxsel  r,a,b,c" ],
                [ "vector double", "vector double", "vector double", "vector bool long long", "xxsel  r,a,b,c" ],
                [ "vector double", "vector double", "vector double", "vector unsigned long long", "xxsel  r,a,b,c" ]
            ]
        }
    },
    {
        "mnemonic": "vec_shasigma_be",
        "name": "Vector SHA Sigma Big-Endian",
        "syntax": "r = vec_shasigma_be (a, b, c)",
        "purpose": "Performs a Secure Hash computation in accordance with Federal\n      Information Processing Standards FIPS-180-3.",
        "result": "Each element of\n      r contains the SHA256 or SHA512 hash\n      as follows.",
        "endianness": "",
        "instructions": [ "vshasigmaw" ],
        "type_signatures": {
            "var_heads": [ "r", "a", "b", "c", "Example Implementation" ],
            "list": [
                [ "vector unsigned int", "vector unsigned int", "const int", "4-bit unsigned literal", "vshasigmaw  r,a,b,c" ],
                [ "vector unsigned long long", "vector unsigned long long", "const int", "4-bit unsigned literal", "vshasigmaw  r,a,b,d" ]
            ]
        }
    },
    {
        "mnemonic": "vec_signed",
        "name": "Vector Convert Floating-Point to Signed Integer",
        "syntax": "r = vec_signed (a)",
        "purpose": "Converts a vector of floating-point numbers to a vector of signed\n      integers.",
        "result": "Each\n      element of r is obtained by\n      truncating the corresponding element of a to a signed integer.  The current\n      floating-point rounding mode is ignored.",
        "endianness": "None.",
        "instructions": [ "xvcvspsxws", "xvcvdpsxds" ],
        "type_signatures": {
            "var_heads": [ "r", "a", "Example Implementation" ],
            "list": [
                [ "vector signed int", "vector float", "xvcvspsxws  r,a" ],
                [ "vector signed long long", "vector double", "xvcvdpsxds  r,a" ]
            ]
        }
    },
    {
        "mnemonic": "vec_signed2",
        "name": "Vector Convert Double-Precision to Signed Word",
        "syntax": "r = vec_signed2 (a, b)",
        "purpose": "Converts two vectors of double-precision floating-point numbers to a\n      vector of signed 32-bit integers.",
        "result": "Let v be the concatenation of a and b.  Each\n      element of r is obtained by truncating\n      the corresponding element of v to a\n      signed 32-bit integer.",
        "endianness": "The element numbering within a register is left-to-right for big-endian\n      targets, and right-to-left for little-endian targets.",
        "instructions": [ "xxpermdi", "xvcvdpsxws", "vmrgow", "vmrgew" ],
        "type_signatures": {
            "var_heads": [ "r", "a", "b", "Example LE\nImplementation", "Example BE\nImplementation" ],
            "list": [
                [ "vector signed int", "vector double", "vector double", "xxpermdi   t,b,a,3\n xxpermdi   u,b,a,0\n xvcvdpsxws v,t\n xvcvdpsxws w,u\n vmrgow     r,w,v", "xxpermdi   t,a,b,0\n xxpermdi   u,a,b,3\n xvcvdpsxws v,t\n xvcvdpsxws w,u\n vmrgew     r,v,w" ]
            ]
        }
    },
    {
        "mnemonic": "vec_signede",
        "name": "Vector Convert Double-Precision to Signed Word Even",
        "syntax": "r = vec_signede (a)",
        "purpose": "Converts elements of a source vector to signed integers and stores\n      them in the even-numbered elements of the result vector.",
        "result": "Element 0 of\n      r contains element 0 of a, truncated to a signed integer.  Element 2 of\n      r contains element 1 of a, truncated to a signed integer.  Elements 1 and\n      3 of r are undefined.",
        "endianness": "The element numbering within a register is left-to-right for big-endian\n      targets, and right-to-left for little-endian targets.",
        "instructions": [ "xvcvdpsxws", "vsldoi" ],
        "type_signatures": {
            "var_heads": [ "r", "a", "Example LE\nImplementation", "Example BE\nImplementation" ],
            "list": [
                [ "vector signed int", "vector double", "xvcvdpsxws  t,a\n  vsldoi      r,t,t,12", "xvcvdpsxws  t,a" ]
            ]
        }
    },
    {
        "mnemonic": "vec_signedo",
        "name": "Vector Convert Double-Precision to Signed Word Odd",
        "syntax": "r = vec_signedo (a)",
        "purpose": "Converts elements of a source vector to signed integers and stores them\n      in the odd-numbered elements of the result vector.",
        "result": "Element 1 of\n      r contains element 0 of a, truncated to a signed integer.  Element 3 of\n      r contains element 1 of a, truncated to a signed integer.  Elements 0 and\n      2 of r are undefined.",
        "endianness": "The element numbering within a register is left-to-right for big-endian\n      targets, and right-to-left for little-endian targets.",
        "instructions": [ "xvcvdpsxws", "vsldoi" ],
        "type_signatures": {
            "var_heads": [ "r", "a", "Example LE\nImplementation", "Example BE\nImplementation" ],
            "list": [
                [ "vector signed int", "vector double", "xvcvdpsxws  r,a", "xvcvdpsxws  t,a\n  vsldoi      r,t,t,12" ]
            ]
        }
    },
    {
        "mnemonic": "vec_sl",
        "name": "Vector Shift Left",
        "syntax": "r = vec_sl (a, b)",
        "purpose": "Performs a left shift for each element of a vector.",
        "result": "Each element of\n      r is the result of left-shifting the\n      corresponding element of a by the\n      number of bits specified by the corresponding element of b, modulo the number of bits in the element.\n      Zeros are shifted in from the right.",
        "endianness": "None.",
        "instructions": [ "vslb", "vslw", "vsld", "vslh" ],
        "type_signatures": {
            "var_heads": [ "r", "a", "b", "Example Implementation" ],
            "list": [
                [ "vector signed char", "vector signed char", "vector unsigned char", "vslb  r,a,b" ],
                [ "vector unsigned char", "vector unsigned char", "vector unsigned char", "vslb  r,a,b" ],
                [ "vector signed short", "vector signed short", "vector unsigned short", "vslh  r,a,b" ],
                [ "vector unsigned short", "vector unsigned short", "vector unsigned short", "vslh  r,a,b" ],
                [ "vector signed int", "vector signed int", "vector unsigned int", "vslw  r,a,b" ],
                [ "vector unsigned int", "vector unsigned int", "vector unsigned int", "vslw  r,a,b" ],
                [ "vector signed long long", "vector signed long long", "vector unsigned long long", "vsld  r,a,b" ],
                [ "vector unsigned long long", "vector unsigned long long", "vector unsigned long long", "vsld  r,a,b" ]
            ]
        }
    },
    {
        "mnemonic": "vec_sld",
        "name": "Vector Shift Left Double",
        "syntax": "r = vec_sld (a, b, c)",
        "purpose": "Left shifts a double vector (that is, two concatenated vectors) by a\n      given number of bytes. For vec_sld being performed on the vector bool\n      and floating-point types, the result is undefined when the specified\n      shift count is not a multiple of the element size.",
        "result": "Vector r receives the most-significant 16 bytes obtained\n      by concatenating a and b and shifting left by the number of bytes\n      specified by c, which must be in the\n      range 0–15.",
        "endianness": "",
        "instructions": [ "vsldoi" ],
        "type_signatures": {
            "var_heads": [ "r", "a", "b", "c", "Example Implementation" ],
            "list": [
                [ "vector bool char", "vector bool char", "vector bool char", "4-bit unsigned literal", "vsldoi  r,a,b,c" ],
                [ "vector signed char", "vector signed char", "vector signed char", "4-bit unsigned literal", "vsldoi  r,a,b,c" ],
                [ "vector unsigned char", "vector unsigned char", "vector unsigned char", "4-bit unsigned literal", "vsldoi  r,a,b,c" ],
                [ "vector bool short", "vector bool short", "vector bool short", "4-bit unsigned literal", "vsldoi  r,a,b,c" ],
                [ "vector signed short", "vector signed short", "vector signed short", "4-bit unsigned literal", "vsldoi  r,a,b,c" ],
                [ "vector unsigned short", "vector unsigned short", "vector unsigned short", "4-bit unsigned literal", "vsldoi  r,a,b,c" ],
                [ "vector pixel", "vector pixel", "vector pixel", "4-bit unsigned literal", "vsldoi  r,a,b,c" ],
                [ "vector bool int", "vector bool int", "vector bool int", "4-bit unsigned literal", "vsldoi  r,a,b,c" ],
                [ "vector signed int", "vector signed int", "vector signed int", "4-bit unsigned literal", "vsldoi  r,a,b,c" ],
                [ "vector unsigned int", "vector unsigned int", "vector unsigned int", "4-bit unsigned literal", "vsldoi  r,a,b,c" ],
                [ "vector bool long long", "vector bool long long", "vector bool long long", "4-bit unsigned literal", "vsldoi  r,a,b,c" ],
                [ "vector signed long long", "vector signed long long", "vector signed long long", "4-bit unsigned literal", "vsldoi  r,a,b,c" ],
                [ "vector unsigned long long", "vector unsigned long long", "vector unsigned long long", "4-bit unsigned literal", "vsldoi  r,a,b,c" ],
                [ "vector float", "vector float", "vector float", "4-bit unsigned literal", "vsldoi  r,a,b,c" ],
                [ "vector double", "vector double", "vector double", "4-bit unsigned literal", "vsldoi  r,a,b,c" ]
            ]
        }
    },
    {
        "mnemonic": "vec_sldw",
        "name": "Vector Shift Left Double by Words",
        "syntax": "r = vec_sldw (a, b, c)",
        "purpose": "Returns a vector obtained by shifting left the concatenated source\n      vectors by the number of specified words.",
        "result": "Vector r receives the most-significant 16 bytes obtained\n      by concatenating a and b and shifting left by the number of words\n      specified by c, which must be in the\n      range 0–3.",
        "endianness": "This intrinsic is not endian-neutral, so uses of\n      vec_sldw in big-endian code must be rewritten for little-endian targets.\n      The concatenation of a and b is\n      done in big-endian fashion (left to right), and the shift is always\n      to the left.  This will generally produce surprising results for\n      little-endian targets.",
        "instructions": [ "xxsldwi" ],
        "type_signatures": {
            "var_heads": [ "r", "a", "b", "c", "Example Implementation" ],
            "list": [
                [ "vector signed char", "vector signed char", "vector signed char", "2-bit unsigned literal", "xxsldwi r,a,b,c" ],
                [ "vector unsigned char", "vector unsigned char", "vector unsigned char", "2-bit unsigned literal", "xxsldwi r,a,b,c" ],
                [ "vector signed short", "vector signed short", "vector signed short", "2-bit unsigned literal", "xxsldwi r,a,b,c" ],
                [ "vector unsigned short", "vector unsigned short", "vector unsigned short", "2-bit unsigned literal", "xxsldwi r,a,b,c" ],
                [ "vector signed int", "vector signed int", "vector signed int", "2-bit unsigned literal", "xxsldwi r,a,b,c" ],
                [ "vector unsigned int", "vector unsigned int", "vector unsigned int", "2-bit unsigned literal", "xxsldwi r,a,b,c" ],
                [ "vector signed long long", "vector signed long long", "vector signed long long", "2-bit unsigned literal", "xxsldwi r,a,b,c" ],
                [ "vector unsigned long long", "vector unsigned long long", "vector unsigned long long", "2-bit unsigned literal", "xxsldwi r,a,b,c" ]
            ]
        }
    },
    {
        "mnemonic": "vec_sll",
        "name": "Vector Shift Left Long",
        "syntax": "r = vec_sll (a, b)",
        "purpose": "Left shifts an entire vector by a given number of bits.",
        "result": "Vector\n      r contains the contents of a, shifted left by the number of bits specified\n      by the three least-significant bits of b. Zeros are supplied on the right. The shift\n      count must have been replicated into all bytes of b; if not, the value of r is undefined.",
        "endianness": "This intrinsic is not endian-neutral, so uses of\n      vec_sll in big-endian code must be rewritten for little-endian targets.",
        "instructions": [ "vsl" ],
        "type_signatures": {
            "var_heads": [ "r", "a", "b", "Example Implementation" ],
            "list": [
                [ "vector signed char", "vector signed char", "vector unsigned char", "vsl  r,a,b" ],
                [ "vector unsigned char", "vector unsigned char", "vector unsigned char", "vsl  r,a,b" ],
                [ "vector signed short", "vector signed short", "vector unsigned char", "vsl  r,a,b" ],
                [ "vector unsigned short", "vector unsigned short", "vector unsigned char", "vsl  r,a,b" ],
                [ "vector pixel", "vector pixel", "vector unsigned char", "vsl  r,a,b" ],
                [ "vector signed int", "vector signed int", "vector unsigned char", "vsl  r,a,b" ],
                [ "vector unsigned int", "vector unsigned int", "vector unsigned char", "vsl  r,a,b" ],
                [ "vector signed long long", "vector signed long long", "vector unsigned char", "vsl  r,a,b" ],
                [ "vector unsigned long long", "vector unsigned long long", "vector unsigned char", "vsl  r,a,b" ]
            ]
        }
    },
    {
        "mnemonic": "vec_slo",
        "name": "Vector Shift Left by Octets",
        "syntax": "r = vec_slo (a, b)",
        "purpose": "Left shifts a vector by a given number of bytes (octets).",
        "result": "Vector r receives the contents of a, shifted left by the number of bytes specified\n      by bits 1:4 of the least-significant byte of b.",
        "endianness": "This intrinsic is not endian-neutral, so uses of\n      vec_slo in big-endian code must be rewritten for little-endian targets.\n      The shift count is in element 15 of b\n      for big-endian, but in element 0 of b\n      for little-endian.",
        "instructions": [ "vslo" ],
        "type_signatures": {
            "var_heads": [ "r", "a", "b", "Example Implementation" ],
            "list": [
                [ "vector signed char", "vector signed char", "vector signed char", "vslo  r,a,b" ],
                [ "vector signed char", "vector signed char", "vector unsigned char", "vslo  r,a,b" ],
                [ "vector unsigned char", "vector unsigned char", "vector signed char", "vslo  r,a,b" ],
                [ "vector unsigned char", "vector unsigned char", "vector unsigned char", "vslo  r,a,b" ],
                [ "vector signed short", "vector signed short", "vector signed char", "vslo  r,a,b" ],
                [ "vector signed short", "vector signed short", "vector unsigned char", "vslo  r,a,b" ],
                [ "vector unsigned short", "vector unsigned short", "vector signed char", "vslo  r,a,b" ],
                [ "vector unsigned short", "vector unsigned short", "vector unsigned char", "vslo  r,a,b" ],
                [ "vector pixel", "vector pixel", "vector signed char", "vslo  r,a,b" ],
                [ "vector pixel", "vector pixel", "vector unsigned char", "vslo  r,a,b" ],
                [ "vector signed int", "vector signed int", "vector signed char", "vslo  r,a,b" ],
                [ "vector signed int", "vector signed int", "vector unsigned char", "vslo  r,a,b" ],
                [ "vector unsigned int", "vector unsigned int", "vector signed char", "vslo  r,a,b" ],
                [ "vector unsigned int", "vector unsigned int", "vector unsigned char", "vslo  r,a,b" ],
                [ "vector signed long long", "vector signed long long", "vector signed char", "vslo  r,a,b" ],
                [ "vector signed long long", "vector signed long long", "vector unsigned char", "vslo  r,a,b" ],
                [ "vector unsigned long long", "vector unsigned long long", "vector signed char", "vslo  r,a,b" ],
                [ "vector unsigned long long", "vector unsigned long long", "vector unsigned char", "vslo  r,a,b" ],
                [ "vector float", "vector float", "vector signed char", "vslo  r,a,b" ],
                [ "vector float", "vector float", "vector unsigned char", "vslo  r,a,b" ]
            ]
        }
    },
    {
        "mnemonic": "vec_slv",
        "name": "Vector Shift Left Variable",
        "syntax": "r = vec_slv (a, b)",
        "purpose": "Left-shifts a vector by a varying number of bits by element.",
        "result": "Let v be a 17-byte vector formed from a in bytes [0:15] and a zero byte in element 16.\n      Then each byte element i of r is determined as follows.  The start bit\n      sb is obtained from bits 5:7 of byte element\n      i of b.  Then\n      the contents of bits sb:sb+7\n      of the halfword in byte elements\n      i:i+1 of v are placed into byte element\n      i of r.",
        "endianness": "All bit and byte element numbers are specified in big-endian order.\n      This intrinsic is not endian-neutral.",
        "instructions": [ "vslv" ],
        "type_signatures": {
            "var_heads": [ "r", "a", "b", "Example Implementation", "Restrictions" ],
            "list": [
                [ "vector unsigned char", "vector unsigned char", "vector unsigned char", "vslv  r,a,b", "ISA 3.0 or later" ]
            ]
        }
    },
    {
        "mnemonic": "vec_splat",
        "name": "Vector Splat",
        "syntax": "r = vec_splat (a, b)",
        "purpose": "Returns a vector that has all of its elements set to a given value.",
        "result": "The value of each\n      element of r is the value of the\n      element of a specified by b, which must be an element number less than the\n      number of elements supported for a's\n      type.",
        "endianness": "The element numbering within a register is left-to-right for big-endian\n      targets, and right-to-left for little-endian targets.",
        "instructions": [ "vspltb", "xxspltw", "xxpermdi", "vsplth" ],
        "type_signatures": {
            "var_heads": [ "r", "a", "b", "Example LE\nImplementation", "Example BE\nImplementation" ],
            "list": [
                [ "vector bool char", "vector bool char", "const int", "vspltb r,a,15-b", "vspltb r,a,b" ],
                [ "vector signed char", "vector signed char", "const int", "vspltb r,a,15-b", "vspltb r,a,b" ],
                [ "vector unsigned char", "vector unsigned char", "const int", "vspltb r,a,15-b", "vspltb r,a,b" ],
                [ "vector bool short", "vector bool short", "const int", "vsplth r,a,7-b", "vsplth r,a,b" ],
                [ "vector signed short", "vector signed short", "const int", "vsplth r,a,7-b", "vsplth r,a,b" ],
                [ "vector unsigned short", "vector unsigned short", "const int", "vsplth r,a,7-b", "vsplth r,a,b" ],
                [ "vector pixel", "vector pixel", "const int", "vsplth r,a,7-b", "vsplth r,a,b" ],
                [ "vector bool int", "vector bool int", "const int", "xxspltw r,a,3-b", "xxspltw r,a,b" ],
                [ "vector signed int", "vector signed int", "const int", "xxspltw r,a,3-b", "xxspltw r,a,b" ],
                [ "vector unsigned int", "vector unsigned int", "const int", "xxspltw r,a,3-b", "xxspltw r,a,b" ],
                [ "vector bool long long", "vector bool long long", "const int", "xxpermdi r,a,a,(1-b)*3", "xxpermdi r,a,a,b" ],
                [ "vector signed long long", "vector signed long long", "const int", "xxpermdi r,a,a,(1-b)*3", "xxpermdi r,a,a,b" ],
                [ "vector unsigned long long", "vector unsigned long long", "const int", "xxpermdi r,a,a,(1-b)*3", "xxpermdi r,a,a,b" ],
                [ "vector float", "vector float", "const int", "xxspltw r,a,3-b", "xxspltw r,a,b" ],
                [ "vector double", "vector double", "const int", "xxpermdi r,a,a,(1-b)*3", "xxpermdi r,a,a,b" ]
            ]
        }
    },
    {
        "mnemonic": "vec_splat_s8",
        "name": "Vector Splat to Signed Byte",
        "syntax": "r = vec_splat_s8 (a)",
        "purpose": "Returns a vector with all elements equal to the given value.",
        "result": "Each element of r is given the\n      sign-extended 5-bit value of a.\n      The range of this value is [-16:15].",
        "endianness": "None.",
        "instructions": [ "vspltisb" ],
        "type_signatures": {
            "var_heads": [ "r", "a", "Example Implementation" ],
            "list": [
                [ "vector signed char", "5-bit signed literal", "vspltisb  r,a" ]
            ]
        }
    },
    {
        "mnemonic": "vec_splat_s16",
        "name": "Vector Splat to Signed Halfword",
        "syntax": "r = vec_splat_s16 (a)",
        "purpose": "Returns a vector with all elements equal to the given value.",
        "result": "Each element of r is given the\n      sign-extended 5-bit value of a.\n      The range of this value is [-16:15].",
        "endianness": "None.",
        "instructions": [ "vspltish" ],
        "type_signatures": {
            "var_heads": [ "r", "a", "Example Implementation" ],
            "list": [
                [ "vector signed short", "5-bit signed literal", "vspltish  r,a" ]
            ]
        }
    },
    {
        "mnemonic": "vec_splat_s32",
        "name": "Vector Splat to Signed Word",
        "syntax": "r = vec_splat_s32 (a)",
        "purpose": "Returns a vector with all elements equal to the given value.",
        "result": "Each element of r is given the\n      sign-extended 5-bit value of a.\n      The range of this value is [-16:15].",
        "endianness": "None.",
        "instructions": [ "vspltisw" ],
        "type_signatures": {
            "var_heads": [ "r", "a", "Example Implementation" ],
            "list": [
                [ "vector signed int", "5-bit signed literal", "vspltisw  r,a" ]
            ]
        }
    },
    {
        "mnemonic": "vec_splat_u8",
        "name": "Vector Splat to Unsigned Byte",
        "syntax": "r = vec_splat_u8 (a)",
        "purpose": "Returns a vector with all elements equal to the given value.",
        "result": "The 5-bit signed value of a is\n      sign-extended to a byte and the resulting value is cast to an\n      unsigned char.  This value is placed in each element of\n      r.  The range of the original value is\n      [-16:15].",
        "endianness": "None.",
        "instructions": [ "vspltisb" ],
        "type_signatures": {
            "var_heads": [ "r", "a", "Example Implementation" ],
            "list": [
                [ "vector unsigned char", "5-bit signed literal", "vspltisb  r,a" ]
            ]
        }
    },
    {
        "mnemonic": "vec_splat_u16",
        "name": "Vector Splat to Unsigned Halfword",
        "syntax": "r = vec_splat_u16 (a)",
        "purpose": "Returns a vector with all elements equal to the given value.",
        "result": "The 5-bit signed value of a is\n      sign-extended to a halfword and the resulting value is cast to an\n      unsigned short.  This value is placed in each element of\n      r.  The range of the original value is\n      [-16:15].",
        "endianness": "None.",
        "instructions": [ "vspltish" ],
        "type_signatures": {
            "var_heads": [ "r", "a", "Example Implementation" ],
            "list": [
                [ "vector unsigned short", "5-bit signed literal", "vspltish  r,a" ]
            ]
        }
    },
    {
        "mnemonic": "vec_splat_u32",
        "name": "Vector Splat to Unsigned Word",
        "syntax": "r = vec_splat_u32 (a)",
        "purpose": "Returns a vector with all elements equal to the given value.",
        "result": "The 5-bit signed value of a is\n      sign-extended to a word and the resulting value is cast to an\n      unsigned int.  This value is placed in each element of\n      r.  The range of the original value is\n      [-16:15].",
        "endianness": "None.",
        "instructions": [ "vspltisw" ],
        "type_signatures": {
            "var_heads": [ "r", "a", "Example Implementation" ],
            "list": [
                [ "vector unsigned int", "5-bit signed literal", "vspltisw  r,a" ]
            ]
        }
    },
    {
        "mnemonic": "vec_splats",
        "name": "Vector Splat Scalar",
        "syntax": "r = vec_splats (a)",
        "purpose": "Returns a vector with the value of each element set to the value of\n      the scalar input parameter.",
        "result": "Each element of\n      r is set to the value of a.",
        "endianness": "None.",
        "instructions": [ "rlwinm", "mtvsrd", "vspltb", "mtvsrwz", "xxspltw", "xxpermdi", "vsplth", "xxscvdpspn" ],
        "type_signatures": {
            "var_heads": [ "r", "a", "Example Implementation" ],
            "list": [
                [ "vector signed char", "signed char", "rlwinm  t,a,0,0xff\n  mtvsrd  u,t\n  vspltb  r,u,7" ],
                [ "vector unsigned char", "unsigned char", "rlwinm  t,a,0,0xff\n  mtvsrd  u,t\n  vspltb  r,u,7" ],
                [ "vector signed short", "signed short", "rlwinm  t,a,0,0xffff\n  mtvsrd  u,t\n  vsplth  r,u,3" ],
                [ "vector unsigned short", "unsigned short", "rlwinm  t,a,0,0xffff\n  mtvsrd  u,t\n  vsplth  r,u,3" ],
                [ "vector signed int", "signed int", "mtvsrd  t,a\n  vspltb  r,t,7" ],
                [ "vector unsigned int", "unsigned int", "mtvsrd  t,a\n  vspltb  r,t,7" ],
                [ "vector signed long long", "signed long long", "mtvsrd    t,a\n  xxpermdi  r,t,t,0" ],
                [ "vector unsigned long long", "unsigned long long", "mtvsrd    t,a\n  xxpermdi  r,t,t,0" ],
                [ "vector signed __int128", "signed __int128", "mtvsrwz  t,a\n  xxspltw  r,t,1" ],
                [ "vector unsigned __int128", "unsigned __int128", "mtvsrwz  t,a\n  xxspltw  r,t,1" ],
                [ "vector float", "float", "xxscvdpspn  t,a\n  xxspltw     r,t,0" ],
                [ "vector double", "double", "xxpermdi  r,a,a,0" ]
            ]
        }
    },
    {
        "mnemonic": "vec_sqrt",
        "name": "Vector Square Root",
        "syntax": "r = vec_sqrt (a)",
        "purpose": "Returns a vector containing the square root of each element in the\n      source vector.",
        "result": "Each element of\n      r is the square root of the\n      corresponding element of a.",
        "endianness": "None.",
        "instructions": [ "xvsqrtdp", "xvsqrtsp" ],
        "type_signatures": {
            "var_heads": [ "r", "a", "Example Implementation" ],
            "list": [
                [ "vector float", "vector float", "xvsqrtsp  r,a" ],
                [ "vector double", "vector double", "xvsqrtdp  r,a" ]
            ]
        }
    },
    {
        "mnemonic": "vec_sr",
        "name": "Vector Shift Right",
        "syntax": "r = vec_sr (a, b)",
        "purpose": "Performs a logical right shift for each element of a vector.",
        "result": "Each element of\n      r is the result of logically\n      right-shifting the corresponding element of a by the number of bits specified by the\n      corresponding element of b, modulo the\n      number of bits in the element. Zeros are shifted in from the\n      left.",
        "endianness": "None.",
        "instructions": [ "vsrb", "vsrw", "vsrd", "vsrh" ],
        "type_signatures": {
            "var_heads": [ "r", "a", "b", "Example Implementation" ],
            "list": [
                [ "vector signed char", "vector signed char", "vector unsigned char", "vsrb  r,a,b" ],
                [ "vector unsigned char", "vector unsigned char", "vector unsigned char", "vsrb  r,a,b" ],
                [ "vector signed short", "vector signed short", "vector unsigned short", "vsrh  r,a,b" ],
                [ "vector unsigned short", "vector unsigned short", "vector unsigned short", "vsrh  r,a,b" ],
                [ "vector signed int", "vector signed int", "vector unsigned int", "vsrw  r,a,b" ],
                [ "vector unsigned int", "vector unsigned int", "vector unsigned int", "vsrw  r,a,b" ],
                [ "vector signed long long", "vector signed long long", "vector unsigned long long", "vsrd  r,a,b" ],
                [ "vector unsigned long long", "vector unsigned long long", "vector unsigned long long", "vsrd  r,a,b" ]
            ]
        }
    },
    {
        "mnemonic": "vec_sra",
        "name": "Vector Shift Right Algebraic",
        "syntax": "r = vec_sra (a, b)",
        "purpose": "Performs an algebraic right shift for each element of a vector.",
        "result": "Each element of\n      r is the result of algebraically\n      right-shifting the corresponding element of a by the number of bits specified by the\n      corresponding element of b, modulo the\n      number of bits in the element. Copies of the sign bit are shifted in\n      from the left.",
        "endianness": "None.",
        "instructions": [ "vsrab", "vsraw", "vsrad", "vsrah" ],
        "type_signatures": {
            "var_heads": [ "r", "a", "b", "Example Implementation" ],
            "list": [
                [ "vector signed char", "vector signed char", "vector unsigned char", "vsrab  r,a,b" ],
                [ "vector unsigned char", "vector unsigned char", "vector unsigned char", "vsrab  r,a,b" ],
                [ "vector signed short", "vector signed short", "vector unsigned short", "vsrah  r,a,b" ],
                [ "vector unsigned short", "vector unsigned short", "vector unsigned short", "vsrah  r,a,b" ],
                [ "vector signed int", "vector signed int", "vector unsigned int", "vsraw  r,a,b" ],
                [ "vector unsigned int", "vector unsigned int", "vector unsigned int", "vsraw  r,a,b" ],
                [ "vector signed long long", "vector signed long long", "vector unsigned long long", "vsrad  r,a,b" ],
                [ "vector unsigned long long", "vector unsigned long long", "vector unsigned long long", "vsrad  r,a,b" ]
            ]
        }
    },
    {
        "mnemonic": "vec_srl",
        "name": "Vector Shift Right Long",
        "syntax": "r = vec_srl (a, b)",
        "purpose": "Right shifts a vector by a given number of bits.",
        "result": "Vector r contains the contents of a, shifted right by the number of bits specified\n      by the 3 least-significant bits of b.\n      Zeros are supplied on the left. The shift count must have been\n      replicated into all bytes of b; if not,\n      the value of r is undefined.",
        "endianness": "This intrinsic is not endian-neutral, so uses of\n      vec_srl in big-endian code must be rewritten for little-endian targets.",
        "instructions": [ "vsr" ],
        "type_signatures": {
            "var_heads": [ "r", "a", "b", "Example Implementation" ],
            "list": [
                [ "vector signed char", "vector signed char", "vector unsigned char", "vsr  r,a,b" ],
                [ "vector unsigned char", "vector unsigned char", "vector unsigned char", "vsr  r,a,b" ],
                [ "vector signed short", "vector signed short", "vector unsigned char", "vsr  r,a,b" ],
                [ "vector unsigned short", "vector unsigned short", "vector unsigned char", "vsr  r,a,b" ],
                [ "vector pixel", "vector pixel", "vector unsigned char", "vsr  r,a,b" ],
                [ "vector signed int", "vector signed int", "vector unsigned char", "vsr  r,a,b" ],
                [ "vector unsigned int", "vector unsigned int", "vector unsigned char", "vsr  r,a,b" ],
                [ "vector signed long long", "vector signed long long", "vector unsigned char", "vsr  r,a,b" ],
                [ "vector unsigned long long", "vector unsigned long long", "vector unsigned char", "vsr  r,a,b" ]
            ]
        }
    },
    {
        "mnemonic": "vec_sro",
        "name": "Vector Shift Right by Octets",
        "syntax": "r = vec_sro (a, b)",
        "purpose": "Right shifts a vector by a given number of bytes (octets).",
        "result": "Vector\n      r receives the contents of\n      a, shifted right by the number of bytes\n      specified by bits 1–4 of the least-significant byte of\n      b.\n      Zeros are supplied from the left.",
        "endianness": "",
        "instructions": [ "vsro" ],
        "type_signatures": {
            "var_heads": [ "r", "a", "b", "Example Implementation" ],
            "list": [
                [ "vector signed char", "vector signed char", "vector signed char", "vsro  r,a,b" ],
                [ "vector signed char", "vector signed char", "vector unsigned char", "vsro  r,a,b" ],
                [ "vector unsigned char", "vector unsigned char", "vector signed char", "vsro  r,a,b" ],
                [ "vector unsigned char", "vector unsigned char", "vector unsigned char", "vsro  r,a,b" ],
                [ "vector signed short", "vector signed short", "vector signed char", "vsro  r,a,b" ],
                [ "vector signed short", "vector signed short", "vector unsigned char", "vsro  r,a,b" ],
                [ "vector unsigned short", "vector unsigned short", "vector signed char", "vsro  r,a,b" ],
                [ "vector unsigned short", "vector unsigned short", "vector unsigned char", "vsro  r,a,b" ],
                [ "vector pixel", "vector pixel", "vector signed char", "vsro  r,a,b" ],
                [ "vector pixel", "vector pixel", "vector unsigned char", "vsro  r,a,b" ],
                [ "vector signed int", "vector signed int", "vector signed char", "vsro  r,a,b" ],
                [ "vector signed int", "vector signed int", "vector unsigned char", "vsro  r,a,b" ],
                [ "vector unsigned int", "vector unsigned int", "vector signed char", "vsro  r,a,b" ],
                [ "vector unsigned int", "vector unsigned int", "vector unsigned char", "vsro  r,a,b" ],
                [ "vector signed long long", "vector signed long long", "vector signed char", "vsro  r,a,b" ],
                [ "vector signed long long", "vector signed long long", "vector unsigned char", "vsro  r,a,b" ],
                [ "vector unsigned long long", "vector unsigned long long", "vector signed char", "vsro  r,a,b" ],
                [ "vector unsigned long long", "vector unsigned long long", "vector unsigned char", "vsro  r,a,b" ],
                [ "vector float", "vector float", "vector signed char", "vsro  r,a,b" ],
                [ "vector float", "vector float", "vector unsigned char", "vsro  r,a,b" ]
            ]
        }
    },
    {
        "mnemonic": "vec_srv",
        "name": "Vector Shift Right Variable",
        "syntax": "r = vec_srv (a, b)",
        "purpose": "Right-shifts a vector by a varying number of bits by element.",
        "result": "Let v be a 17-byte vector formed from a zero byte\n      in element 0 and the elements of a\n      in bytes [1:16].  Then each byte element i of\n      r is determined as follows.  The\n      start bit sb is obtained from bits 5:7 of\n      byte element i of b.  Then the contents of bits\n      (8 – sb):(15 – sb) of the\n      halfword in byte elements i:i+1\n      of v are placed into byte element\n      i of r.",
        "endianness": "All bit and byte element numbers are specified in big-endian order.\n      This intrinsic is not endian-neutral.",
        "instructions": [ "vsrv" ],
        "type_signatures": {
            "var_heads": [ "r", "a", "b", "Example Implementation", "Restrictions" ],
            "list": [
                [ "vector unsigned char", "vector unsigned char", "vector unsigned char", "vsrv  r,a,b", "ISA 3.0 or later" ]
            ]
        }
    },
    {
        "mnemonic": "vec_st",
        "name": "Vector Store Indexed",
        "syntax": "vec_st (a, b, c)",
        "purpose": "Stores a 16-byte vector into memory at the address specified by a\n      displacement and a pointer, ignoring the four low-order bits\n      of the calculated address.",
        "result": "A memory address\n      is obtained by adding b and c, and masking off the four low-order bits of the\n      result.  The 16-byte vector in a is\n      stored to the resultant memory address.",
        "endianness": "None.",
        "instructions": [ "stvx" ],
        "type_signatures": {
            "var_heads": [ "a", "b", "c", "Example ISA 3.0\nImplementation" ],
            "list": [
                [ "vector bool char", "signed long long", "vector bool char *", "stvx  r,b,a" ],
                [ "vector bool char", "signed long long", "signed char *", "stvx  r,b,a" ],
                [ "vector bool char", "signed long long", "unsigned char *", "stvx  r,b,a" ],
                [ "vector signed char", "signed long long", "signed char *", "stvx  r,b,a" ],
                [ "vector signed char", "signed long long", "vector signed char *", "stvx  r,b,a" ],
                [ "vector unsigned char", "signed long long", "unsigned char *", "stvx  r,b,a" ],
                [ "vector unsigned char", "signed long long", "vector unsigned char *", "stvx  r,b,a" ],
                [ "vector bool short", "signed long long", "vector bool short *", "stvx  r,b,a" ],
                [ "vector bool short", "signed long long", "signed short *", "stvx  r,b,a" ],
                [ "vector bool short", "signed long long", "unsigned short *", "stvx  r,b,a" ],
                [ "vector signed short", "signed long long", "signed short *", "stvx  r,b,a" ],
                [ "vector signed short", "signed long long", "vector signed short *", "stvx  r,b,a" ],
                [ "vector unsigned short", "signed long long", "unsigned short *", "stvx  r,b,a" ],
                [ "vector unsigned short", "signed long long", "vector unsigned short *", "stvx  r,b,a" ],
                [ "vector pixel", "signed long long", "vector pixel *", "stvx  r,b,a" ],
                [ "vector bool int", "signed long long", "vector bool int *", "stvx  r,b,a" ],
                [ "vector bool int", "signed long long", "signed int *", "stvx  r,b,a" ],
                [ "vector bool int", "signed long long", "unsigned int *", "stvx  r,b,a" ],
                [ "vector signed int", "signed long long", "signed int *", "stvx  r,b,a" ],
                [ "vector signed int", "signed long long", "vector signed int *", "stvx  r,b,a" ],
                [ "vector unsigned int", "signed long long", "unsigned int *", "stvx  r,b,a" ],
                [ "vector unsigned int", "signed long long", "vector unsigned int *", "stvx  r,b,a" ],
                [ "vector bool long long", "signed long long", "vector bool long long *", "stvx  r,b,a" ],
                [ "vector signed long long", "signed long long", "signed long long *", "stvx  r,b,a" ],
                [ "vector signed long long", "signed long long", "vector signed long long *", "stvx  r,b,a" ],
                [ "vector unsigned long long", "signed long long", "unsigned long long *", "stvx  r,b,a" ],
                [ "vector unsigned long long", "signed long long", "vector unsigned long long *", "stvx  r,b,a" ],
                [ "vector float", "signed long long", "float *", "stvx  r,b,a" ],
                [ "vector float", "signed long long", "vector float *", "stvx  r,b,a" ],
                [ "vector double", "signed long long", "double *", "stvx  r,b,a" ],
                [ "vector double", "signed long long", "vector double *", "stvx  r,b,a" ]
            ]
        }
    },
    {
        "mnemonic": "vec_ste",
        "name": "Vector Store Element Indexed",
        "syntax": "vec_ste (a, b, c)",
        "purpose": "Stores a single element from a 16-byte vector into memory at the address\n      specified by a displacement and a pointer, aligned to the element size.",
        "result": "The integer value\n      b is added to the pointer value\n      c.  The resulting address is rounded\n      down to the nearest address that is a multiple of\n      es, where es is 1 for char\n      pointers, 2 for short pointers, and 4 for float or int pointers.\n      An element offset eo is calculated by taking the\n      resultant address modulo 16.  The vector element of a at offset eo is stored\n      to the resultant address.",
        "endianness": "None.",
        "instructions": [ "stvebx", "stvewx", "stvehx" ],
        "type_signatures": {
            "var_heads": [ "a", "b", "c", "Example ISA 3.0\nImplementation" ],
            "list": [
                [ "vector bool char", "signed long long", "signed char *", "stvebx  r,b,a" ],
                [ "vector bool char", "signed long long", "unsigned char *", "stvebx  r,b,a" ],
                [ "vector signed char", "signed long long", "signed char *", "stvebx  r,b,a" ],
                [ "vector unsigned char", "signed long long", "unsigned char *", "stvebx  r,b,a" ],
                [ "vector bool short", "signed long long", "signed short *", "stvehx  r,b,a" ],
                [ "vector bool short", "signed long long", "unsigned short *", "stvehx  r,b,a" ],
                [ "vector signed short", "signed long long", "signed short *", "stvehx  r,b,a" ],
                [ "vector unsigned short", "signed long long", "unsigned short *", "stvehx  r,b,a" ],
                [ "vector pixel", "signed long long", "unsigned short *", "stvehx  r,b,a" ],
                [ "vector bool int", "signed long long", "signed int *", "stvewx  r,b,a" ],
                [ "vector bool int", "signed long long", "unsigned int *", "stvewx  r,b,a" ],
                [ "vector signed int", "signed long long", "signed int *", "stvewx  r,b,a" ],
                [ "vector unsigned int", "signed long long", "unsigned int *", "stvewx  r,b,a" ],
                [ "vector float", "signed long long", "float *", "stvewx  r,b,a" ]
            ]
        }
    },
    {
        "mnemonic": "vec_stl",
        "name": "Vector Store Indexed Least Recently Used",
        "syntax": "vec_stl (a, b, c)",
        "purpose": "Stores a 16-byte vector into memory at the address specified by a\n      displacement and a pointer, ignoring the four low-order bits\n      of the calculated address, and marking the cache line containing\n      the address as least frequently used.",
        "result": "A memory address\n      is obtained by adding b and c, and masking off the four low-order bits of the\n      result.  The 16-byte vector in a is\n      stored to the resultant memory address, and the containing cache\n      line is marked as least frequently used.",
        "endianness": "None.",
        "instructions": [ "stvxl" ],
        "type_signatures": {
            "var_heads": [ "a", "b", "c", "Example ISA 3.0\nImplementation" ],
            "list": [
                [ "vector bool char", "signed long long", "vector bool char *", "stvxl  r,b,a" ],
                [ "vector bool char", "signed long long", "signed char *", "stvxl  r,b,a" ],
                [ "vector bool char", "signed long long", "unsigned char *", "stvxl  r,b,a" ],
                [ "vector signed char", "signed long long", "signed char *", "stvxl  r,b,a" ],
                [ "vector signed char", "signed long long", "vector signed char *", "stvxl  r,b,a" ],
                [ "vector unsigned char", "signed long long", "unsigned char *", "stvxl  r,b,a" ],
                [ "vector unsigned char", "signed long long", "vector unsigned char *", "stvxl  r,b,a" ],
                [ "vector bool short", "signed long long", "vector bool short *", "stvxl  r,b,a" ],
                [ "vector bool short", "signed long long", "signed short *", "stvxl  r,b,a" ],
                [ "vector bool short", "signed long long", "unsigned short *", "stvxl  r,b,a" ],
                [ "vector signed short", "signed long long", "signed short *", "stvxl  r,b,a" ],
                [ "vector signed short", "signed long long", "vector signed short *", "stvxl  r,b,a" ],
                [ "vector unsigned short", "signed long long", "unsigned short *", "stvxl  r,b,a" ],
                [ "vector unsigned short", "signed long long", "vector unsigned short *", "stvxl  r,b,a" ],
                [ "vector pixel", "signed long long", "vector pixel *", "stvxl  r,b,a" ],
                [ "vector bool int", "signed long long", "vector bool int *", "stvxl  r,b,a" ],
                [ "vector bool int", "signed long long", "signed int *", "stvxl  r,b,a" ],
                [ "vector bool int", "signed long long", "unsigned int *", "stvxl  r,b,a" ],
                [ "vector signed int", "signed long long", "signed int *", "stvxl  r,b,a" ],
                [ "vector signed int", "signed long long", "vector signed int *", "stvxl  r,b,a" ],
                [ "vector unsigned int", "signed long long", "unsigned int *", "stvxl  r,b,a" ],
                [ "vector unsigned int", "signed long long", "vector unsigned int *", "stvxl  r,b,a" ],
                [ "vector bool long long", "signed long long", "vector bool long long *", "stvxl  r,b,a" ],
                [ "vector signed long long", "signed long long", "signed long long *", "stvxl  r,b,a" ],
                [ "vector signed long long", "signed long long", "vector signed long long *", "stvxl  r,b,a" ],
                [ "vector unsigned long long", "signed long long", "unsigned long long *", "stvxl  r,b,a" ],
                [ "vector unsigned long long", "signed long long", "vector unsigned long long *", "stvxl  r,b,a" ],
                [ "vector float", "signed long long", "float *", "stvxl  r,b,a" ],
                [ "vector float", "signed long long", "vector float *", "stvxl  r,b,a" ],
                [ "vector double", "signed long long", "double *", "stvxl  r,b,a" ],
                [ "vector double", "signed long long", "vector double *", "stvxl  r,b,a" ]
            ]
        }
    },
    {
        "mnemonic": "vec_sub",
        "name": "Vector Subtract",
        "syntax": "r = vec_sub (a, b)",
        "purpose": "Returns a vector containing the result of subtracting each element of\n      one source vector from the corresponding element of another source\n      vector.",
        "result": "The value of each\n      element of r is the result of\n      subtracting the value of the corresponding element of b from the value of the corresponding element of\n      a. The arithmetic is modular for\n      integer vectors.",
        "endianness": "None.",
        "instructions": [ "vsububm", "vsubuwm", "vsubuqm", "vsubudm", "vsubuhm", "xvsubdp", "xvsubsp" ],
        "type_signatures": {
            "var_heads": [ "r", "a", "b", "Example Implementation" ],
            "list": [
                [ "vector signed char", "vector signed char", "vector signed char", "vsububm  r,a,b" ],
                [ "vector unsigned char", "vector unsigned char", "vector unsigned char", "vsububm  r,a,b" ],
                [ "vector signed short", "vector signed short", "vector signed short", "vsubuhm  r,a,b" ],
                [ "vector unsigned short", "vector unsigned short", "vector unsigned short", "vsubuhm  r,a,b" ],
                [ "vector signed int", "vector signed int", "vector signed int", "vsubuwm  r,a,b" ],
                [ "vector unsigned int", "vector unsigned int", "vector unsigned int", "vsubuwm  r,a,b" ],
                [ "vector signed long long", "vector signed long long", "vector signed long long", "vsubudm  r,a,b" ],
                [ "vector unsigned long long", "vector unsigned long long", "vector unsigned long long", "vsubudm  r,a,b" ],
                [ "vector signed __int128", "vector signed __int128", "vector signed __int128", "vsubuqm  r,a,b" ],
                [ "vector unsigned __int128", "vector unsigned __int128", "vector unsigned __int128", "vsubuqm  r,a,b" ],
                [ "vector float", "vector float", "vector float", "xvsubsp  r,a,b" ],
                [ "vector double", "vector double", "vector double", "xvsubdp  r,a,b" ]
            ]
        }
    },
    {
        "mnemonic": "vec_subc",
        "name": "Vector Subtract Carryout",
        "syntax": "r = vec_subc (a, b)",
        "purpose": "Returns a vector wherein each element contains the carry\n      produced by subtracting the corresponding elements of the two\n      source vectors.",
        "result": "The value of each\n      element of r is the complement of the\n      carry produced by subtracting the value of the corresponding element of\n      b from the value of the corresponding\n      element of a. The value is 0 if a\n      borrow occurred, or 1 if no borrow occurred.",
        "endianness": "None.",
        "instructions": [ "vsubcuw", "vsubcuq" ],
        "type_signatures": {
            "var_heads": [ "r", "a", "b", "Example Implementation" ],
            "list": [
                [ "vector signed int", "vector signed int", "vector signed int", "vsubcuw  r,a,b" ],
                [ "vector unsigned int", "vector unsigned int", "vector unsigned int", "vsubcuw  r,a,b" ],
                [ "vector signed __int128", "vector signed __int128", "vector signed __int128", "vsubcuq  r,a,b" ],
                [ "vector unsigned __int128", "vector unsigned __int128", "vector unsigned __int128", "vsubcuq  r,a,b" ]
            ]
        }
    },
    {
        "mnemonic": "vec_sube",
        "name": "Vector Subtract Extended",
        "syntax": "r = vec_sube (a, b, c)",
        "purpose": "Returns a vector containing the result of first elementwise subtracting\n      one vector from another vector, and then elementwise adding a third\n      carry vector. Elements of the carry vector have a value of 0 or 1.",
        "result": "Let c' be a vector for which each element is 0 if\n      the rightmost bit of the corresponding element of c is 0, and 1 otherwise. Then the value of each\n      element of r is produced by subtracting\n      the corresponding element of b from the\n      corresponding element of a, and then\n      adding the corresponding element of c'.",
        "endianness": "None.",
        "instructions": [ "vspltisw", "vsubuwm", "xxland", "vsubeuqm" ],
        "type_signatures": {
            "var_heads": [ "r", "a", "b", "c", "Example Implementation" ],
            "list": [
                [ "vector signed int", "vector signed int", "vector signed int", "vector signed int", "vspltisw  t,1\n  vsubuwm   u,a,b\n  xxland    v,c,t\n  vsubuwm   r,u,v" ],
                [ "vector unsigned int", "vector unsigned int", "vector unsigned int", "vector unsigned int", "vspltisw  t,1\n  vsubuwm   u,a,b\n  xxland    v,c,t\n  vsubuwm   r,u,v" ],
                [ "vector signed __int128", "vector signed __int128", "vector signed __int128", "vector signed __int128", "vsubeuqm  r,a,b,c" ],
                [ "vector unsigned __int128", "vector unsigned __int128", "vector unsigned __int128", "vector unsigned __int128", "vsubeuqm  r,a,b,c" ]
            ]
        }
    },
    {
        "mnemonic": "vec_subec",
        "name": "Vector Subtract Extended Carryout",
        "syntax": "r = vec_subec (a, b, c)",
        "purpose": "Returns a vector containing the carries produced by subtracting one\n      vector from another, then adding a third vector to the difference.  The\n      third vector is a carry vector, with each element having a value of 0\n      or 1.",
        "result": "The value of each\n      element of r is the carry produced by\n      subtracting the corresponding element of b from the corresponding element of a, and then adding the carry specified in the\n      corresponding element of c (1 if there\n      is a carry, 0 otherwise).",
        "endianness": "None.",
        "instructions": [ "vspltisw", "xxland", "vsubuwm", "vsubcuw", "xxlor", "vsubecuq" ],
        "type_signatures": {
            "var_heads": [ "r", "a", "b", "c", "Example Implementation" ],
            "list": [
                [ "vector signed int", "vector signed int", "vector signed int", "vector signed int", "vspltisw  t,1\n  xxland    u,c,t\n  vsubuwm   v,a,b\n  vsubcuw   w,a,b\n  vsubcuw   x,v,u\n  xxlor     r,w,x" ],
                [ "vector unsigned int", "vector unsigned int", "vector unsigned int", "vector unsigned int", "vspltisw  t,1\n  xxland    u,c,t\n  vsubuwm   v,a,b\n  vsubcuw   w,a,b\n  vsubcuw   x,v,u\n  xxlor     r,w,x" ],
                [ "vector signed __int128", "vector signed __int128", "vector signed __int128", "vector signed __int128", "vsubecuq  r,a,b,c" ],
                [ "vector unsigned __int128", "vector unsigned __int128", "vector unsigned __int128", "vector unsigned __int128", "vsubecuq  r,a,b,c" ]
            ]
        }
    },
    {
        "mnemonic": "vec_subs",
        "name": "Vector Subtract Saturated",
        "syntax": "r = vec_subs (a, b)",
        "purpose": "Returns a vector containing the saturated differences of each set of\n      corresponding elements of the source vectors.",
        "result": "The value of each\n      element of r is the saturated result of\n      subtracting the value of the corresponding element of b from the value of the corresponding element of\n      a.",
        "endianness": "None.",
        "instructions": [ "vsubsbs", "vsububs", "vsubsws", "vsubuws", "vsubshs", "vsubuhs" ],
        "type_signatures": {
            "var_heads": [ "r", "a", "b", "Example Implementation" ],
            "list": [
                [ "vector signed char", "vector signed char", "vector signed char", "vsubsbs  r,a,b" ],
                [ "vector unsigned char", "vector unsigned char", "vector unsigned char", "vsububs  r,a,b" ],
                [ "vector signed short", "vector signed short", "vector signed short", "vsubshs  r,a,b" ],
                [ "vector unsigned short", "vector unsigned short", "vector unsigned short", "vsubuhs  r,a,b" ],
                [ "vector signed int", "vector signed int", "vector signed int", "vsubsws  r,a,b" ],
                [ "vector unsigned int", "vector unsigned int", "vector unsigned int", "vsubuws  r,a,b" ]
            ]
        }
    },
    {
        "mnemonic": "vec_sum2s",
        "name": "Vector Sum Across Half",
        "syntax": "r = vec_sum2s (a, b)",
        "purpose": "Returns a vector containing the results of performing a sum-across\n      operation within each doubleword of the first source vector together with\n      accumulated results in the second source vector.",
        "result": "Elements 0 and 2\n      of r are 0. Element 1 of r contains the saturated sum of elements 0 and 1\n      of a and element 1 of b. Element 3 of r contains the saturated sum of elements 2 and 3\n      of a and element 3 of b.",
        "endianness": "The element numbering within a register is left-to-right for big-endian\n      targets, and right-to-left for little-endian targets.",
        "instructions": [ "vsldoi", "vsum2sws" ],
        "type_signatures": {
            "var_heads": [ "r", "a", "b", "Example LE\nImplementation", "Example BE\nImplementation" ],
            "list": [
                [ "vector signed int", "vector signed int", "vector signed int", "vsldoi    t,b,b,12\n  vsum2sws  u,a,t\n  vsldoi    r,u,u,4", "vsum2sws  r,a,b" ]
            ]
        }
    },
    {
        "mnemonic": "vec_sum4s",
        "name": "Vector Sum Across Quarter",
        "syntax": "r = vec_sum4s (a, b)",
        "purpose": "Returns a vector containing the results of performing a sum-across\n      operation within each word of the first source vector together with\n      accumulated results in the second source vector.",
        "result": "",
        "endianness": "None.",
        "instructions": [ "vsum4sbs", "vsum4shs", "vsum4ubs" ],
        "type_signatures": {
            "var_heads": [ "r", "a", "b", "Example\nImplementation" ],
            "list": [
                [ "vector signed int", "vector signed char", "vector signed int", "vsum4sbs  r,a,b" ],
                [ "vector unsigned int", "vector unsigned char", "vector unsigned int", "vsum4ubs  r,a,b" ],
                [ "vector signed int", "vector signed short", "vector signed int", "vsum4shs  r,a,b" ]
            ]
        }
    },
    {
        "mnemonic": "vec_sums",
        "name": "Vector Sum Across",
        "syntax": "r = vec_sums (a, b)",
        "purpose": "Returns a vector containing the results of performing a sum-across\n      operation on the first source vector together with accumulated results\n      in the second source vector.",
        "result": "Elements 0, 1, and 2\n      of r are 0. Element 3 is the saturated\n      sum of all the elements of a and\n      element 3 of b.",
        "endianness": "The element numbering within a register is left-to-right for big-endian\n      targets, and right-to-left for little-endian targets.",
        "instructions": [ "vspltw", "vsumsws", "vsldoi" ],
        "type_signatures": {
            "var_heads": [ "r", "a", "b", "Example LE\nImplementation", "Example BE\nImplementation" ],
            "list": [
                [ "vector signed int", "vector signed int", "vector signed int", "vspltw   t,b,0\n  vsumsws  u,a,t\n  vsldoi   r,u,u,12", "vsumsws  r,a,b" ]
            ]
        }
    },
    {
        "mnemonic": "vec_test_data_class",
        "name": "Vector Test Data Class",
        "syntax": "r = vec_test_data_class (a, b)",
        "purpose": "Determines the data class for each floating-point element.",
        "result": "",
        "endianness": "None.",
        "instructions": [ "xvtstdcsp", "xvtstdcdp" ],
        "type_signatures": {
            "var_heads": [ "r", "a", "b", "Example Implementation", "Restrictions" ],
            "list": [
                [ "vector bool int", "vector float", "7-bit unsigned literal", "xvtstdcsp  r,a,b", "ISA 3.0 or later" ],
                [ "vector bool long long", "vector double", "7-bit unsigned literal", "xvtstdcdp  r,a,b", "ISA 3.0 or later" ]
            ]
        }
    },
    {
        "mnemonic": "vec_trunc",
        "name": "Vector Truncate",
        "syntax": "r = vec_trunc (a)",
        "purpose": "Returns a vector containing the truncated values of the corresponding\n      elements of the source vector.",
        "result": "Each element of\n      r contains the value of the\n      corresponding element of a, truncated\n      to an integral value.",
        "endianness": "None.",
        "instructions": [ "xvrdpiz", "xvrspiz" ],
        "type_signatures": {
            "var_heads": [ "r", "a", "Example Implementation" ],
            "list": [
                [ "vector float", "vector float", "xvrspiz  r,a" ],
                [ "vector double", "vector double", "xvrdpiz  r,a" ]
            ]
        }
    },
    {
        "mnemonic": "vec_unpackh",
        "name": "Vector Unpack High",
        "syntax": "r = vec_unpackh (a)",
        "purpose": "Unpacks the most-significant (“high”) half of a vector into a vector\n      with larger elements.",
        "result": "If a is an integer vector, the value of each element\n      of r is the value of the corresponding\n      element of the most-significant half of a.",
        "endianness": "The &quot;high&quot; half of a vector with n elements is the\n      first n/2 elements of the vector.  For little\n      endian, these elements are in the rightmost half of the vector.  For\n      big endian, these elements are in the leftmost half of the vector.",
        "instructions": [ "vupklsh", "vupkhsh", "vupklpx", "vupkhpx", "vupklsw", "vupkhsw", "vupklsb", "vupkhsb", "xxsldwi", "xvcvspdp" ],
        "type_signatures": {
            "var_heads": [ "r", "a", "Example LE\nImplementation", "Example BE\nImplementation" ],
            "list": [
                [ "vector bool short", "vector bool char", "vupklsb  r,a", "vupkhsb  r,a" ],
                [ "vector signed short", "vector signed char", "vupklsb  r,a", "vupkhsb  r,a" ],
                [ "vector bool int", "vector bool short", "vupklsh  r,a", "vupkhsh  r,a" ],
                [ "vector signed int", "vector signed short", "vupklsh  r,a", "vupkhsh  r,a" ],
                [ "vector unsigned int", "vector pixel", "vupklpx  r,a", "vupkhpx  r,a" ],
                [ "vector bool long long", "vector bool int", "vupklsw  r,a", "vupkhsw  r,a" ],
                [ "vector signed long long", "vector signed int", "vupklsw  r,a", "vupkhsw  r,a" ],
                [ "vector double", "vector float", "xxsldwi  t,a,a,3\n xxsldwi  u,a,t,2\n xvcvspdp r,u", "xxsldwi   t,a,a,1\n xxsldwi   u,t,a,3\n xvcvspdp  r,u" ]
            ]
        }
    },
    {
        "mnemonic": "vec_unpackl",
        "name": "Vector Unpack Low",
        "syntax": "r = vec_unpackl (a)",
        "purpose": "Unpacks the least-significant (“low”) half of a vector into a vector\n      with larger elements.",
        "result": "If a is an integer vector, the value of each element\n      of r is the value of the corresponding\n      element of the least-significant half of a.",
        "endianness": "The &quot;high&quot; half of a vector with n elements is the\n      first n/2 elements of the vector.  For little\n      endian, these elements are in the rightmost half of the vector.  For\n      big endian, these elements are in the leftmost half of the vector.",
        "instructions": [ "vupkhsh", "vupklsh", "vupkhpx", "vupklpx", "vupkhsw", "vupklsw", "vupkhsb", "vupklsb", "xxsldwi", "xvcvspdp" ],
        "type_signatures": {
            "var_heads": [ "r", "a", "Example LE\nImplementation", "Example BE\nImplementation" ],
            "list": [
                [ "vector bool short", "vector bool char", "vupkhsb  r,a", "vupklsb  r,a" ],
                [ "vector signed short", "vector signed char", "vupkhsb  r,a", "vupklsb  r,a" ],
                [ "vector bool int", "vector bool short", "vupkhsh  r,a", "vupklsh  r,a" ],
                [ "vector signed int", "vector signed short", "vupkhsh  r,a", "vupklsh  r,a" ],
                [ "vector unsigned int", "vector pixel", "vupkhpx  r,a", "vupklpx  r,a" ],
                [ "vector bool long long", "vector bool int", "vupkhsw  r,a", "vupklsw  r,a" ],
                [ "vector signed long long", "vector signed int", "vupkhsw  r,a", "vupklsw  r,a" ],
                [ "vector double", "vector float", "xxsldwi   t,a,a,1\n xxsldwi   u,t,a,3\n xvcvspdp  r,u", "xxsldwi   t,a,a,3\n xxsldwi   u,a,t,2\n xvcvspdp  r,u" ]
            ]
        }
    },
    {
        "mnemonic": "vec_unsigned",
        "name": "Vector Convert Floating-Point to Unsigned Integer",
        "syntax": "r = vec_unsigned (a)",
        "purpose": "Converts a vector of floating-point numbers to a vector of unsigned\n      integers.",
        "result": "Each element of\n      r is obtained by truncating the\n      corresponding element of a to an\n      unsigned integer.  The current floating-point rounding mode is\n      ignored.",
        "endianness": "None.",
        "instructions": [ "xvcvspsxws", "xvcvdpsxds" ],
        "type_signatures": {
            "var_heads": [ "r", "a", "Example Implementation" ],
            "list": [
                [ "vector unsigned int", "vector float", "xvcvspsxws  r,a" ],
                [ "vector unsigned long long", "vector double", "xvcvdpsxds  r,a" ]
            ]
        }
    },
    {
        "mnemonic": "vec_unsigned2",
        "name": "Vector Convert Double-Precision to Unsigned Word",
        "syntax": "r = vec_unsigned2 (a, b)",
        "purpose": "Converts two vectors of double-precision floating-point numbers to a\n      vector of unsigned 32-bit integers.",
        "result": "Let v be the concatenation of a and b.  Each\n      element of r is obtained by truncating\n      the corresponding element of v to an\n      unsigned 32-bit integer.  The current floating-point rounding\n      mode is ignored.",
        "endianness": "The element numbering within a register is left-to-right for big-endian\n      targets, and right-to-left for little-endian targets.",
        "instructions": [ "xxpermdi", "xvcvdpuxws", "vmrgow", "vmrgew" ],
        "type_signatures": {
            "var_heads": [ "r", "a", "b", "Example LE\nImplementation", "Example BE\nImplementation" ],
            "list": [
                [ "vector unsigned int", "vector double", "vector double", "xxpermdi   t,b,a,3\n xxpermdi   u,b,a,0\n xvcvdpuxws v,t\n xvcvdpuxws w,u\n vmrgow     r,w,v", "xxpermdi   t,a,b,3\n xxpermdi   u,a,b,0\n xvcvdpuxws v,t\n xvcvdpuxws w,u\n vmrgew     r,v,w" ]
            ]
        }
    },
    {
        "mnemonic": "vec_unsignede",
        "name": "Vector Convert Double-Precision to Unsigned Word Even",
        "syntax": "r = vec_unsignede (a)",
        "purpose": "Converts elements of the source vector to unsigned integers and stores\n      them in the even-numbered elements of the result vector.",
        "result": "Element 0 of\n      r contains element 0 of a, truncated to an unsigned integer.  Element 2 of\n      r contains element 1 of a, truncated to a signed integer.  Elements 1 and\n      3 of r are undefined.  Truncation\n      of a negative number to an unsigned integer results in a value of\n      zero.",
        "endianness": "The element numbering within a register is left-to-right for big-endian\n      targets, and right-to-left for little-endian targets.",
        "instructions": [ "xvcvdpuxws", "vsldoi" ],
        "type_signatures": {
            "var_heads": [ "r", "a", "Example LE\nImplementation", "Example BE\nImplementation" ],
            "list": [
                [ "vector unsigned int", "vector double", "xvcvdpuxws t,a\n vsldoi     r,t,t,12", "xvcvdpuxws r,a" ]
            ]
        }
    },
    {
        "mnemonic": "vec_unsignedo",
        "name": "Vector Convert Double-Precision to Unsigned Word Odd",
        "syntax": "r = vec_unsignedo (a)",
        "purpose": "Converts elements of the source vector to unsigned integers and stores\n      them in the odd-numbered elements of the result vector.",
        "result": "Element 1 of\n      r contains element 0 of a, truncated to an unsigned integer.  Element 3 of\n      r contains element 1 of a, truncated to an unsigned integer.  Elements 0\n      and 2 of r are undefined.  Truncation\n      of a negative number to an unsigned integer results in a value of\n      zero.",
        "endianness": "The element numbering within a register is left-to-right for big-endian\n      targets, and right-to-left for little-endian targets.",
        "instructions": [ "xvcvdpuxws", "vsldoi" ],
        "type_signatures": {
            "var_heads": [ "r", "a", "Example LE\nImplementation", "Example BE\nImplementation" ],
            "list": [
                [ "vector unsigned int", "vector double", "xvcvdpuxws r,a", "xvcvdpuxws t,a\n vsldoi     r,t,t,12" ]
            ]
        }
    },
    {
        "mnemonic": "vec_xl",
        "name": "VSX Unaligned Load",
        "syntax": "r = vec_xl (a, b)",
        "purpose": "Loads a 16-byte vector from the memory address specified by the\n      displacement and the pointer.",
        "result": "The value of\n      r is obtained by adding a and b, then\n      loading the 16-byte vector from the resultant memory address.",
        "endianness": "For ISA 2.07, there is no bi-endian unaligned load instruction.\n      For little-endian targets, it is necessary to use the lxvd2x instruction\n      and swap the doublewords with an xxswapd instruction.  For big-endian\n      targets, the lxvd2x instruction or lxvw4x instruction suffices.  The\n      examples below assume ISA 3.0, where the bi-endian lxv instruction is\n      available.",
        "instructions": [ "lxv" ],
        "type_signatures": {
            "var_heads": [ "r", "a", "b", "Example ISA 3.0\nImplementation" ],
            "list": [
                [ "vector signed char", "signed long long", "const signed char *", "lxv  r,a(b)" ],
                [ "vector unsigned char", "signed long long", "const unsigned char *", "lxv  r,a(b)" ],
                [ "vector signed short", "signed long long", "const signed short *", "lxv  r,a(b)" ],
                [ "vector unsigned short", "signed long long", "const unsigned short *", "lxv  r,a(b)" ],
                [ "vector signed int", "signed long long", "const signed int *", "lxv  r,a(b)" ],
                [ "vector unsigned int", "signed long long", "const unsigned int *", "lxv  r,a(b)" ],
                [ "vector signed signed long long", "signed long long", "const signed long long *", "lxv  r,a(b)" ],
                [ "vector unsigned long long", "signed long long", "const unsigned long long *", "lxv  r,a(b)" ],
                [ "vector signed __int128", "signed long long", "const signed __int128 *", "lxv  r,a(b)" ],
                [ "vector unsigned __int128", "signed long long", "const unsigned __int128 *", "lxv  r,a(b)" ],
                [ "vector float", "signed long long", "const float *", "lxv  r,a(b)" ],
                [ "vector double", "signed long long", "const double *", "lxv  r,a(b)" ]
            ]
        }
    },
    {
        "mnemonic": "vec_xl_be",
        "name": "VSX Unaligned Load as Big Endian",
        "syntax": "r = vec_xl_be (a, b)",
        "purpose": "Loads a vector from an address into a register in big-endian element\n      order, regardless of the endianness of the target machine.",
        "result": "The value of\n      r is obtained by adding a and b, then\n      loading the vector elements from the resulting address in big-endian\n      order.",
        "endianness": "In big-endian mode, this acts just like the vec_xl intrinsic.\n      In little-endian mode, the highest-numbered element of r is loaded from the lowest data address, and\n      the lowest-numbered element of r from\n      the highest data address.",
        "instructions": [ "lxvb16x", "lxv", "lxvw4x", "lxvd2x", "lxvh8x" ],
        "type_signatures": {
            "var_heads": [ "r", "a", "b", "Example ISA 3.0 LE\nImplementation", "Example ISA 3.0 BE\nImplementation" ],
            "list": [
                [ "vector signed char", "signed long long", "const signed char *", "lxvb16x r,a,b", "lxv r,a,b" ],
                [ "vector unsigned char", "signed long long", "const unsigned char *", "lxvb16x r,a,b", "lxv r,a,b" ],
                [ "vector signed short", "signed long long", "const signed short *", "lxvh8x r,a,b", "lxv r,a,b" ],
                [ "vector unsigned short", "signed long long", "const unsigned short *", "lxvh8x r,a,b", "lxv r,a,b" ],
                [ "vector signed int", "signed long long", "const signed int *", "lxvw4x r,a,b", "lxv r,a,b" ],
                [ "vector unsigned int", "signed long long", "const unsigned int *", "lxvw4x r,a,b", "lxv r,a,b" ],
                [ "vector signed long long", "signed long long", "const signed long long *", "lxvd2x r,a,b", "lxv r,a,b" ],
                [ "vector unsigned long long", "signed long long", "const unsigned long long *", "lxvd2x r,a,b", "lxv r,a,b" ],
                [ "vector signed __int128", "signed long long", "const signed __int128 *", "lxv r,a,b", "lxv r,a,b" ],
                [ "vector unsigned __int128", "signed long long", "const unsigned __int128 *", "lxv r,a,b", "lxv r,a,b" ],
                [ "vector float", "signed long long", "const float *", "lxvw4x r,a,b", "lxv r,a,b" ],
                [ "vector double", "signed long long", "const double *", "lxvd2x r,a,b", "lxv r,a,b" ]
            ]
        }
    },
    {
        "mnemonic": "vec_xl_len",
        "name": "Vector Load with Length",
        "syntax": "r = vec_xl_len (a, b)",
        "purpose": "Loads a vector of a specified byte length.",
        "result": "Loads the number of\n      bytes specified by b from the address\n      specified in a. Initializes elements in\n      order from the byte stream (as defined by the endianness of the target).\n      Any bytes of elements that cannot be initialized from the\n      number of loaded bytes have a zero value.",
        "endianness": "None.",
        "instructions": [ "sldi", "lxvl" ],
        "type_signatures": {
            "var_heads": [ "r", "a", "b", "Example\nImplementation", "Restrictions" ],
            "list": [
                [ "vector signed char", "const signed char *", "size_t", "sldi  t,b,56\n  lxvl  r,a,t", "ISA 3.0 or later" ],
                [ "vector unsigned char", "const unsigned char *", "size_t", "sldi  t,b,56\n  lxvl  r,a,t", "ISA 3.0 or later" ],
                [ "vector signed short", "const signed short *", "size_t", "sldi  t,b,56\n  lxvl  r,a,t", "ISA 3.0 or later" ],
                [ "vector unsigned short", "const unsigned short *", "size_t", "sldi  t,b,56\n  lxvl  r,a,t", "ISA 3.0 or later" ],
                [ "vector signed int", "const signed int *", "size_t", "sldi  t,b,56\n  lxvl  r,a,t", "ISA 3.0 or later" ],
                [ "vector unsigned int", "const unsigned int *", "size_t", "sldi  t,b,56\n  lxvl  r,a,t", "ISA 3.0 or later" ],
                [ "vector signed long long", "const signed long long *", "size_t", "sldi  t,b,56\n  lxvl  r,a,t", "ISA 3.0 or later" ],
                [ "vector unsigned long long", "const unsigned long long *", "size_t", "sldi  t,b,56\n  lxvl  r,a,t", "ISA 3.0 or later" ],
                [ "vector signed __int128", "const signed __int128 *", "size_t", "sldi  t,b,56\n  lxvl  r,a,t", "ISA 3.0 or later" ],
                [ "vector unsigned __int128", "const unsigned __int128 *", "size_t", "sldi  t,b,56\n  lxvl  r,a,t", "ISA 3.0 or later" ],
                [ "vector float", "const float *", "size_t", "sldi  t,b,56\n  lxvl  r,a,t", "ISA 3.0 or later" ],
                [ "vector double", "const double *", "size_t", "sldi  t,b,56\n  lxvl  r,a,t", "ISA 3.0 or later" ]
            ]
        }
    },
    {
        "mnemonic": "vec_xl_len_r",
        "name": "Vector Load with Length Right-Justified",
        "syntax": "r = vec_xl_len_r (a, b)",
        "purpose": "Loads a vector of a specified byte length, right-justified.",
        "result": "Loads the number of\n      bytes specified by b from the address\n      specified in a, right justified in\n      r. Initializes elements in order from\n      the byte stream (as defined by the endianness of the target).\n      Any bytes of elements that cannot be initialized from the\n      number of loaded bytes have a zero value.",
        "endianness": "None.",
        "instructions": [ "sldi", "lvsl", "lxvll", "vperm" ],
        "type_signatures": {
            "var_heads": [ "r", "a", "b", "Example\nImplementation", "Restrictions" ],
            "list": [
                [ "vector unsigned char", "const unsigned char *", "size_t", "sldi  t,b,56\n  lvsl  u,0,b\n  lxvll v,a,t\n  vperm r,v,v,u", "ISA 3.0 or later" ]
            ]
        }
    },
    {
        "mnemonic": "vec_xor",
        "name": "Vector Exclusive OR",
        "syntax": "r = vec_xor (a, b)",
        "purpose": "Performs a bitwise XOR of two vectors.",
        "result": "v is the bitwise\n      exclusive OR of a and b.",
        "endianness": "None.",
        "instructions": [ "xxlxor" ],
        "type_signatures": {
            "var_heads": [ "r", "a", "b", "Example Implementation" ],
            "list": [
                [ "vector bool char", "vector bool char", "vector bool char", "xxlxor  r,a,b" ],
                [ "vector signed char", "vector signed char", "vector signed char", "xxlxor  r,a,b" ],
                [ "vector unsigned char", "vector unsigned char", "vector unsigned char", "xxlxor  r,a,b" ],
                [ "vector bool short", "vector bool short", "vector bool short", "xxlxor  r,a,b" ],
                [ "vector signed short", "vector signed short", "vector signed short", "xxlxor  r,a,b" ],
                [ "vector unsigned short", "vector unsigned short", "vector unsigned short", "xxlxor  r,a,b" ],
                [ "vector bool int", "vector bool int", "vector bool int", "xxlxor  r,a,b" ],
                [ "vector signed int", "vector signed int", "vector signed int", "xxlxor  r,a,b" ],
                [ "vector unsigned int", "vector unsigned int", "vector unsigned int", "xxlxor  r,a,b" ],
                [ "vector bool long long", "vector bool long long", "vector bool long long", "xxlxor  r,a,b" ],
                [ "vector signed long long", "vector signed long long", "vector signed long long", "xxlxor  r,a,b" ],
                [ "vector unsigned long long", "vector unsigned long long", "vector unsigned long long", "xxlxor  r,a,b" ],
                [ "vector float", "vector float", "vector float", "xxlxor  r,a,b" ],
                [ "vector double", "vector double", "vector double", "xxlxor  r,a,b" ]
            ]
        }
    },
    {
        "mnemonic": "vec_xst",
        "name": "VSX Unaligned Store",
        "syntax": "vec_xst (a, b, c)",
        "purpose": "Stores a 16-byte value into memory at the address specified by the\n      displacement and pointer.",
        "result": "The values of\n      b and c are added, and the value of a is stored to the resultant address.",
        "endianness": "For ISA 2.07, there is no bi-endian unaligned store instruction.  For\n      little-endian targets, it is necessary to first swap the doublewords\n      of the value to be stored using an xxswapd instruction, and then store\n      the result using the stxvd2x instruction.  For big-endian targets, the\n      stxvd2x or stxvw4x instruction suffices.  The examples below assume ISA\n      3.0, where the bi-endian stxv instruction is available.",
        "instructions": [ "stxv" ],
        "type_signatures": {
            "var_heads": [ "a", "b", "c", "Example ISA 3.0\nImplementation" ],
            "list": [
                [ "vector signed char", "signed long long", "signed char *", "stxv  a,b(c)" ],
                [ "vector unsigned char", "signed long long", "unsigned char *", "stxv  a,b(c)" ],
                [ "vector signed short", "signed long long", "signed short *", "stxv  a,b(c)" ],
                [ "vector unsigned short", "signed long long", "unsigned short *", "stxv  a,b(c)" ],
                [ "vector signed int", "signed long long", "signed int *", "stxv  a,b(c)" ],
                [ "vector unsigned int", "signed long long", "unsigned int *", "stxv  a,b(c)" ],
                [ "vector signed long long", "signed long long", "signed long long *", "stxv  a,b(c)" ],
                [ "vector unsigned long long", "signed long long", "unsigned long long *", "stxv  a,b(c)" ],
                [ "vector signed __int128", "signed long long", "signed __int128 *", "stxv  a,b(c)" ],
                [ "vector unsigned __int128", "signed long long", "unsigned __int128 *", "stxv  a,b(c)" ],
                [ "vector float", "signed long long", "float *", "stxv  a,b(c)" ],
                [ "vector double", "signed long long", "double *", "stxv  a,b(c)" ]
            ]
        }
    },
    {
        "mnemonic": "vec_xst_be",
        "name": "VSX Unaligned Store as Big Endian",
        "syntax": "vec_xst_be (a, b, c)",
        "purpose": "Stores a vector to an address using big-endian\n      element order, regardless of the endianness of the target machine.",
        "result": "The values of\n      b and c are added, and the value of a is stored to the resultant address using\n      big-endian element order.",
        "endianness": "In big-endian mode, this acts just like the vec_xst intrinsic.  In\n      little-endian mode, the lowest data address receives the\n      highest-numbered element of a, and\n      the highest data address receives the lowest-numbered element of\n      a.",
        "instructions": [ "stxvb16x", "stxv", "stxvw4x", "stxvd2x", "stxvh8x" ],
        "type_signatures": {
            "var_heads": [ "a", "b", "c", "Example ISA 3.0 LE\nImplementation", "Example ISA 3.0 BE\nImplementation" ],
            "list": [
                [ "vector signed char", "signed long long", "signed char *", "stxvb16x a,b,c", "stxv a,b,c" ],
                [ "vector unsigned char", "signed long long", "unsigned char *", "stxvb16x a,b,c", "stxv a,b,c" ],
                [ "vector signed short", "signed long long", "signed short *", "stxvh8x a,b,c", "stxv a,b,c" ],
                [ "vector unsigned short", "signed long long", "unsigned short *", "stxvh8x a,b,c", "stxv a,b,c" ],
                [ "vector signed int", "signed long long", "signed int *", "stxvw4x a,b,c", "stxv a,b,c" ],
                [ "vector unsigned int", "signed long long", "unsigned int *", "stxvw4x a,b,c", "stxv a,b,c" ],
                [ "vector signed long long", "signed long long", "signed long long *", "stxvd2x a,b,c", "stxv a,b,c" ],
                [ "vector unsigned long long", "signed long long", "unsigned long long *", "stxvd2x a,b,c", "stxv a,b,c" ],
                [ "vector signed __int128", "signed long long", "signed __int128 *", "stxv a,b,c", "stxv a,b,c" ],
                [ "vector unsigned __int128", "signed long long", "unsigned __int128 *", "stxv a,b,c", "stxv a,b,c" ],
                [ "vector float", "signed long long", "float *", "stxvw4x a,b,c", "stxv a,b,c" ],
                [ "vector double", "signed long long", "double *", "stxvd2x a,b,c", "stxv a,b,c" ]
            ]
        }
    },
    {
        "mnemonic": "vec_xst_len",
        "name": "Vector Store with Length",
        "syntax": "vec_xst_len (a, b, c)",
        "purpose": "Stores a vector of a specified byte length.",
        "result": "Stores the number of\n      bytes specified by c of the vector\n      a to the address specified in\n      b. The bytes are obtained starting from\n      the lowest-numbered byte of the lowest-numbered element (as defined by\n      the endianness of the target). All bytes of an element\n      are accessed before proceeding to the next higher element.",
        "endianness": "None.",
        "instructions": [ "sldi", "stxvl" ],
        "type_signatures": {
            "var_heads": [ "a", "b", "c", "Example Implementation", "Restrictions" ],
            "list": [
                [ "vector signed char", "signed char *", "size_t", "sldi   t,c,56\n  stxvl  a,b,t", "ISA 3.0 or later" ],
                [ "vector unsigned char", "unsigned char *", "size_t", "sldi   t,c,56\n  stxvl  a,b,t", "ISA 3.0 or later" ],
                [ "vector signed short", "signed short *", "size_t", "sldi   t,c,56\n  stxvl  a,b,t", "ISA 3.0 or later" ],
                [ "vector unsigned short", "unsigned short *", "size_t", "sldi   t,c,56\n  stxvl  a,b,t", "ISA 3.0 or later" ],
                [ "vector signed int", "signed int *", "size_t", "sldi   t,c,56\n  stxvl  a,b,t", "ISA 3.0 or later" ],
                [ "vector unsigned int", "unsigned int *", "size_t", "sldi   t,c,56\n  stxvl  a,b,t", "ISA 3.0 or later" ],
                [ "vector signed long long", "signed long long *", "size_t", "sldi   t,c,56\n  stxvl  a,b,t", "ISA 3.0 or later" ],
                [ "vector unsigned long long", "unsigned long long *", "size_t", "sldi   t,c,56\n  stxvl  a,b,t", "ISA 3.0 or later" ],
                [ "vector signed __int128", "signed __int128 *", "size_t", "sldi   t,c,56\n  stxvl  a,b,t", "ISA 3.0 or later" ],
                [ "vector unsigned __int128", "unsigned __int128 *", "size_t", "sldi   t,c,56\n  stxvl  a,b,t", "ISA 3.0 or later" ],
                [ "vector float", "float *", "size_t", "sldi   t,c,56\n  stxvl  a,b,t", "ISA 3.0 or later" ],
                [ "vector double", "double *", "size_t", "sldi   t,c,56\n  stxvl  a,b,t", "ISA 3.0 or later" ]
            ]
        }
    },
    {
        "mnemonic": "vec_xst_len_r",
        "name": "Vector Store with Length Right-Justified",
        "syntax": "vec_xst_len_r (a, b, c)",
        "purpose": "Stores a right-justified vector of a specified byte length.",
        "result": "Stores the number of\n      bytes specified by c of the\n      right-justified vector a to the address\n      specified by b.",
        "endianness": "None.",
        "instructions": [ "lvsr", "sldi", "vperm", "stxvll" ],
        "type_signatures": {
            "var_heads": [ "a", "b", "c", "Example Implementation", "Restrictions" ],
            "list": [
                [ "vector unsigned char", "unsigned char *", "size_t", "lvsr   t,0,c\n  sldi   u,c,56\n  vperm  v,a,a,t\n  stxvll v,b,u", "ISA 3.0 or later" ]
            ]
        }
    }
]
